<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XML学习</title>
    <url>/2021/05/12/XML%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/2021/06/02/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2021/05/12/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机基础知识</title>
    <url>/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JavaSE进阶</title>
    <url>/2021/05/30/JavaSE%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>抽象类和接口以及抽象类和接口的区别：<br>    抽象类：<br>        抽象类的定义：在class前添加abstract关键字<br>        抽象类是无法实例化的，所以抽象类是用来被子类继承的<br>        final和abstract不能联合使用，这两个关键字是对立的<br>        抽象类的子类可以是抽象类，也可以是非抽象类<br>        抽象类虽然无法实例化，但是抽象类有构造方法，构造方法是供子类使用的。<br>        抽象类中不一定有抽象方法，抽象方法必须在抽象类中。<br>        抽象方法的定义：public abstract void doSome();<br>        一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现</p>
<a id="more"></a>
<pre><code>java语言中凡是没有方法体的方法都是抽象方法。
        不对，错误的。
        Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
        都不是抽象方法，例如：
            public native int hashCode();
            这个方法底层调用了C++写的动态链接库程序。
            前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</code></pre><!--more-->
<pre><code>接口的基础语法：
    接口是一种‘引用数据类型’
    接口是完全抽象的
    接口的定义：[修饰符列表] interface 接口名{}
    接口的多继承
    接口中只有常量+抽象方法
    接口中所有的元素都是public修饰的
    接口中的抽象方法的public abstract可以省略
    接口中常量的public static final可以省略
    接口中方法不能有方法体
    一个非抽象的类，实现接口的时候，必须将接口中的所有方法实现
    一个类可以实现多个接口
    extends 和 implements可以共存，extends在前，impl在后
    使用接口，写代码时，可以使用多态

接口在开发中的作用：
    面向抽象编程---&gt;面向接口编程
    有了接口就实现拓展
    调用者面向接口调用，实现者面向接口编写实现

抽象类和接口的区别：
    抽象类是半抽象的，接口是完全抽象的
    抽象类中有构造方法，接口中没有
    接口和接口之间，支持多继承
    类和类之间只能单继承
    一个类可以同时实现多个接口，一个抽象类只能继承一个类
    接口中只允许出现常量和抽象方法
    接口使用的比抽象类多，抽象类使用少
    接口一般都是对“行为”的抽象</code></pre><p>import和package：<br>    package：<br>        必须出现在源文件的第一行<br>    import：<br>        java.lang包不需要引入<br>        同包下的java文件不需要引入</p>
<p>private 表示私有的，只能在本类中访问<br>        public 表示公开的，在任何位置都可以访问<br>        “默认”表示只能在本类，以及同包下访问。<br>        protected表示只能在本类、同包、子类中访问。</p>
<p>JDK类库根类：Object<br>    需要知道的几个方法：<br>        protected Object clone()   // 负责对象克隆的。<br>         int hashCode()    // 获取对象哈希值的一个方法。<br>        boolean equals(Object obj)  // 判断两个对象是否相等<br>            以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。<br>            重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。<br>            基本数据类型比较实用：==<br>            对象和对象比较：调用equals方法<br>            String类是SUN编写的，所以String类的equals方法重写了。<br>            以后判断两个字符串是否相等，最好不要使用==，要调用字符串对象的equals方法。<br>            注意：重写equals方法的时候要彻底。<br>        String toString()  // 将对象转换成字符串形式<br>            以后的所有的类的toString()方法是需要重写的，System.out.println(引用);<br>             这里会自动调用“引用”的toString()方法。String类是SUN写，toString方法已经重写了。<br>        protected void finalize()  // 垃圾回收器负责调用的方法</p>
<p>数组：<br>    理解：空间存储上，内存地址是连续的，每个元素占用的空间大小形同，知道首元素的内存地址，知道下标可以计算出偏移量，<br>    优点：检索效率高<br>    缺点：随机增删效率较低，数组无法存储大数据量<br>    数组最后一个元素的增删效率不受影响</p>
<pre><code>一维数组的静态初始化和动态初始化
    静态初始化：
        int []arr ={1,2,3,4};
        Object[] objs = {new Object(), new Object(), new Object()};
    动态初始化：
        int[] arr = new int[4]; // 4个长度，每个元素默认值0
        Object[] objs = new Object[4]; // 4个长度，每个元素默认值null                        

数组的拷贝：System.arraycopy()方法的使用
    数组的特点：长度一旦确定，不可变
    数组长度不够的时候，需要扩容，扩容机制：新建一个更大的数组
    将小数组中数据拷贝到大数组中，小数组对象被垃圾回收</code></pre><p>String类：<br>    理解：<br>        字符串一旦创建，不可修改<br>        双引号括起来的字符串存储在字符串常量池中<br>        字符串的比较使用的是equals方法<br>        String已经重写了toString()和equals()方法<br>    String的构造方法：<br>        String s = “abc”;<br>        String s = new String(“abc”);<br>        String s = new String(byte数组);<br>        String s = new String(byte数组, 起始下标, 长度);<br>        String s = new String(char数组);<br>        String s = new String(char数组, 起始下标, 长度);<br>    采用双引号赋值字符串，在编译期将会放到方法区中的字符串的常量池，如果是运行时对字符串相加或者相减会放到堆中（放之前会验证方法区中是否含有相同的字符串常量，如果存在，把地址返回，如果不存在，先将字符串常量放到池中，然后返回该对象的地址）<br>    String常用方法：<br>        1. endsWith：判断字符串是否以指定的后缀结束<br>        2. startsWith，判断字符串是否以指定的前缀开始<br>        3. equals，字符串相等比较，不忽略大小写<br>        4. equalsIgnoreCase，字符串相等比较，忽略大小写<br>        5. indexOf，取得指定字符在字符串的位置<br>        6. lastIndexOf，返回最后一次字符串出现的位置<br>        7. length，取得字符串的长度<br>        8. replaceAll，替换字符串中指定的内容<br>        9. split，根据指定的表达式拆分字符串<br>        10. substring，截子串<br>        11. trim,去前尾空格<br>        12. valueOf，将其他类型转换成字符串<br>    使用String时注意：<br>        String是不可变对象，如果多个字符串拼接，就会产生多个对象，会造成内存溢出</p>
<p>StringBuffer和StringBuilder<br>    StringBuffer和StringBuilder可以看做可变长度的字符串<br>    StringBuffer和StringBuilder初始化容量为16<br>    StringBuffer和StringBuilder是完成字符串拼接操作的，方法名：append<br>    频繁进行字符串拼接不建议使用‘+’<br>    StringBuffer（字符串缓冲区）:<br>        工作原理：<br>            预先申请一块内存，存放字符序列，如果字符序列满了，重新改变缓存区的大小，StringBuffer是可变对象，这个是String最大的不同<br>    StringBuilderr：<br>        用法和Buffer一样，区别是StringBuffer方法是同步的，是线程安全的，但速度慢，StringBuilder速度快，线程不安全<br>八中基本数据类型对应的包装类：<br>    包装类存在的作用：方便编程<br>    八种包装类的类名：<br>        Byte<br>        Short<br>        Integer<br>        Long<br>        Float<br>        Double<br>        Boolean<br>        Character<br>    所有的数字的父类Number       </p>
<p>日期类：<br>    获取系统当前时间：<br>        Date d = new Date();<br>    日期格式化：Date –&gt; String<br>        yyyy-MM-dd HH:mm:ss SSS<br>        SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss SSS”);<br>        String s = sdf.format(new Date());<br>    String –&gt; Date<br>        SimpleDateFormat sdf = new SimpleDate(“yyyy-MM-dd HH:mm:ss”);<br>        Date d = sdf.parse(“2008-08-08 08:08:08”);<br>    获取毫秒数<br>        long begin = System.currentTimeMillis();<br>        Date d = new Date(begin - 1000 * 60 * 60 * 24);</p>
<p>数字类<br>    DecimalFormat数字格式化<br>        ###,###.## 表示加入千分位，保留两个小数。<br>        ###,###.0000 表示加入千分位，保留4个小数，不够补0<br>    BigDecimal<br>        财务软件中通常使用BigDecimal</p>
<p>随机数<br>    怎么产生int类型随机数。<br>        Random r = new Random();<br>        int i = r.nextInt();<br>    怎么产生某个范围之内的int类型随机数。<br>        Random r = new Random();<br>        int i = r.nextInt(101); // 产生[0-100]的随机数。</p>
<p>枚举<br>    枚举是一种引用数据类型。<br>    枚举编译之后也是class文件。<br>    枚举类型怎么定义？<br>        enum 枚举类型名{<br>            枚举值,枚举值2,枚举值3<br>        }<br>    当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来的时候，建议返回值类型设计为枚举类型。</p>
<p>异常处理机制：<br>    java中异常的作用:增强程序的健壮性<br>    java中的异常以类和对象的形式存在</p>
<p>java的异常处理机制：<br>    异常在java中以类和对象的形式存在<br>    Object<br>    Object下有Throwable（可抛出的）<br>    Throwable下有两个分支：Error：（不可处理的，直接退出JVM）和Exception（可处理的）<br>    Exception下有两个分支：<br>        Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。<br>        RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）<br>    java对异常的处理的两种方式：<br>        使用throws关键字，抛给上一级<br>        使用try……catch语句进行异常的抓捕<br>        java出现异常，如果一直往上抛，最终会抛给main方法，main方法再往上抛给了JVM，JVM知道异常后，终止java程序的执行。<br>    异常捕获的顺序：从小到大<br>    子类方法不能抛出比父类方法更多的异常</p>
<p>集合：<br>    Java主要有3个重要的集合<br>        List:一个有序的集合，可以放重复的数据<br>        Set:无序的集合，不允许放重复的数据<br>        Map:一个无序的集合，包含一个键对象和一个值对象，键对象不重复，值对象可以重复<br>    Collection和Iterator：<br>        Collection是List和Set的父接口，在Collection中定义一些主要方法<br>        Iterator：迭代接口，通过此接口可以遍历集合中的数据<br>    List接口：<br>        主要实现了ArrayList和LinkedList，都是由顺序的基于线性存储，可以看成是可变数组。<br>        ArrayList：查询数据比较快，添加和删除数据比较慢（基于可变数组）<br>        LinkedList：查询数据比较慢，添加和删除数据比较快（基于链式数据结构）<br>        Vector：不建议使用，方法是同步的，效率慢，已经被ArrayList取代<br>        Stack：是继承Vector实现的一个栈，栈结构是后进先出的，已经被LinkedList取代<br>    Set接口：<br>        哈希表：一种数据结构，用于提供快速存取操作，基于数组。<br>        HashSet：存储的数据是无序的不可重复的，按照哈希算法存取数据，具有很好的性能<br>            工作原理：插入数据的时候，调用对象的hashCode得到对象的哈希吗，根据哈希吗计算出对象插入集合的位置。<br>        equals和hashCode:</p>
<pre><code>    TreeSet:
        可以对Set集合进行排序，默认自然升序排序
Map接口：
    可以放置键值对，也就是每个元素都包含键对象和值对象，Map实现较为常用的为HashMap，HashMap对键对象的存取和HashSet一样，仍采用哈希算法，所以如果使用自定类作为Map的键对象，必须复写equals和hashCode方法。
    HashMap：

    TreeMap：</code></pre><p>基本类型的包装类：<br>    作用：提供更多实用的操作，更容易处理基本类型，所有的包装类都是final的，所以不能创建子类，包装类都是不可变对象<br>    byte    Byte<br>    short   Short<br>    char    Character<br>    int     Integer<br>    long    Long<br>    float   Float<br>    double  Double<br>    boolean Boolean</p>
<p>JDK5.0新特性：<br>    JDK5.0之前包装类和基本类型做运算时，必须将包装类转换为基本类型。JDK5.0提供自动装箱拆箱Auto-boxing/unboxing</p>
<p>泛型：</p>
<p>2021-6-3 </p>
<p>IO流：要站在内存的角度，看输出和输入<br>    概述：文件通常是一连串的字节和字符构成，组成文件的字节序列称为字节流，组成文件的字符序列称为字符流。java根据流的方向分为输入流和输出流。</p>
<pre><code>输入流：将文件或其他输入设备的数据加载到内存的过程；
输出流：将内存中的数据保存到文件或者其他输出设备中

Java语言将IO分为：字节输入\输出流和字符输入\输出流

InputStream（字节输入流）:
    InputStream是一个抽象类，所有继承InputStream的类都是字节输入流
OutputStream（字节输出流）：   
    所有继承OutputStream的类都是字节输出流
Reader（字符输出流）：
    所有继承Reader的类都是字符输入流
Writer（字符输出流）： 
    所有继承Writer都是字符输出流

文件流：
    文件流主要分为：文件字节输入流、文件字节输出流、文件字符输入流、文件字符输出流

    FileInputStream(文件字节输入流):
        主要按照字节方式读取文件
        注意：如果是读取的是中文，按照字节读入，然后直接打印在控制台的话，会发生乱码，因为汉字是按照两个自己存储的，按照一个字节打印汉字是不完整的。
    FileOutputStream(文件字节输出流)：
        按照字节方式写文件，例如文件的复制，首先读取文件，读取文件后将文件保存在另一个磁盘上，就完成了备份。
    FileReader(文件字符输入流):
        以字符为单位读取字符，也就是一次读取两个字节，采用字符输入流读取文本文件，汉字就不乱码了。
    FileWriter(文件字符输出流):
        输出字符流到文本文件。

缓冲流：
    目的：为了提升效率，减少物理读取次数。
    缓冲流主要有：：BufferedInputStream、BufferedOutputStream，BufferedReader、BufferedWriter
    BufferedReader 提供了实用方法readLine()，可以直接读取一行，BufferWriter 提供了 newLine()可以写换行符。

转换流：   
    包括InputStreamReader 和 OutputStreamWriter
    InputStreamReader：将字节流输入流转换为字符输入流
    OutputStreamWriter：主要是将字节流输出流转换成字符输出流

打印流：
    包括：PrintStream 字节流和 PrintWriter字符流</code></pre><p>对象流：</p>
<p>​    对象流可以将Java对象转换为二进制写入磁盘，这个过程通常叫做序列化，并且还可以从磁盘里读出完整java对象，而这个过程叫做反序列化。</p>
<p>对象流主要包括：ObjectInputStream 和 ObjectOutputStream </p>
<p>实现序列化和反序列化：</p>
<p>​    实现序列化该类必须实现序列化接口 java.io.Serializable,该接口没有任何方法，该接口只是一种标记接口，标记这个类是可序列化的</p>
<p>序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class ObjectStreamTest02 &#123; </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">ObjectOutputStream oos &#x3D; null; </span><br><span class="line"></span><br><span class="line">try &#123; </span><br><span class="line">oos &#x3D; new ObjectOutputStream( new FileOutputStream(&quot;c:&#x2F;Person.dat&quot;)); </span><br><span class="line">Person person &#x3D; new Person(); </span><br><span class="line">person.name &#x3D; &quot;张三&quot;; </span><br><span class="line">oos.writeObject(person); </span><br><span class="line">&#125;catch(FileNotFoundException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;catch(IOException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;finally &#123; </span><br><span class="line">try &#123; </span><br><span class="line">if (oos !&#x3D; null) &#123; </span><br><span class="line">oos.close(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;catch(IOException e) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现序列化接口 </span><br><span class="line">class Person implements Serializable&#123; </span><br><span class="line">String name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化，过程类似</p>
<p>关于transient关键字：一个类实现Serializable接口后，类中的某个属性被transient关键字修饰后，序列化时会被忽略</p>
<p>serialVersionUID ：序列化有关 </p>
<p>File类：</p>
<p>​    提供了大量的文件操作：删除文件，修改文件，得到文件的修改日期，建立目录，列表文件。</p>
<p>zip格式：</p>
<p>​    参见java.util.zip.*包下的api</p>
<p>多线程</p>
<p>多线程概念：线程指的是进程中的一个执行场景，也就是执行流程。</p>
<p>​    每一个进程是一个应用程序，都有独立的内存空间</p>
<p>​    同一个进程的线程中的线程共享其进程中的内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的。）</p>
<p>什么是进程？</p>
<p>​    一个进程就是一个应用程序。在操作系统中每启动一个应用程序就会启动一个进程。例如：qq进程，word进程……。</p>
<p>系统引入多进程的作用：最初的计算机是“单进程的”，计算机只能运行一个应用程序，例如第一台计算机只有 </p>
<p>DOS 窗口。现代的计算机可以满足我们一边听音乐，一边玩游戏。现代的计算给我们人类感 </p>
<p>觉：多件事情一起运行。感觉是并行的（错觉）。</p>
<p>对于单核的计算机来讲，在某一个时间点上只能做一件事情，但是由于计算机的处理速度 </p>
<p>很高，多个进程之间完成频繁的切换执行，这个切换速度使人类产生了错觉，人类的错觉是：多个进程在同时运行。 </p>
<p>计算机引入多进程的作用：提高 <strong>CPU</strong> <strong>的使用率</strong>。 </p>
<p><strong>重点：进程和进程之间的内存独立。</strong> </p>
<p>什么是线程：线程是进程的一个执行场景。一个进程可以启动多个线程。 </p>
<p><strong>进程引入多线程的作用？</strong></p>
<p>提高进程的使用率。 </p>
<p><strong>重点：线程和线程之间栈内存独立，堆内存和方法区内存共享。一个线程一个栈。</strong> </p>
<p><strong>描述</strong> <strong>java</strong> <strong>程序的执行原理：</strong> </p>
<p>java 命令执行会启动 JVM，JVM 的启动表示启动一个应用程序，表示启动了一个进程。 </p>
<p>该进程会自动启动一个“主线程”，然后主线程负责调用某个类的 main 方法。所以 main 方法 </p>
<p>的执行是在主线程中执行的。然后通过 main 方法代码的执行可以启动其他的“分支线程”。 </p>
<p>所以，main 方法结束程序不一定结束，因为其他的分支线程有可能还在执行。 </p>
<p>线程的创建和启动：<br>    java虚拟机的主线程入口是main方法，用户可以自己创建线程，创建方式有两种：</p>
<p>​    继承Thread类</p>
<p>​    实现Runnable接口（推荐使用Runnable接口）</p>
<p>继承Thread类：</p>
<p>Thread类中创建线程最重要的两个方法：</p>
<p>public void run()</p>
<p>public void start()</p>
<p>采用</p>
]]></content>
  </entry>
  <entry>
    <title>MatLab学习</title>
    <url>/2021/07/11/MatLab%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>学习资料来自：公众号：二进制人工智能，回复matlab。<br>2021-7-10<br>Matlab操作界面了解，搜索路径<br>2021-7-11<br>clc：清空命令行窗口的数据<br>doc，with，help：可以了解matlab的使用和函数用法查找<br>矩阵乘法：*<br>数组乘法：.*</p>
<p>inv(矩阵)函数返回的是矩阵得转置</p>
<p>语句后面加上分号的话，不显示结果，可以继续执行<br>MATLAB提供数据转换函数来实现数据类型的转换</p>
<p>整形：<br>    无符号整数：无符号 8,16,32,64位整数范围：0-2的8次方-1；<br>    有符号整数：带符号8,16,32,64位整数范围：-2的七次方-2的七次方-1</p>
<p>浮点型：<br>    分为单精度和双精度两种类型，单精度实数占用内存4个字节，双精度实数占用内存8个字节，双精度型精度更高。<br>    single函数：将其他类型转化为单精度类型；<br>    double函数：将其他类型转化为双精度类型；</p>
<p>复数型：<br>    复数类型包括实部和虚部两个部分，实部和虚部默认为双精度型，虚部单位用i表示。<br>    函数：<br>        real() %求复数的实部<br>        imag() %求复数的虚部</p>
<p>数值数据的输出格式(format)<br>    format long %设置输出为long型<br>    format %恢复默认输出格式<br>    tip：format命令指示影响数据输出的格式，不影响数据的计算和储存。</p>
<p>常用数学函数：</p>
<pre><code>函数调用的格式：函数名(函数自变量的值)
函数的自变量为矩阵形式（标量本身也是一种矩阵的特例）。
函数在运算时，将函数逐项作用于矩阵的每一个元素上，所以最后运算的结果是与自变量同型的矩阵。
    &gt;&gt; A = [pi/2,pi/4;-pi/2,-pi/4]
    A =
        1.5708    0.7854
        -1.5708   -0.7854
    &gt;&gt; sin(A)
    ans =
        1.0000    0.7071
        -1.0000   -0.7071</code></pre><p>常用函数（sin，sind，abs，取整）<br>    sin，cos这样的三角函数中输入的是以弧度为单位的数，如果想输入以角度为单位的数，用sind和cosd函数</p>
<pre><code>abs函数可以求实数的绝对值，复数的模，字符串的ASCII码值。

取整函数：round按照四舍五入，ceil按照向上取整，floor按照向下取整，fix固定取靠近0的那个整数即舍弃小数的取整。

rem(m,n)%求m/n的与余数
isprime(n)%判断n是否是素数，是则返回1，否则返回0

find(A)函数：返回向量中非零元素的位置</code></pre><p>变量与赋值语句：<br>    变量名以字母开头，后接字母，数字，下划线，区分大小写，标准函数名以及命令名必须用小写字母。</p>
<p>预定义变量：ans是默认的赋值变量；i，j代表叙述单位；pi代表圆周率；NaN代表非数（在绘图的时候，如果想裁掉一部分，只要把裁掉的部分的坐标设置为NaN）</p>
<p>查看修改变量：who/whos,whos显示的信息更多</p>
<p>内存变量文件（save,load）<br>    用于保存Matlab工作区变量的文件叫做内存变量文件，其扩展名为.mat，也叫MAT文件，是一种标准的二进制格式文件。<br>    save命令：创建内存变量文件<br>    load命令：载入内存变量文件<br>    save mydata a x   % 将a x保存在mydata.mat文件中<br>    load mydata       % 载入mydata.mat中的变量</p>
<p>MATLAB矩阵的表示：  </p>
<pre><code>1：矩阵元素用中括号扩起来，按照行的顺序输入个各元素
2：同一行的元素可以用逗号或者空格分隔开
3：不同行的元素用分号分割</code></pre><p>MATLAB矩阵的拼接：<br>    A=[1,2,3,4;5,6,7,8]<br>    B=[4,3,2,1;0,9,8,7]<br>    C=[A;B]%B矩阵在A矩阵的下面<br>    C1=[A,B]%B矩阵在A矩阵右边</p>
<p>构建复数矩阵：<br>    B=[1,2,3;4,5,6];<br>    C=[6,7,8;9,10,11];<br>    A=B+i*C<br>A =<br>   1.0000 + 6.0000i   2.0000 + 7.0000i   3.0000 + 8.0000i<br>   4.0000 + 9.0000i   5.0000 +10.0000i   6.0000 +11.0000i</p>
<p>冒号表达式：<br>    格式   初始值:步长:终止值</p>
<p>结构矩阵：<br>    &gt;&gt; class(1).n1=18;class(1).xm=’XIaoming’;class(1).xh=[1,2,3,4,5];</p>
<blockquote>
<blockquote>
<p> class(2).n1=19;class(2).xm=’XIaohong’;class(2).xh=[1,2,3,4,6];<br>class(3).n1=10;class(3).xm=’Xiaojun’;class(3).xh=[1,2,3,4,9];<br>whos<br>  Name       Size            Bytes  Class     Attributes</p>
</blockquote>
</blockquote>
<p>  class      1x3              1390  struct              </p>
<blockquote>
<blockquote>
<p>class</p>
</blockquote>
</blockquote>
<p>class = </p>
<p>1x3 struct array with fields:</p>
<pre><code>n1
xm
xh</code></pre><blockquote>
<blockquote>
<p>class(1)</p>
</blockquote>
</blockquote>
<p>ans = </p>
<pre><code>n1: 18
xm: &apos;XIaoming&apos;
xh: [1 2 3 4 5]</code></pre><blockquote>
<blockquote>
<p>class1 = class</p>
</blockquote>
</blockquote>
<p>class1 = </p>
<p>1x3 struct array with fields:</p>
<pre><code>n1
xm
xh</code></pre><blockquote>
<blockquote>
<p>class1(1).xh</p>
</blockquote>
</blockquote>
<p>ans =</p>
<pre><code>1     2     3     4     5</code></pre><blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>单元矩阵：<br>    单元矩阵类型，可以把不同的数据放在一个变量中，单元矩阵与结构矩阵不一样，单元矩阵的一个元素就是一个数据</p>
<p>矩阵元素的引用：<br>    1，通过下标来引用矩阵的元素，A(3,1)表示A矩阵的第三行第二列的元素。<br>    2，通过序号来引用，matlab是按照列进行元素存储的，存储完第一列元素后，继续存储第二列的元素。<br>    矩阵元素的序号和下标可以利用sub2ind和ind2sub函数进行相互转化</p>
<p>利用冒号表达式获得子矩阵：<br>    获取第i行的全部元素A(i,:)<br>    获得第j列的全部元素A(:,j)<br>    获得第i<del>i+m行内且在第k</del>k+m列中的所有元素A(i:i+m,k:k+m)<br>    获得第i~i+m行的所有元素A(i:i+m,:)</p>
<p>end运算符: 表示某一维的末尾元素下标</p>
<p>改变矩阵的形状(reshape):reshape(A,m,n)<br>    函数只是改变原矩阵的行数和列数，不改变原矩阵的元素个数以及存储顺序。<br>    例如：<br>    X = [23,45,65,34,65,34,98,45,6,7,89,6]<br>    y = reshape(X,3,4)% y矩阵是3行4列，按列存储<br>    y =<br>    23    34    98     7<br>    45    65    45    89<br>    65    34     6     6</p>
<p>MATLAB基本运算：<br>    基本算数运算：<br>        加+   减-   乘*   左除\  右除/  乘方^<br>    MATLAB的算数运算是在矩阵意义下运行的。<br>    单个数据的算数运算只是矩阵运算的一种特例<br>    加法运算：<br>        如果两矩阵同型，则运算时两矩阵的对应元素相加减。<br>        如果两个矩阵不同型，则matlab将给出错误信息<br>        一个标量也可以和矩阵进行加减运算，这时把标量和矩阵的每一个元素进行加减运算<br>    乘法运算：</p>
<p> 矩阵A和B进行乘法运算，要求A的列数与B的行数相等，则称矩阵A，B是可乘的。<br>    如果两矩阵维数或者大小不相容，会报错。<br>除法运算：<br>    在MATLAB中，有两种矩阵除法：左除/和右除\。<br>    如果A矩阵是非奇异矩阵，则B/A等效于 B * inv(A), A\B等效于inv(A) * B     (奇异矩阵就是行列式为0的矩阵，一个矩阵可逆，说明一个矩阵是非奇异矩阵)<br>乘方运算：<br>    A^2 = A<em>A<br>点运算：<br>    点运算符：四个：.</em>     ./      .\       .^    。<br>    两矩阵进行点运算指的是他们的对应元素进行相关运算，要求两矩阵同型。<br>关系运算：<br>    关系运算符：&lt;小于，&lt;=小于等于，&gt;大于，=&gt;大于等于， ==等于，<del>=不等于。<br>    当两个比较量是标量时，直接比较两个数的大小，正确则返回1，否则返回0。<br>    当比较的量是两个同型的矩阵时，比较的是两对矩阵相同位置的元素按照标量关系运算规则逐个进行，最终的关系运算的结果是一个与原矩阵同型的矩阵，元素由0，1组成。<br>    当参与比较的一个是标量一个是矩阵的时候，标量与矩阵的每一个元素进行比较，最终的结果返回与原矩阵相同的矩阵，元素由0，1组成。<br>逻辑运算<br>    运算符：&amp;（与），|（或），和</del>（非）<br>    a，b两个标量，<br>    a&amp;b：a，b全为零的时候，运算结果为1，否则为0；<br>    a|b：a，b只要有一个不为零，运算结果就为1；<br>    ~a：a为1，，结果为0<br>    参与逻辑运算的如果是两个同型矩阵，那么将会对矩阵相同位置上的元素，按照标量规则进行运算返回一个与原矩阵同型的矩阵，元素由0，1组成；</p>
<p>字符串处理：<br>    在matlab中，字符串是用单括号括起来的，创建字符串过程中，如果字符串中有单引号的话，用两个单引号表示字符串中的一个字符串。创建字符串矩阵实例：ch = [‘abcdef’,’123456’];<br>    字符串的操作：<br>        字符串作为命令执行：eval(s);s中为matlab的命令字符串<br>        字符串与数值之间的转换：abs和double函数可以用来获取字符串矩阵所对应的ASCII码矩阵；char函数可以把ASCII码矩阵转换为字符串矩阵；<br>    字符串的比较：（关系运算符或者是利用字符串比较函数）<br>        1，关系比较符，字符串里的每个字符按照ASCII码进行逐个比较，比较的结果是一个数值向量，向量要么是1，或者是0。<br>        2，字符串比较函数：<br>            1)strcmp(s1,s2):用来比较字符串s1和s2是否相等，如果相等返回1，否则返回0。<br>            2)strncmp(s1,s2,n):用来比较两个字符串前n个是否相等，如果相等返回1，否则返回0。<br>            3)strcmpi(s1,s2):在忽略字母大小写前提下，比较量字符串是否相等，相等返回1，否则返回0。<br>            4)strncmpi(s1,s2,n):忽略字符串大小写，比较前n个字符串是否相等，相等返回1，否则返回0。<br>    字符串的查找和替换：<br>        find(s1,s2):返回短字符串在长字符串中的开始位置。<br>        strrep(s1,s2,s3):返回字符串s1中的所有子字符串s2替换为字符串s3.</p>
<p>—————————-第一章一天终于给肝完了，还有八章😣o(╥﹏╥)o———————————————–</p>
<p>———–2021-7-12————-第二章，都是矩阵，线代忘得差不多了…… 开始！！！！！！—————————-</p>
<p>size(A):返回矩阵的大小。<br>format rat：输出格式将小数形式转化为分数形式<br>矩阵的特征值：</p>
<p>特殊矩阵：<br>      通用型矩阵：<br>        zero函数：产生全0矩阵，即零矩阵。<br>        ones矩阵：产生全是1矩阵，即幺矩阵。<br>        eye函数：产生对角线段不为1的矩阵，当矩阵是方阵的时候，得到一个单位矩阵。<br>        rand函数：产生（0，1）区间的均匀分布的随机矩阵。<br>        randn函数：产生均值为0，方差为1的标准正泰分布随机矩阵 。</p>
<p>​    用于专门学科的特殊矩阵：<br>​        魔方矩阵–Magic Square<br>​            特点：n阶魔方矩阵由1，2，3…n^2共n^2个整数组成，且每行，每列，主副对角线上的n个元素之和都相等；n阶魔方矩阵每行每列元素之和为（1+2+3+…+n^2）/n = (n+n^3)/2。<br>​            MATLAB函数的magic(n)产生特定的魔方矩阵。<br>​        范德蒙矩阵：<br>​            <img src="https://img-blog.csdnimg.cn/20200225223730821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="范德蒙矩阵"><br>​        希尔伯特矩阵：<br>​            <img src="https://img-blog.csdnimg.cn/20200225223910101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​        伴随矩阵：<br>​            <img src="https://img-blog.csdnimg.cn/20200225224117756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​            <img src="https://img-blog.csdnimg.cn/20200225224219403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​        帕斯卡矩阵：<br>​            <img src="https://img-blog.csdnimg.cn/20200225224445440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​            例子：<br>​            <img src="https://img-blog.csdnimg.cn/20200225224515349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>矩阵变换：<br>    对角阵：只有对角线上有非零元素的矩阵。<br>    数量矩阵：对角线上的元素相等的对角矩阵。<br>    单位矩阵：对角线上的元素都为1的对角矩阵。<br>    相关函数：<br>        提取对角线元素：<br>       <img src="https://img-blog.csdnimg.cn/20200225225014735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        构造对角矩阵<br>       <img src="https://img-blog.csdnimg.cn/2020022522511771.png" alt="在这里插入图片描述"></p>
<p>三角阵：<br>    上三角矩阵：<br>    <img src="https://img-blog.csdnimg.cn/20200225225517654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    下三角矩阵：<br>    <img src="https://img-blog.csdnimg.cn/20200225225548956.png" alt="在这里插入图片描述"></p>
<p>矩阵的转置：<br>    两者对于实矩阵没有差异，均表示转置矩阵<br>    ctranspose, ‘表示复共轭转置，转置后虚部符号相反。<br>    transpose, .’表示非共轭转置，转置后虚部不变</p>
<p>矩阵的旋转：<br>    <img src="https://img-blog.csdnimg.cn/20200225225828259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>矩阵的翻转：<br>    <img src="https://img-blog.csdnimg.cn/20200225225949126.png" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/2020022523065439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>矩阵的求逆矩阵：<br>    对于一个方阵A，如果存在一个与其同阶的方阵使得AB=BA=I（I为单位矩阵）则称B为A的逆矩阵，A也是B的逆矩阵。<br>    函数：inv(A),求方阵A的逆矩阵<br>    例子🌰：<br>    <img src="https://img-blog.csdnimg.cn/20200225231016428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>矩阵求值：<br>    矩阵的行列式：<br>        把一个方阵看做一个行列式，按照行列式的规则求值，这个值就是方阵对应的行列式的值。<br>        det(A):求方阵A所对应的行列式的值。（必须是方阵）<br>    矩阵的秩：<br>        概念：矩阵线性无关的行数或者列数称为矩阵的秩。<br>        函数：rank(A),求矩阵的秩。<br>    矩阵的迹：<br>        概念：矩阵的迹等于矩阵的对角线元素之和，也等于矩阵的特征值之和。<br>        函数：trace(A),求矩阵A的迹。<br>    向量和矩阵的范数：<br>        矩阵或者向量的范数用来度量矩阵或者向量在某种意义下的长度。<br>        <img src="https://img-blog.csdnimg.cn/20200225232020998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    矩阵的条件数：<br>        <img src="https://img-blog.csdnimg.cn/20200225232406378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>矩阵的特征值与特征向量：<br>    特征值的数学定义：（有点忘记了，￣□￣｜｜）<br>        <img src="https://img-blog.csdnimg.cn/20200226010535257.png" alt="在这里插入图片描述"><br>    求矩阵的特征值和特征向量：<br>        <img src="https://img-blog.csdnimg.cn/20200226010633561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>稀疏矩阵：<br>    稀疏矩阵指的是零元素个数远远多于非零元素个数的矩阵，如果将大量的零元素也存储，会导致存储空间的浪费。MATLAB为稀疏矩阵提供特殊的存储方式。</p>
<p>1：完全存储方式<br>2：稀疏存储方式：矩阵值存储矩阵的非零元素的值及其位置，即行号和列号。<br>    注意：采取稀疏矩阵存储方式时，矩阵元素的存储顺序并没有改变，还是按照列顺序进行存储。</p>
<p>稀疏存储方式的产生：<br>    完全存储方式与稀疏存储方式之间的转化：<br>        A = sparse(S):将矩阵S转化为稀疏矩阵方式的<br>        S = full(A):将矩阵A转化为完全存储方式的矩阵S。<br>    🌰：<br>        <img src="https://img-blog.csdnimg.cn/20200226023304423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>直接建立稀疏存储矩阵：<br>    sparse函数的其他调用函数：<br>        sparse(m,n):生成一个mxn的所有元素都是零的稀疏矩阵。<br>        sparse(u,s,S):其中u，v，S是3个等长的向量。S是要建立的稀疏存储矩阵的非零元素<br>    🌰：<br>        <img src="https://img-blog.csdnimg.cn/2020022602353898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>spconvert函数：<br>    <img src="https://img-blog.csdnimg.cn/2020022602383560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用A的一行元素来表示一个稀疏矩阵的一个元素，相当于A每一行的每个元素是相应的稀疏矩阵元素的一个信息。这些信息经过spconvert函数就可以得到相应的稀疏矩阵元素。</p>
<p>带状稀疏矩阵的稀疏存储：<br>    稀疏矩阵有两种基本类型：无规则结构的稀疏矩阵，有结构的稀疏矩阵。</p>
<p>带状稀疏矩阵：所有非零元素集中在对角线上的矩阵。<br>1）：[B,d] = spdiags(A):从带状稀疏矩阵A中提取全部的非零对角线元素赋值给矩阵B及其这些非零对角线的位置向量d。<br>2）：A = spdiags(B,d,m,n):产生带状矩阵的稀疏存储矩阵A，其中m，n为原带状稀疏矩阵的行数与列数，矩阵B的第i列即为原带状矩阵的第i条非零对角线，向量d为原带状稀疏矩阵所有非零对角线的位置。</p>
<p>单位矩阵的稀疏存储：<br>    speye(m,n)返回一个m x n的稀疏存储单位矩阵。</p>
<p>——————————-2021-7-13—第二章结束，三章加油ヾ(◍°∇°◍)ﾉﾞ————————</p>
<p>有点简单🍳，哈哈</p>
<p>rem(x,y):求x/y的余数</p>
<p>顺序存储结构：<br>    程序：程序是用某种计算机能够理解并且能够执行的语言来描述的解决问题的方法和步骤。<br>    程度设计的基本步骤：分析问题，确定求解问题的数学模型或者方法–&gt;设计算法，并画出流程图–&gt;选择编程工具，根据算法编写程序–&gt;调试程序，分析程序的输出结果。</p>
<p>程序的三种基本结构：顺序结构，选择结构，循环结构；</p>
<p>脚本文件和函数文件：<br>    脚本文件是可以在命令行窗口直接执行的文件，也叫命令文件。<br>    函数文件是定义一个函数，不能直接执行，必须先调用它。</p>
<p>文件的创建：<br>    <img src="https://img-blog.csdnimg.cn/20200226095729894.png" alt="在这里插入图片描述"></p>
<p>顺序结构：<br>    <img src="https://img-blog.csdnimg.cn/20200226100056429.png" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20200226100556715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>数据的输入：<br>A = input(‘请输入变量A的值：’);<br>数据的输出：<br>disp(输出项);（disp不会显示变量的名字和空格，输出格式更紧凑）</p>
<p>程序的暂停：pause(延迟秒数)，如果是强行终止程序的运行，可以只用Ctrl+C命令。</p>
<p>输入原始数据–&gt;对原始数据进行处理–&gt;输出处理结果</p>
<p>if语句实现选择结构：<br>    选择结构：<br>    <img src="https://img-blog.csdnimg.cn/20200226101516330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>if语句：<br>    <img src="https://img-blog.csdnimg.cn/2020022610162038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20200226102049629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20200226102518527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>MATLAB绘图：<br>    hold on 和hold off（默认）<br>    是相对使用的前者的意思是，你在当前图的轴（坐标系）中画了一幅图，再画另一幅图时，原来的图还在，与新图共存，都看得到<br>    后者表达的是，你在当前图的轴（坐标系）中画了一幅图，此时，状态是hold off,则再画另一幅图时，原来的图就看不到了，在轴上绘制的是新图，原图被替换了</p>
<p>linspace(x,y,z):生成一个数列，x开头，y结束，z为步长（间隔）<br>二维曲线：<br>    plot函数：plot(x,y)其中，x，y分别用来存储x坐标和y坐标。</p>
<p>函数文件的定义和调用：</p>
<p>函数文件基本结构：<br>    <img src="https://img-blog.csdnimg.cn/20200226162544633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    tip：当函数名与函数文件名不同的时候，MATLAB将忽略函数名，调用时使用函数文件名。</p>
<p>函数调用：<br>    <img src="https://img-blog.csdnimg.cn/20200226162645415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>匿名函数：<br>    匿名函数不用函数文件定义，直接在程序脚本中创建。<br>    <img src="https://img-blog.csdnimg.cn/2020022616305056.png" alt="在这里插入图片描述"><br>    🌰：<br>        <img src="https://img-blog.csdnimg.cn/20200226170501499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>Java基础复习</title>
    <url>/2021/05/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="path："><a href="#path：" class="headerlink" title="path："></a>path：</h1><p>主要为了检索文件方便，如果要执行某个文件，不用到文件所在目录去找，操作系统会在path路径下找。<br>Classpath：类路径，java运行查找类文件的路径</p>
<h1 id="public-class-和class："><a href="#public-class-和class：" class="headerlink" title="public class 和class："></a>public class 和class：</h1><p>​    public class声明类，文件名和类名必须一致，class声明类，文件名任意，但生成的class文件名称和类名一样，不和原文件名一致。</p>
<a id="more"></a>

<h1 id="类的命名："><a href="#类的命名：" class="headerlink" title="类的命名："></a>类的命名：</h1><p>首字母大写，单词之间首字母大写</p>
<h1 id="标识符和标识符命名："><a href="#标识符和标识符命名：" class="headerlink" title="标识符和标识符命名："></a>标识符和标识符命名：</h1><p>​    必须由数字，字母，下划线，和美元符号构成，不能以数字开头，区分大小写，最好见名知意，只用驼峰形式，第一个单词首字母为小写，其他单词首字母为大写，例如：fatherMather()</p>
<h1 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h1><p>​    全部都是小写。</p>
<h1 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h1><p>基本数据类型：</p>
<p>​    数值类型：<br>​            整数：byte，short，int，long<br>​            浮点：float，double<br>​    字符类型；char<br>​    布尔类型：boolean<br>引用数据类型： 数组,类,接口</p>
<!--more-->
<h1 id="字符编码："><a href="#字符编码：" class="headerlink" title="字符编码："></a>字符编码：</h1><p>ASCII：采用一个字节编码，主要针对英文编码<br>ISO-8859-1：(latin-1) ISO制定，主要为西欧语言编码，兼容ASCII<br>GBK/GB2312/GB18030：主要是汉字编码<br>unicode：统一全世界所有文字编码，有几种实现：UTF-8，TUF-16，UTF-32<br>java中的char使用的是utf-16编码，所以一个char类型变量可以存放一个汉字</p>
<h1 id="java整数常量表示方法："><a href="#java整数常量表示方法：" class="headerlink" title="java整数常量表示方法："></a>java整数常量表示方法：</h1><p>默认整数型为int，long类型后最好加上大写的L，小写容易混淆<br>十进制：默认是十进制<br>八进制：以0开头，如013<br>十六进制：以0x开头，如0x23</p>
<h1 id="java浮点类型："><a href="#java浮点类型：" class="headerlink" title="java浮点类型："></a>java浮点类型：</h1><p>默认是double<br>double为8个字节，float为4个字节<br>double向float转换会出现精度丢失<br>声明float，数值后必须加上f，如:float f = 10.5f；</p>
<h1 id="基本类型转换："><a href="#基本类型转换：" class="headerlink" title="基本类型转换："></a>基本类型转换：</h1><p>boolean特殊，不能转换为其他类型<br>默认转换：<br>    byte–&gt;short(char)–&gt;int–&gt;long–&gt;float–&gt;double<br>    byte,short,char之间不会相互转换，首先先转换为int<br>强制转换：<br>    容量大类型转换为容量小类型<br>    只要不超过范围，可以直接将整数值赋值给byte，short，char</p>
<h1 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h1><p>短路与和逻辑与：<br>    短路与：从第一个判断数推断结果，只要第一个是false，不计算第二个操作数<br>    逻辑与：两个操作数都计算<br>短路或和逻辑或：<br>    短路或：从第一个操作数推断结果，只要是true，不计算第二个操作数<br>    逻辑或：两个操作数都计算<br>条件运算符：<br>    op1？op2：op3<br>    如果操作数op1为true，则输出op2，否则输出op3</p>
<h1 id="switch语句："><a href="#switch语句：" class="headerlink" title="switch语句："></a>switch语句：</h1><p>switch(表达式){<br>         case 值1: 语句 break;<br>         case 值2: 语句 break;<br>         default 语句<br>}<br>     表达式中的值只能是：char，byte，short，int 类型，boolean ，long，float，double都是非法的<br>break语句可以省略，但会出现switch穿透<br>default 语句也可以省略，一般不建议省略</p>
<h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><p>​    方法的修饰符有：public，protected，private，abstract，static，final，synchronized<br>​    方法名：符合合法的标识符（驼峰式）</p>
<h2 id="方法重载：（多态的一种）"><a href="#方法重载：（多态的一种）" class="headerlink" title="方法重载：（多态的一种）"></a>方法重载：（多态的一种）</h2><p>​    重载条件：<br>​        方法名相同<br>​        方法的参数类型，个数，顺序至少有一个不同<br>​        方法的返回值可以不同也可以相同，（不依靠返回值类型区分重载）<br>​        方法的修饰符可以不同，方法重载和修饰符没有关系<br>​        方法重载只出现在一个类中</p>
<h1 id="面向过程和面向对象："><a href="#面向过程和面向对象：" class="headerlink" title="面向过程和面向对象："></a>面向过程和面向对象：</h1><p>​    面向过程：必须了解整个过程，每个步骤的因果关系，每个步骤很难分离<br>​    面向对象：将现实世界分割成不同单元(对象),实现每个对象，如果完成某个功能，只需要将每个对象协作起来就可以了</p>
<h2 id="面向对象的三大特性："><a href="#面向对象的三大特性：" class="headerlink" title="面向对象的三大特性："></a>面向对象的三大特性：</h2><p>​    封装<br>​    继承<br>​    多态</p>
<h1 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a>类和对象：</h1><p>对象也叫实例，类的具体化就是对象或实例<br>好处：更符合人的思维模式，更容易分析<br>面向对象开发的三个阶段：<br>    OOA：面向对象的分析<br>    OOD：面向对象的设计<br>    OOP：面向对象的编程 —–Java是纯面向对象的语言<br>类 = 属性 ＋ 方法<br>    属性来源于类的状态，方法来自于动作<br>    类中的成员变量和局部变量，成员变量会默认初始化，默认初始化为该变量的默认值，局部变量必须在使用前初始化，</p>
<p>对象的创建和使用：<br>    必须是new出来，才能用<br>    一个类可以创建N个对象，成员变量只属于当前的对象（只属于对象，不属于类），只能通过对象才能访问成员变量，通过类不能直接访问成员变量</p>
<p>面向对象封装：<br>    使用private声明成员变量，成员变量只属于对象，属性只能通过方法访问<br>    封装属性，暴露方法</p>
<p>构造方法：<br>    声明格式：构造方法修饰词 类名 (参数列表)<br>    构造方法修饰词：public，protected，private<br>    构造方法可重载<br>    特点：<br>        方法名必须和类名一致<br>        构造方法不具有返回值，也没有void，否则就成为了普通的方法<br>        每个类都有构造方法，没有明显显示，系统会默认的定义一个不含任何参数的构造方法</p>
<p>this关键字：<br>    this指的是当前调用的对象，有100个对象就有100个this<br>    this的使用：<br>        局部变量和成员变量重名的时候，this指定调用成员变量<br>        通过this调用另一个构造方法<br>        在构造方法中，如果使用this调用构造方法，this语句必须放在第一行，否则会报错<br>        this只能用在构造方法和成员方法内部(声明变量也可以用)，static标识的方法里不能使用this</p>
<p>static关键字：<br>    静态的意思，可以修饰成员方法，成员变量<br>    特点：被类的所有对象共享，这也是我们判断是否使用静态关键字的条件，可以通过类名调用，当然也可以通过对象名调用（推荐使用类名）<br>    访问特点：<br>        非静态的成员方法：<br>            能访问静态的成员变量，能访问非静态的成员变量，能访问静态的成员方法，能访问非静态的成员方法<br>        静态的成员方法：能访问静态的成员变量，能访问静态的成员方法<br>    可修饰：变量，方法，代码块<br>    用static修饰的变量和方法，可以采用类名访问<br>    用static声明的代码块为静态代码块，jvm加载类的时候，会执行静态代码块的内容<br>    static声明的变量，所有的通过该类new出来的对象，都可以访问该变量，类也可以访问，所以叫类变量。<br>    总结：静态的只能调用静态的</p>
<p>静态方法：<br>    静态方法不能直接调用实例变量，实例方法和this，和实例相关的，都不能直接调用。</p>
<p>静态变量<br>    在类加载的时候就会初始化，就是将类的字节码读取到方法区就初始化了</p>
<p>main方法：<br>    public：表示全局所有，就是封装性<br>    static：静态的，也就是说它描述的方法只能通过类调用<br>    main：系统规定<br>    String[]args：参数类型也是系统规定的<br>    静态方法，java虚拟机调用方便，直接拿到类就能调用main方法，静态的东西都在方法区，静态方法调用成员属性，在方法区无法找到，就算在堆区找到，对象也没有创建，所以，静态方法不能直接访问成员属性和成员方法。</p>
<h2 id="类的继承："><a href="#类的继承：" class="headerlink" title="类的继承："></a>类的继承：</h2><pre><code>继承的注意事项：只支持单继承，不支持多继承，但支持多层继承

继承的好处和弊端：提高代码的复用率（多个类相同的成员可以放在同一个类中）
提高代码的维护性
继承让类与类之间产生关系，类的耦合性增强，当父类发生变化时子类实现也不得不跟着变化，削弱子类的独立性。

继承的应用场景：
    使用继承，需要考虑类与类之间是否考虑is，a的关系，不能盲目使用继承</code></pre><p>​    关键字：extends<br>​    继承是面向对象的重要概念<br>​    继承提高软件可重用性<br>​    java只支持类的单继承<br>​    软件设计原则：重复代码最好不要重复两次或多次</p>
<pre><code>​    



方法的覆盖/重写（Override）：</code></pre><p>​    方法覆盖的条件：<br>​        必须有继承关系<br>​        覆盖只能出现在子类中，没有继承关系，不存在覆盖，只存在重载<br>​        在子类中被覆盖的方法，必须和父类的方法完全一致，方法名，返回类型，参数列表，完全一样<br>​        <strong>子类方法的访问权限不能小于父类方法的访问权限</strong><br>    方法重写的应用场景：<br>        当子类需要父类的功能，而功能主体子类有自己独特内容，可以重写父类方法中的方法，沿袭父类的功能，又定义子类特有的内容<br>    Override注解：监测当前方法，是否是重写的方法，起到检验的作用</p>
<pre><code>方法重写的注意事项：
    私有方法不能被重写，子类方法访问权限不能更低；

继承中变量的访问：就近原则，子类没有找到变量，在父类找，不考虑父类的父类。</code></pre><h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h2><p>重载式多态：<br>    也叫编译时多态，这种多态在编译时就确定好了，在调用这种重载式方法的时候，传入不同的参数，最后得到不同的结果，就是一种多态。<br>重写式多态：<br>        也叫运行时多态，多态通过动态绑定来实现，在执行期间判断引用对象的实际类型，根据实际类型调用相应方法</p>
<p>多态中的成员访问特点：<br>    成员的访问特点：成员变量—-&gt;编译看父类，运行看父类;成员方法—-&gt;编译看父类，运行看子类;</p>
<p>多态的好处和弊端：<br>    好处：提高程序的扩展性，定义方法的时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作<br>    弊端：不能使用子类的特有成员</p>
<p>多态的转型：<br>    向上转型：父类引用指向子类对象就是向上转型<br>    向上转型：子类型 对象名 = （子对象）父类引用;</p>
<p>对静态方法的覆盖：<br>    静态方法不存在多态的概念，多态和成员方法相关，静态方法值属于某一个类，声明的是哪一个类，就调用的是哪一个类的静态方法，和子类没有关系。new谁调谁。<br>    为什么覆盖成员方法可以构成多态，主要是运行期间的动态绑定，静态绑定的含义是在编译成class文件的时候已经确定好调用哪个方法。</p>
<p>super关键字：<br>    调用父类的构造方法和成员方法<br>    super只能应用在成员方法和构造方法中，不能应用在静态方法中，和this一样，如果在构造方法中使用，必须放在第一行。<br>    子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父也就没有子<br>    有时需要在子类中显示的调用父类的成员方法</p>
<p>final关键字：<br>     final的应用：final的意思是最终的意思 可以修饰成员变量，方法，类</p>
<pre><code>采用final修饰的类不能被继承
采用final修饰的方法不能被覆盖
采用final修饰的变量不能被修改
final修饰的变量必须显示初始化
如果修饰的是引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象可以修改。
构造方法不能被final修饰
final定义的静态变量，调用时不会执行java的类初始化方法，也就是说不会执行static代码块等相关语句。
final修饰引用数据类型变量：final修饰的引用类型的地址值不能发生变化，但地址里面的内容是可以变化的</code></pre><p>抽象类：<br>    采用sbstract关键字定义的类就是抽象类，采用abstract关键字定义的方法就是抽象方法<br>    抽象的方法只需要在抽象类中，提供声明，不需要实现<br>    如果一个类包含抽象方法，那么这个类必须是抽象类<br>    一个类是抽象的，那么这个类被子类继承，抽象方法必须复写，如果在子类中不复写抽象方法，那么必须将此方法声明为抽象方法。<br>    抽象的类是不能被实例化的<br>    抽象类不能被final修饰，因为抽象方法就是被子类实现的，而且final修饰的类不能被继承。<br>    抽象的方法只需在抽象类中，提供声明，不需要实现，起到一个强制的约束作用，要求子类必须实现。<br>    如果一个类是抽象的，那么这个类被子类继承，抽象方法必须被覆盖。如果子类不覆盖该抽象方法，那么必须将方法再次声明为抽象方法，继承的子类也成为了抽象子类。<br>    抽象类不能被final修饰<br>    抽象类特点：<br>        抽象类和成员方法必须用abstract关键字修饰;<br>        抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类;<br>        抽象类不能被实例化<br>        抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类</p>
<pre><code>抽象类的成员特点：
    成员变量：既可以是变量，也可以是常量
    构造方法：空参构造，有参构造
    成员方法：抽象方法，普通方法</code></pre><p>接口：<br>    接口可以看做是抽象类的一种特殊情况，在接口中只能定义抽象的方法和变量。<br>    java接口要用interface声明<br>    接口的方法默认就是public abstract的，不能修改<br>    接口的变量时public static final类型的，不能改变，所以必须显示的初始化。<br>    接口不能被实例化，接口没有函数的概念。<br>    接口之间可以继承，接口之间不能实现。<br>    接口的方法只能通过类来实现，通过implements关键字<br>    如果一个类实现了接口，接口里的方法必须全部实现<br>    一个类可以实现多个接口<br>    接口中的方法默认是public abstract的，不能更改<br>    接口中的变量是public static final类型的，不能更改，所以必须显示的初始化。就算是没有关键词final修饰，例如 String y=”yes”; y也是默认加上public static final的<br>    接口不能被实例化，接口没有构造函数的概念</p>
<p>接口的进一步应用：<br>    在java中接口其实描述了类需要做的事情，类要遵循接口的定义来做事。<br>    使用接口的好处：<br>        采用接口明确的声明了他所能提供的服务<br>        解决了java单继承的问题<br>        实现了可接插性（重要）</p>
<p>类和接口的关系：<br>    类与类的关系：继承关系，只能单继承，但是可以多层继承<br>    类和接口的关系：实现关系，可以单实现，也可以多实现，还可以继承一个类同时实现多个接口。<br>    接口与接口的关系：继承关系，可以单继承，也可以多继承！！！。</p>
<p>多态：<br>    多种状态的含义。<br>    如方法重载，相同的方法名称考可以完成不同的功能，这就是多态的一种表现，此时成为静态多态。<br>    如将学生数据保存的示例，当调用接口的方法，java就自动调用实现类的方法，如果Oracle实现级调用Oracle的方法，如果是MySql实现的就调用MySql中的方法，这是在运行时决定的，叫做运行时多态。<br>    多态的条件：<br>        有继承或实现，有方法覆盖或实现，父类对象（接口）指向子类对象<br>    接口和抽象类的区别：<br>        接口描述方法的特征，不给出实现，一方面解决了java的单继承问题，实现了可接插性。<br>        抽象类提供了部分实现，抽象类是不能实例化的，抽象类的存在主要是把公共的代码移植到抽象类中。<br>        面向接口编程，不要面向具体编程（面向抽象编程，不面向具体编程）<br>        优先选择接口（因为继承抽象类后，此类将无法再继承，所以丧失了类的灵活性）</p>
<p>类之间的关系：<br>    泛化关系：类和类之间的继承关系及接口之间的继承关系<br>    实现关系：类对接口的实现<br>    并联关系：类和类之间的连接，一个类可以知道另一个类的属性和方法，在java语言中使用实例变量体现<br>    聚合关系：是关联关系的一种，是较强的关联关系，是整体和部分的关系，如汽车和轮胎，聚合关系的类处在不平等的层次上，一个代表整体，一个代表部分<br>    合成关系：是关系的一种，比聚合关系强的关联关系，如：人和四肢，整体对象决定部分对象的生命周期，部分对象每一时刻只与一个对象发生合成关系<br>    依赖关系：比关联关系弱，在java语言中体现在返回值，参数，局部变量和静态方法调用</p>
<p>Object类：<br>    Object类是所有Java类的基类<br>    如果在类的声明中未使用extends关键字指明基类，则默认基类为Object类</p>
<p>toString():<br>    返回该对象的字符串表示，通常toString方法会返回一个”以文本方式表示”此对象的字符串，Object类的toString方法返回一个字符串，该字符串由类名加标记@和此对象的哈希码的无符号十六进制表示组成，</p>
<p>finalize：<br>    垃圾回收器（Garbage Collection），也叫GC，垃圾回收器的主要特点：<br>        当对象不再被程序使用时，垃圾回收器将其回收<br>        垃圾回收是在后台运行的，无法命令垃圾回收器马上回收资源但是可以告诉它，尽快回收资源（System.gc和Runtime.getRuntime().gc()）<br>        垃圾回收器在回收某个对象的时候，首先会调用该对象的finalize方法<br>        GC主要针对堆内存</p>
<p>==和equals方法：<br>    等号可以比较基本类型和引用类型，等号比较的是值，特别是比较引用类型，比较的是引用的内存地址<br>    equals方法比较对象的地址，字符串的equals方法是比较的内容</p>
<p>包和import：<br>    包：其实就是目录，特别是项目比较大的时候，java文件特别多的时候，应该分目录管理，在java中称为分包管理，包的名称通常采用小写<br>        包最好采用小写字母<br>        包的命名要有规则，不能重复，一般采用公司网站的逆序<br>        package必须放在所有语句的第一行，注释除外<br>    import:<br>        采用import引入需要使用的类<br>        可以采用*通配符，引入包下的所有类（方式不明确，效率较低，但简单）<br>        如果都在同一个包下，就不需要import引入了</p>
<p>JDK常用开发包：<br>    java.lang:语言标准包，使用此包中的内容无需import引入<br>    java.sql:提供JDBC接口类<br>    java.util：提供常用工具类<br>    java.io:提供各种输入输出流</p>
<p>修饰符：<br>    package：<br>        包是文件夹，用来管理文件；<br>        包的定义格式：<br>            package 包名；（多级包，分开）<br>            例如：package com.edu.demo<br>        带包编译&amp;带包运行<br>            带包编译：javac -d.类名.java<br>            带包运行：java 包名+类名<br>    import:<br>        导包的意义：使用不同包下的类时，使用的时候要写类的路径，写起来很麻烦为了简化导包的操作，java就提供导包的功能<br>        导包的格式：import 包名</p>
<p>访问权限控制符：<br>    java访问修饰符主要包括：private，protected，public，可以限定其他类对该类，属性和方法的使用权限。</p>
<pre><code>修饰符      类的内部        同一个包里      子类（不同包中）        任何地方
private     Y               N               N                       N
protected   Y               Y               Y                       N
public      Y               Y               Y                       Y
default     Y               Y               N                       N
对类的修饰只有public和default，内部类除外





private:private声明的变量或方法，只能在同一个类中使用
protected：采用protected声明的变量或方法只能子类或者同一个包下的类可以调用。
default：如果class不采用public修饰的话，此时的class只能被该包下的类访问，其他包无法访问</code></pre><p>内部类：<br>    在一个类的内部定义的类，叫做内部类<br>    内部类的分类：<br>        实例内部类<br>            创建实例内部类，外部类的实例必须已经创建<br>            实例内部类会持有外部类的引用<br>            实例内部不能定义static成员，只能定义实例成员<br>        局部内部类<br>            局部内部类是在方法中定义的，只能在当前方法中使用，和局部变量的作用一样，局部内部类和实例内部类一致，不能包含静态成员。局部变量在内部类中使用必须采用final修饰<br>        静态内部类<br>            静态内部类不会持有外部的类的引用，创建时可以不用创建外部类<br>            静态内部类可以访问外部的成员变量，如果访问外部类的成员变量，必须通过外部类的实例访问<br>        匿名内部类<br>            特殊内部类，没有名字。</p>
<p>JVM的内存结构中三块比较重要的内存空间。<br>    方法区：<br>        存储代码片段，存储xxx.class字节码文件，这个空间是最先有数据的，<br>        类加载器首先将代码加载到这里。<br>    堆内存：<br>        用来存放各种类的实例对象<br>    栈内存：<br>        stack栈当中存储什么？<br>            每个方法执行时所需要的内存空间（局部变量）。</p>
<p>System.out.println(“Hello World!”)：<br>        System.out 中，out后面没有小括号，说明out是变量名。<br>        另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。<br>        System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。</p>
<p>java和c++的区别：</p>
<p>都是面向对象的语言</p>
<p>java不提供指针直接访问内存，程序内存更安全</p>
<p>java的类是单继承，c++支持多继承，虽然java的类不可以多继承，但是接口可以多继承</p>
<p>java有自动内存管理机制，不需要人手动释放无用内存。</p>
<p>c语言中，字符串或字符数组最后都会有额外的字符‘\0’来表示结束，java里没有结束符的概念。</p>
<p>import java和javax：</p>
<p>javax之前是Java的拓展包，后来成为java的标准API的一部分，没啥区别了。</p>
<p>编译和解释型语言：</p>
<p>编译型语言：编译器针对指定的操作系统将源代码一次性翻译成可被平台执行的机器码</p>
<p>解释型语言：解释器对源程序逐行解释成特定平台的机器码并立即执行。</p>
<p>java程序是要先编译后解释，经过两个步骤。所以java是编译和解释并存。</p>
<p>字符常量和字符串常量区别：<br>形式上：字符常量使用单引号，字符串常量使用双引号</p>
<p>含义上：字符常量相当于一个整数值（ASCII），可参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放的位置）</p>
<p>内存大小：字符常量只占2个字节，字符串常量占若干个字节。</p>
<p>泛型：</p>
<p>==和equals的区别：</p>
<p>==：判断两个对象的地址是否相等，即判断两个对象是不是一个对象。</p>
<p>（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）</p>
<p>因为java只有值传递，所以==，不管是比较基本数据类型，还是引用数据类型的变量，本质都是比较值，只是引用类型变量的值是对象的地址。</p>
<p>equals()：判断两个对象是否相等，不能用于比较基本数据类型的变量。</p>
<p>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>诸如String，Date等类对equals方法进行重写的话，比较所指对象的内容。</p>
<p>为什么重写equals方法必须重写hsahCode方法？（待整理）</p>
<pre><code>hashCode()：获取哈希值，也称散列码，实际返回的是int整数。哈希码的作用是确定该对象在哈希表的索引位置。hashCode()定义在JDK的Object类中，意味着java中的任何类都包含hashCode()函数。注意：Object的hashCode方法是本地方法，也就是c语言或者c++实现的，该方法会用来将对象的内存地址转换为整数返回。

强调：向HsahSet或者HashMap中加入数据时，必须同时覆盖equals和hashCode方法
    两个对象的equals相等，那么他们的hashCode相等，两个对象的equals不相等，hashCode不要求相等。</code></pre><p>Java中的几种基本类型和对应的包装类：（待整理）<br>    基本类型:<br>        6种数字类型：byte，short，int，long，float，double<br>        1种字符类型：char<br>        1种布尔类型：boolean (默认false)<br>        Java里使用long类型的时候，要在数值后面加上L<br>        char类型用单引号，String用双引号。<br>    自动拆箱和装箱：<br>        装箱：将基本类型用他们对应的引用类型包装起来；<br>        拆箱：将包装类型转换为基本类型；</p>
<p>String的两种创建方式：<br>    1：双引号的方式，是在编译生成class文件的时候，字符串就存放在常量池里的，定义一个新的字符串的时候，先从常量池里找有没有这个字符串，有的话直接拿来用，没有的话，放进去后，再用。<br>    2：new关键字创建，创建一个字符串对象，对象放在堆区内存中，每次创建一个字符串的时候，创建一个新的字符串对象，字符串内容一样，字符串的引用不一样，可以用==来判断一下，不能用equals方法来判断，因为String类重写了toString方法。</p>
<pre><code>因为String是不可变对象，多个字符串拼接的话，会形成多个对象，可能会造成内存溢出，拼接的时候可以使用StringBuffer和Builder</code></pre><p>枚举：<br>        采用枚举能够限定取值的范围，在程序编译的时候，及早返回错误，使程序更加健壮</p>
<p>Treeset：<br>    可以放入不重复的数据，而且会进行排序，但必须实现Comparable接口，基本类型的包装类和String已经实现了该接口</p>
<p>Comparable和 Comparator区别：<br>    一个类实现Comparable接口表明这个类的对象之间可以相互比较，对象组成的集合可以直接使用sort方法排序。<br>    Comparator可以看做一种算法的实现，将算法和数据分离，Comparator也可以在两种情况下使用：<br>        1：类本身没有考虑到比较问题而没有实现Comparable,可以通过Comparator来实现排序，不必改变对象本身<br>        2：可以使用多种排序标准，降序，升序。<br>    对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</p>
<pre><code>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</code></pre><p>HashMap：<br>    HashMap底层实现是hash表，所以Map的Key，必须重写hashCode和equals方法。</p>
<p>TreeMap：<br>    TreeMap可以对Map中的Key进行排序，如果map中的key采用的是自定义类，那么需要实现Comparable或者Comparator接口完成排序</p>
]]></content>
  </entry>
  <entry>
    <title>Java代码练习</title>
    <url>/2021/06/12/Java%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>2021-6-12<br>冒泡排序：<br>import java.util.Scanner;<br>public class bubbleSortTest {<br>    public static void main(String[] args) {<br>        Scanner input = new Scanner(System.in);<br>        int a[] = new int[10];<br>        for(int i = 0;i&lt;a.length;i++){<br>            a[i] = input.nextInt();<br>        }<br>        System.out.println(“冒泡排序未排序前数组：”);<br>        //for each 循环<br>        for (int i:a) {<br>            System.out.print(i+”  “);<br>        }<br>        //冒泡排序：<br>        int d=0;<br>        for (int i=0; i&lt;a.length-1;i++){<br>            for (int j=0;j&lt;a.length-i-1;j++) {<br>                if (a[j] &lt; a[j + 1]) {<br>                    d = a[j];<br>                    a[j] = a[j + 1];<br>                    a[j + 1] = d;<br>                }<br>            }<br>    }<br>        //冒泡排序后的结果<br>        System.out.println(“冒泡排序后”);<br>        for (int i=0;i&lt;a.length;i++){<br>            System.out.print(a[i]+”   “);<br>        }<br>}}</p>
<p>选择排序：<br>public class selectionSortTest {<br>    public static void main(String[] args) {<br>        int []arr = new int[]{1,2,3,9,8,7,6,5,4,10};<br>        selectSort(arr);<br>        for (int i=0;i&lt;arr.length;i++){<br>            System.out.println(arr[i]+”   “);<br>        }<br>    }<br>    public  static void selectSort(int[] a){<br>        //实现冒泡排序,从小到大排列<br>        //数组要遍历a.length遍<br>        int minIndex=0;<br>        for (int i=0;i&lt;a.length;i++){<br>            minIndex = i;//记录一下最小值的索引<br>            for (int j=i+1;j&lt;a.length;j++){<br>                if (a[minIndex]&gt;a[j]){<br>                    minIndex=j;<br>                }<br>            }<br>            //将最小值和起始值进行交换<br>            int d=a[i];<br>            a[i]=a[minIndex];<br>            a[minIndex]=d;<br>        }</p>
<pre><code>}
}</code></pre><a id="more"></a>
<p>二分查找：<br>import java.util.Scanner;<br>import java.math.*;<br>public class binarySearch {<br>    public static void main(String[] args) {<br>        Scanner input =new Scanner(System.in);<br>        int[] a = new int[]{1,2,3,4,5,6,7,8,9,10};<br>        System.out.println(“数组：”);<br>        for (int i=0;i&lt;a.length;i++){<br>            System.out.print(a[i]+” “);<br>        }<br>        System.out.println(“输入你想查找的数：”);<br>        int b = input.nextInt();<br>        //递归实现：<br>//        System.out.println(“—————–递归实现———————-“);<br>//        int findnumIndex =find(b,a,0,a.length-1);<br>//        System.out.println(“findnumIndex:”+findnumIndex);<br>        System.out.println(“——————-while实现———————–”);<br>        //循环实现<br>        int first=0;<br>        int last = a.length-1;<br>        int mid = (first+last)/2;<br>        if (b==mid){<br>            System.out.println(“findnumIndex:”+mid);<br>        }<br>        while (b!=a[mid]){<br>           if (b&lt;a[mid]){<br>               last = mid;<br>               mid = (first+last) /2;<br>           }else if(b&gt;a[mid]){<br>                first = mid;<br>                mid = (first+last)/2;<br>           }else if (b==a[mid]){<br>               System.out.println(“findnumIndex:”+mid);<br>           }<br>        }<br>        System.out.println(“findnumIndex:”+mid);<br>    }</p>
<pre><code>//findNum  想查找的目标数字，a：查找的数组     start:查找数组起始位置    fin:查找的数组的末尾位置
//返回目标数字所在的索引
public static int find(int findNum ,int[] a,int start,int fin){

    int mid = a[start]+a[fin];
    mid = mid/2;
    if (findNum&lt;a[start] || findNum&gt;a[fin]){
        System.out.println(&quot;该数不在此数组内&quot;);
        return -1;
    }else if (findNum&lt;mid) {
        fin=mid;
        return find(findNum,a,start,fin);
    }
    else if (findNum&gt;mid){
        start = mid;
        return find(findNum,a,start,fin);
    }else if(findNum==mid) {
        return mid;
    }
        return -1;

}</code></pre><p>}</p>
<p>2021-6-13<br>比较字符串地址值<br>public class stringPoolTest {<br>    public static void main(String[] args) {<br>        String s1 = “abc”;<br>        String s2 = “abc”;<br>        String s3  = new String(“abc”);<br>        System.out.println(s1==s2);//s1,s2都是来源于一个字符串常量池的停用<br>        System.out.println(s1==s3);//一个是字符串常量池的地址值，一个是字符串对象的地址。<br>        System.out.println(s1.equals(s3));//String重写了toString方法，比较的是内容，所以为true<br>    }<br>}</p>
<p>2021-6-15</p>
<p>泛型自动类型推断<br>import java.util.ArrayList;</p>
<p>public class genericsTest {<br>    public static void main(String[] args) {<br>        //jdk7新特性，后面的尖括号不用填写东西<br>        ArrayList<animal> arrayList = new ArrayList&lt;&gt;();<br>        //普通写法<br>        ArrayList<animal> arrayList1 = new ArrayList<animal>();<br>    }<br>}<br>class animal{</animal></animal></animal></p>
<p>}</p>
<p>switch支持String：</p>
<p>public class switchTest {<br>    public static void main(String[] args) {<br>        //Switch支持String<br>        String name = “cui”;<br>        switch(name){<br>            case “jin”: System.out.println(“jin”);break;<br>            case “cui”: System.out.println(“cui”);break;<br>            case “hao”: System.out.println(“hao”);break;<br>            default:<br>                System.out.println(“没有cui”);break;<br>        }<br>    }<br>}</p>
<p>Integer的常量池：<br>public class intergerPoolTest {<br>    public static void main(String[] args) {<br>        int a1= 100;<br>        int a2 = 100;<br>        System.out.println(“a1== a2”+(a1== a2));//true<br>        int e1= 100000;<br>        int e2 = 100000;<br>        System.out.println(“e1== e2”+(e1== e2));//true</p>
<pre><code>    Integer b1 = 100;
    Integer b2 = 100;
    System.out.println(&quot;b1==b2:&quot;+(b1==b2));//true
    Integer c1 = 1000;
    Integer c2 = 1000;
    System.out.println(&quot;c1==c2:&quot;+(c1==c2));//false
}</code></pre><p>}</p>
<p>2021-6-17<br>Collection练习：</p>
<p>import java.util.*;</p>
<p>public class collectionTest {<br>    public static void main(String[] args) {<br>        //创建Collection集合的对象<br>        Collection<String> c = new ArrayList<String>();<br>        //添加元素：bollean add(E e)<br>        c.add(“hello”);<br>        c.add(“World”);<br>        c.add(“demo”);<br>        System.out.println(c);<br>        System.out.println(“===========================”);<br>        List arr1 = new ArrayList&lt;&gt;();<br>        arr1.add(1);<br>        arr1.add(2);<br>        arr1.add(2);<br>        arr1.add(2);<br>        arr1.add(2);<br>        Iterator iterator = arr1.iterator();<br>        while (iterator.hasNext()){<br>            Integer a = (Integer) iterator.next();<br>            System.out.println(a);<br>        }</String></String></p>
<pre><code>}</code></pre><p>}</p>
<p>枚举练习：</p>
<p>public class enumTest {<br>    public static void main(String[] args) {<br>        Color color = Color.green;<br>        switch (color){<br>            case red:<br>                System.out.println(“红色”);<br>                break;<br>            case blank:<br>                System.out.println(“灰色”);<br>                break;<br>                case yellow:<br>                System.out.println(“黄色”);<br>                break;<br>            default:<br>                System.out.println(“没有yanse”);</p>
<pre><code>    }
    int value1 = 3;
    int value2 = 4;
    Result result = method1(value1,value2);
    System.out.println(result);//FAILURE
    //result的变量类型：
    System.out.println(result.getClass().getName());//enumTest$Result
}
private static Result method1(int value1,int value2){
    if(value1&gt;value2)return Result.SUCCESS;
    if(value1&lt;=value2)return Result.FAILURE;
    else return Result.FAILURE;
}
public  enum  Color{
    red,green,blank,yellow
}
enum Result{
    SUCCESS,FAILURE
}</code></pre><p>}</p>
<p>2021-6-21<br>集合类练习：<br>import java.lang.reflect.Array;<br>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;</p>
<p>public class genericsTest01 {<br>    public static void main(String[] args) {<br>        List list =new ArrayList();<br>        list.add(1);<br>        list.add(2);<br>        list.add(4);<br>        list.add(3);<br>        for (Iterator iter = list.iterator(); list.iterator().hasNext();){<br>            System.out.println(iter.next());<br>        }</p>
<pre><code>}</code></pre><p>}</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2021/05/04/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录MySQL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p12345612</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 显示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE test;</span><br><span class="line"></span><br><span class="line">-- 切换数据库</span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line">-- 显示数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 创建数据表</span><br><span class="line">CREATE TABLE pet (</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    owner VARCHAR(20),</span><br><span class="line">    species VARCHAR(20),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birth DATE,</span><br><span class="line">    death DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看数据表结构</span><br><span class="line">-- describe pet;</span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line">-- 查询表</span><br><span class="line">SELECT * from pet;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);</span><br><span class="line"></span><br><span class="line">-- 修改数据</span><br><span class="line">UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除数据</span><br><span class="line">DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE myorder;</span><br></pre></td></tr></table></figure>

<h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 主键约束</span><br><span class="line">-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 联合主键</span><br><span class="line">-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    password VARCHAR(20),</span><br><span class="line">    PRIMARY KEY(id, name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 自增约束</span><br><span class="line">-- 自增约束的主键由系统自动递增分配。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加主键约束</span><br><span class="line">-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD PRIMARY KEY(id);</span><br><span class="line">ALTER TABLE user MODIFY id INT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">-- 删除主键</span><br><span class="line">ALTER TABLE user drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 建表时创建唯一主键</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    UNIQUE(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加唯一主键</span><br><span class="line">-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD UNIQUE(name);</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">-- 删除唯一主键</span><br><span class="line">ALTER TABLE user DROP INDEX name;</span><br></pre></td></tr></table></figure>

<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表时添加非空约束</span><br><span class="line">-- 约束某个字段不能为空</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 建表时添加默认约束</span><br><span class="line">-- 约束某个字段的默认值</span><br><span class="line">CREATE TABLE user2 (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    age INT DEFAULT 10</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY age INT;</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 班级</span><br><span class="line">CREATE TABLE classes (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE students (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    -- 这里的 class_id 要和 classes 中的 id 字段相关联</span><br><span class="line">    class_id INT,</span><br><span class="line">    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值</span><br><span class="line">    FOREIGN KEY(class_id) REFERENCES classes(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；</span><br><span class="line">-- 2. 主表中的记录被副表引用时，主表不可以被删除。</span><br></pre></td></tr></table></figure>

<h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    product_name VARCHAR(20),</span><br><span class="line">    customer_name VARCHAR(20),</span><br><span class="line">    PRIMARY KEY (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE product (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    customer_phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
<h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE select_test;</span><br><span class="line">-- 切换数据库</span><br><span class="line">USE select_test;</span><br><span class="line"></span><br><span class="line">-- 创建学生表</span><br><span class="line">CREATE TABLE student (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE, -- 生日</span><br><span class="line">    class VARCHAR(20) -- 所在班级</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建教师表</span><br><span class="line">CREATE TABLE teacher (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE,</span><br><span class="line">    profession VARCHAR(20) NOT NULL, -- 职称</span><br><span class="line">    department VARCHAR(20) NOT NULL -- 部门</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建课程表</span><br><span class="line">CREATE TABLE course (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    t_no VARCHAR(20) NOT NULL, -- 教师编号</span><br><span class="line">    -- 表示该 tno 来自于 teacher 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(t_no) REFERENCES teacher(no) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 成绩表</span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    s_no VARCHAR(20) NOT NULL, -- 学生编号</span><br><span class="line">    c_no VARCHAR(20) NOT NULL, -- 课程号</span><br><span class="line">    degree DECIMAL,	-- 成绩</span><br><span class="line">    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(s_no) REFERENCES student(no),	</span><br><span class="line">    FOREIGN KEY(c_no) REFERENCES course(no),</span><br><span class="line">    -- 设置 s_no, c_no 为联合主键</span><br><span class="line">    PRIMARY KEY(s_no, c_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 添加学生表数据</span><br><span class="line">INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加教师表数据</span><br><span class="line">INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加课程表数据</span><br><span class="line">INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加添加成绩表数据</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);</span><br><span class="line"></span><br><span class="line">-- 查看表结构</span><br><span class="line">SELECT * FROM course;</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">SELECT * FROM teacher;</span><br></pre></td></tr></table></figure>

<h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询 student 表的所有行</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询 student 表中的 name、sex 和 class 字段的所有行</span><br><span class="line">SELECT name, sex, class FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询 teacher 表中不重复的 department 列</span><br><span class="line">-- department: 去重查询</span><br><span class="line">SELECT DISTINCT department FROM teacher;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）</span><br><span class="line">-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;</span><br><span class="line">SELECT * FROM score WHERE degree BETWEEN 60 AND 80;</span><br><span class="line">SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中成绩为 85, 86 或 88 的行</span><br><span class="line">-- IN: 查询规定中的多个值</span><br><span class="line">SELECT * FROM score WHERE degree IN (85, 86, 88);</span><br><span class="line"></span><br><span class="line">-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行</span><br><span class="line">-- or: 表示或者关系</span><br><span class="line">SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- 以 class 降序的方式查询 student 表的所有行</span><br><span class="line">-- DESC: 降序，从高到低</span><br><span class="line">-- ASC（默认）: 升序，从低到高</span><br><span class="line">SELECT * FROM student ORDER BY class DESC;</span><br><span class="line">SELECT * FROM student ORDER BY class ASC;</span><br><span class="line"></span><br><span class="line">-- 以 c_no 升序、degree 降序查询 score 表的所有行</span><br><span class="line">SELECT * FROM score ORDER BY c_no ASC, degree DESC;</span><br><span class="line"></span><br><span class="line">-- 查询 &quot;95031&quot; 班的学生人数</span><br><span class="line">-- COUNT: 统计</span><br><span class="line">SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。</span><br><span class="line">-- (SELECT MAX(degree) FROM score): 子查询，算出最高分</span><br><span class="line">SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line"></span><br><span class="line">--  排序查询</span><br><span class="line">-- LIMIT r, n: 表示从第r行开始，查询n条数据</span><br><span class="line">SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</span><br></pre></td></tr></table></figure>

<h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- AVG: 平均值</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;</span><br><span class="line"></span><br><span class="line">-- GROUP BY: 分组查询</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br></pre></td></tr></table></figure>

<h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">-- c_no 课程编号</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先把 c_no, AVG(degree) 通过分组查询出来</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     85.3333 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- 再查询出至少有 2 名学生选修的课程</span><br><span class="line">-- HAVING: 表示持有</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2</span><br><span class="line"></span><br><span class="line">-- 并且是以 3 开头的课程</span><br><span class="line">-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。</span><br><span class="line">AND c_no LIKE &#39;3%&#39;;</span><br><span class="line"></span><br><span class="line">-- 把前面的SQL语句拼接起来，</span><br><span class="line">-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。</span><br><span class="line">SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| c_no  | AVG(degree) | COUNT(*) |</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| 3-105 |     85.3333 |        3 |</span><br><span class="line">| 3-245 |     76.3333 |        3 |</span><br><span class="line">+-------+-------------+----------+</span><br></pre></td></tr></table></figure>

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT no, name FROM student;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| no  | name      |</span><br><span class="line">+-----+-----------+</span><br><span class="line">| 101 | 曾华      |</span><br><span class="line">| 102 | 匡明      |</span><br><span class="line">| 103 | 王丽      |</span><br><span class="line">| 104 | 李军      |</span><br><span class="line">| 105 | 王芳      |</span><br><span class="line">| 106 | 陆军      |</span><br><span class="line">| 107 | 王尼玛    |</span><br><span class="line">| 108 | 张全蛋    |</span><br><span class="line">| 109 | 赵铁柱    |</span><br><span class="line">+-----+-----------+</span><br><span class="line"></span><br><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- FROM...: 表示从 student, score 表中查询</span><br><span class="line">-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。</span><br><span class="line">SELECT name, c_no, degree FROM student, score </span><br><span class="line">WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。</span><br><span class="line">-- as 表示取一个该字段的别名。</span><br><span class="line">SELECT s_no, name as c_name, degree FROM score, course</span><br><span class="line">WHERE score.c_no &#x3D; course.no;</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| s_no | c_name          | degree |</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| 103  | 计算机导论      |     92 |</span><br><span class="line">| 105  | 计算机导论      |     88 |</span><br><span class="line">| 109  | 计算机导论      |     76 |</span><br><span class="line">| 103  | 操作系统        |     86 |</span><br><span class="line">| 105  | 操作系统        |     75 |</span><br><span class="line">| 109  | 操作系统        |     68 |</span><br><span class="line">| 103  | 数字电路        |     85 |</span><br><span class="line">| 105  | 数字电路        |     79 |</span><br><span class="line">| 109  | 数字电路        |     81 |</span><br><span class="line">+------+-----------------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 课程表</span><br><span class="line">SELECT no, name FROM course;</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br><span class="line"></span><br><span class="line">-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。</span><br><span class="line">SELECT student.name as s_name, course.name as c_name, degree </span><br><span class="line">FROM student, score, course</span><br><span class="line">WHERE student.NO &#x3D; score.s_no</span><br><span class="line">AND score.c_no &#x3D; course.no;</span><br></pre></td></tr></table></figure>

<h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询</span><br><span class="line">SELECT s_no, c_no, degree FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT c_no, AVG(degree) FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)</span><br><span class="line">GROUP BY c_no;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     82.0000 |</span><br><span class="line">| 3-245 |     71.5000 |</span><br><span class="line">| 6-166 |     80.0000 |</span><br><span class="line">+-------+-------------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score </span><br><span class="line">WHERE c_no &#x3D; &#39;3-105&#39;</span><br><span class="line">AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。</span><br><span class="line">SELECT * FROM score</span><br><span class="line">WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- YEAR(..): 取出日期中的年份</span><br><span class="line">SELECT no, name, birthday FROM student</span><br><span class="line">WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</span><br></pre></td></tr></table></figure>

<h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );</span><br></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE t_no &#x3D; ( </span><br><span class="line">        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; </span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询 teacher 表</span><br><span class="line">SELECT no, name FROM teacher;</span><br><span class="line">+-----+--------+</span><br><span class="line">| no  | name   |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 804 | 李诚   |</span><br><span class="line">| 825 | 王萍   |</span><br><span class="line">| 831 | 刘冰   |</span><br><span class="line">| 856 | 张旭   |</span><br><span class="line">+-----+--------+</span><br><span class="line"></span><br><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 在这里找到对应的条件</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course;</span><br><span class="line">-- t_no: 教师编号</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| no    | name            | t_no |</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| 3-105 | 计算机导论      | 825  |</span><br><span class="line">| 3-245 | 操作系统        | 804  |</span><br><span class="line">| 6-166 | 数字电路        | 856  |</span><br><span class="line">| 9-888 | 高等数学        | 831  |</span><br><span class="line">+-------+-----------------+------+</span><br></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在此之前向 score 插入一些数据，以便丰富查询条件。</span><br><span class="line">INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。</span><br><span class="line">SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;</span><br><span class="line">+-------+</span><br><span class="line">| c_no  |</span><br><span class="line">+-------+</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT t_no FROM course WHERE no IN (</span><br><span class="line">    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">);</span><br><span class="line">+------+</span><br><span class="line">| t_no |</span><br><span class="line">+------+</span><br><span class="line">| 825  |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 最终条件</span><br><span class="line">    SELECT t_no FROM course WHERE no IN (</span><br><span class="line">        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号</span><br><span class="line">SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| no  | name   | department   |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| 804 | 李诚   | 计算机系     |</span><br><span class="line">| 825 | 王萍   | 计算机系     |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line"></span><br><span class="line">-- 通过 course 表查询该教师的课程编号</span><br><span class="line">SELECT no FROM course WHERE t_no IN (</span><br><span class="line">    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br><span class="line">+-------+</span><br><span class="line">| no    |</span><br><span class="line">+-------+</span><br><span class="line">| 3-245 |</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br><span class="line"></span><br><span class="line">-- 根据筛选出来的课程号查询成绩表</span><br><span class="line">SELECT * FROM score WHERE c_no IN (</span><br><span class="line">    SELECT no FROM course WHERE t_no IN (</span><br><span class="line">        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT: 代表逻辑非</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;</span><br><span class="line">)</span><br><span class="line">-- 合并两个集</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- ANY: 符合SQL语句中的任意条件。</span><br><span class="line">-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，</span><br><span class="line">-- 最后根据降序查询结果。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">) ORDER BY degree DESC;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 只需对上一道题稍作修改。</span><br><span class="line">-- ALL: 符合SQL语句中的所有条件。</span><br><span class="line">-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询平均分</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     87.6667 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line">SELECT degree FROM score;</span><br><span class="line">+--------+</span><br><span class="line">| degree |</span><br><span class="line">+--------+</span><br><span class="line">|     90 |</span><br><span class="line">|     91 |</span><br><span class="line">|     92 |</span><br><span class="line">|     86 |</span><br><span class="line">|     85 |</span><br><span class="line">|     89 |</span><br><span class="line">|     88 |</span><br><span class="line">|     75 |</span><br><span class="line">|     79 |</span><br><span class="line">|     76 |</span><br><span class="line">|     68 |</span><br><span class="line">|     81 |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">-- 将表 b 作用于表 a 中查询数据</span><br><span class="line">-- score a (b): 将表声明为 a (b)，</span><br><span class="line">-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。</span><br><span class="line">SELECT * FROM score a WHERE degree &lt; (</span><br><span class="line">    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| name   | department      |</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| 李诚   | 计算机系        |</span><br><span class="line">| 王萍   | 计算机系        |</span><br><span class="line">| 刘冰   | 电子工程系      |</span><br><span class="line">| 张旭   | 电子工程系      |</span><br><span class="line">+--------+-----------------+</span><br></pre></td></tr></table></figure>

<h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看学生表信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line"></span><br><span class="line">-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。</span><br><span class="line">SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;</span><br><span class="line">+-------+</span><br><span class="line">| class |</span><br><span class="line">+-------+</span><br><span class="line">| 95033 |</span><br><span class="line">| 95031 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT: 取反</span><br><span class="line">-- LIKE: 模糊查询</span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。</span><br><span class="line">SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 曾华      |   42 |</span><br><span class="line">| 匡明      |   44 |</span><br><span class="line">| 王丽      |   43 |</span><br><span class="line">| 李军      |   43 |</span><br><span class="line">| 王芳      |   44 |</span><br><span class="line">| 陆军      |   45 |</span><br><span class="line">| 王尼玛    |   43 |</span><br><span class="line">| 张全蛋    |   44 |</span><br><span class="line">| 赵铁柱    |   45 |</span><br><span class="line">| 张飞      |   45 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure>

<h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(birthday), MIN(birthday) FROM student;</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| MAX(birthday) | MIN(birthday) |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| 1977-09-01    | 1974-06-03    |</span><br><span class="line">+---------------+---------------+</span><br></pre></td></tr></table></figure>

<h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student ORDER BY class DESC, birthday;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| no    | name         | t_no |</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| 3-245 | 操作系统     | 804  |</span><br><span class="line">| 6-166 | 数字电路     | 856  |</span><br><span class="line">+-------+--------------+------+</span><br></pre></td></tr></table></figure>

<h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 找出最高成绩（该查询只能有一个结果）</span><br><span class="line">SELECT MAX(degree) FROM score;</span><br><span class="line"></span><br><span class="line">-- 根据上面的条件筛选出所有最高成绩表，</span><br><span class="line">-- 该查询可能有多个结果，假设 degree 值多次符合条件。</span><br><span class="line">SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先将李军的性别作为条件取出来</span><br><span class="line">SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;</span><br><span class="line">+-----+</span><br><span class="line">| sex |</span><br><span class="line">+-----+</span><br><span class="line">| 男  |</span><br><span class="line">+-----+</span><br><span class="line"></span><br><span class="line">-- 根据性别查询 name 和 sex</span><br><span class="line">SELECT name, sex FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+</span><br><span class="line">| name      | sex |</span><br><span class="line">+-----------+-----+</span><br><span class="line">| 曾华      | 男  |</span><br><span class="line">| 匡明      | 男  |</span><br><span class="line">| 李军      | 男  |</span><br><span class="line">| 陆军      | 男  |</span><br><span class="line">| 王尼玛    | 男  |</span><br><span class="line">| 张全蛋    | 男  |</span><br><span class="line">| 赵铁柱    | 男  |</span><br><span class="line">| 张飞      | 男  |</span><br><span class="line">+-----------+-----+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, sex, class FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">) AND class &#x3D; (</span><br><span class="line">    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| name      | sex | class |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| 曾华      | 男  | 95033 |</span><br><span class="line">| 李军      | 男  | 95033 |</span><br><span class="line">| 王尼玛    | 男  | 95033 |</span><br><span class="line">+-----------+-----+-------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;</span><br><span class="line">) AND s_no IN (</span><br><span class="line">    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE grade (</span><br><span class="line">    low INT(3),</span><br><span class="line">    upp INT(3),</span><br><span class="line">    grade char(1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO grade VALUES (90, 100, &#39;A&#39;);</span><br><span class="line">INSERT INTO grade VALUES (80, 89, &#39;B&#39;);</span><br><span class="line">INSERT INTO grade VALUES (70, 79, &#39;C&#39;);</span><br><span class="line">INSERT INTO grade VALUES (60, 69, &#39;D&#39;);</span><br><span class="line">INSERT INTO grade VALUES (0, 59, &#39;E&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM grade;</span><br><span class="line">+------+------+-------+</span><br><span class="line">| low  | upp  | grade |</span><br><span class="line">+------+------+-------+</span><br><span class="line">|   90 |  100 | A     |</span><br><span class="line">|   80 |   89 | B     |</span><br><span class="line">|   70 |   79 | C     |</span><br><span class="line">|   60 |   69 | D     |</span><br><span class="line">|    0 |   59 | E     |</span><br><span class="line">+------+------+-------+</span><br></pre></td></tr></table></figure>

<p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, grade FROM score, grade </span><br><span class="line">WHERE degree BETWEEN low AND upp;</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| s_no | c_no  | grade |</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| 101  | 3-105 | A     |</span><br><span class="line">| 102  | 3-105 | A     |</span><br><span class="line">| 103  | 3-105 | A     |</span><br><span class="line">| 103  | 3-245 | B     |</span><br><span class="line">| 103  | 6-166 | B     |</span><br><span class="line">| 104  | 3-105 | B     |</span><br><span class="line">| 105  | 3-105 | B     |</span><br><span class="line">| 105  | 3-245 | C     |</span><br><span class="line">| 105  | 6-166 | C     |</span><br><span class="line">| 109  | 3-105 | C     |</span><br><span class="line">| 109  | 3-245 | D     |</span><br><span class="line">| 109  | 6-166 | B     |</span><br><span class="line">+------+-------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE testJoin;</span><br><span class="line"></span><br><span class="line">CREATE TABLE person (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    cardId INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE card (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);</span><br><span class="line">SELECT * FROM card;</span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | name      |</span><br><span class="line">+------+-----------+</span><br><span class="line">|    1 | 饭卡      |</span><br><span class="line">|    2 | 建行卡    |</span><br><span class="line">|    3 | 农行卡    |</span><br><span class="line">|    4 | 工商卡    |</span><br><span class="line">|    5 | 邮政卡    |</span><br><span class="line">+------+-----------+</span><br><span class="line"></span><br><span class="line">INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);</span><br><span class="line">SELECT * FROM person;</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| id   | name   | cardId |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|    1 | 张三   |      1 |</span><br><span class="line">|    2 | 李四   |      3 |</span><br><span class="line">|    3 | 王五   |      6 |</span><br><span class="line">+------+--------+--------+</span><br></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。</span><br><span class="line">-- on: 表示要执行某个条件。</span><br><span class="line">SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line"></span><br><span class="line">-- 将 INNER 关键字省略掉，结果也是一样的。</span><br><span class="line">-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。</span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 不支持这种语法的全外连接</span><br><span class="line">-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">-- 出现错误：</span><br><span class="line">-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;</span><br><span class="line"></span><br><span class="line">-- MySQL全连接语法，使用 UNION 将两张表合并在一起。</span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- a -&gt; -100</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- b -&gt; +100</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询事务的自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            1 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE bank;</span><br><span class="line"></span><br><span class="line">USE bank;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    money INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user VALUES (1, &#39;a&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 回滚到最后一次提交</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 关闭自动提交</span><br><span class="line">SET AUTOCOMMIT &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- 查询自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            0 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line"></span><br><span class="line">-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，</span><br><span class="line">-- 发生变化的数据并没有真正插入到数据表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 数据表中的真实数据其实还是：</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 由于数据还没有真正提交，可以使用回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line">-- 手动提交数据（持久性），</span><br><span class="line">-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 提交后测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询（回滚无效了）</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 转账</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- 到账</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假设转账发生了意外，需要回滚。</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p>
<h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务</span><br><span class="line">-- START TRANSACTION;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">-- 由于手动开启的事务没有开启自动提交，</span><br><span class="line">-- 此时发生变化的数据仍然是被保存在一张临时表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 测试回滚（无效，因为表的数据已经被提交）</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li>
<li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li>
<li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li>
<li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。</span><br><span class="line">+--------------------------------+</span><br><span class="line"></span><br><span class="line">-- MySQL 5.x</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;</span><br><span class="line">SELECT @@TX_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">-- 查询系统隔离级别，发现已经被修改。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-UNCOMMITTED               |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);</span><br><span class="line">INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 开启一个事务操作数据</span><br><span class="line">-- 假设小明在淘宝店买了一双800块钱的鞋子：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 然后淘宝店在另一方查询结果，发现钱已到账。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小明所处的事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 此时无论对方是谁，如果再去查询结果就会发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-COMMITTED                 |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正在操作数据事务（当前事务）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，</span><br><span class="line">-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 假设此时在远程开启了一个新事务，连接到数据库。</span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line">-- 此时远程连接查询到的数据只能是已经提交过的</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张在查询数据的时候发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 在小张求表的 money 平均值之前，小王做了一个操作：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO user VALUES (5, &#39;c&#39;, 100);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 此时表的真实数据是：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：</span><br><span class="line">SELECT AVG(money) FROM user;</span><br><span class="line">+------------+</span><br><span class="line">| AVG(money) |</span><br><span class="line">+------------+</span><br><span class="line">|  820.0000  |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小王 - 北京</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></span><br></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| SERIALIZABLE                   |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张 - 成都</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 小王 - 北京</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 开启事务之前先查询表，准备操作数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">|  6 | d         |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 发现没有 7 号王小花，于是插入一条数据：</span><br><span class="line">INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);</span><br></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/05/26/Git/</url>
    <content><![CDATA[<p>Git：目前最先进的分布式版本控制系统</p>
<p>Workspace：工作区<br>Index/Stage：暂存区<br>Repository：仓库区（本地仓库）<br>Remote：远程仓库</p>
<p>SVN/Git区别：<br>    SVN是集中式的版本控制系统，版本库是集中放在中央服务器的，自己弄的时候，都是在自己的电脑，首先要从中央服务器拿到最新的版本，做完自己的工作，再推送到中央服务器，集中式版本控制系统必须联网才能工作。如果局域网可以，带宽够大，速度够快，在互联网下网速慢的话，就不好了。<br>    Git是分布式的版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，所以工作的时候不需要联网，因为版本都在自己的电脑上，多人协作的时候，如果两个人都修改了文件A，两个人只需把各自的修改推送给对方，就可以互相看到对方的修改。</p>
<p>版本库repository：<br>    也叫仓库，可以简单理解为一个目录，这个目录所有的文件都可以被Git管理起来，每个文件的修改，删除，Git都能被跟踪，以便任何时刻都可以跟踪历史，或者在将来的某个时刻可以将文件‘还原’。</p>
<p>理解工作区和暂存区：<br>    工作区：自己电脑的目录，比如目录下testgit里的文件（.git隐藏目录版本库除外）。或者以后需要再建的目录文件等都属于工作区的范畴<br>    版本库（Repository）：工作区的隐藏目录.git,这个不属于工作区，这是版本库。其中版本库存了很多东西，其中最重要的就是st<br>    age（暂存区），还有Git为我们自动创建的第一个master，以及指向master的一个分支HEAD。</p>
<p>使用Git提交文件到版本库步骤：<br>    1：使用git add把文件添加进去，实际就是把文件添加到暂存区<br>    2：使用git commit提交更改，实际就是把暂存区的内容提交到当前分支。</p>
<p>暂存区：</p>
<p>远程仓库：<br>    首先注册github账号，本地Git和github仓库之间是通过SSH加密的，所以需要设置：<br>        1，</p>
<a id="more"></a>


<p>所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码，Git也是，版本控制系统可以告诉自己每次的改动，但是图片，视频这些二进制文件，虽然也能由版本控制西永管理，但还是没法跟踪文件的变化，只能把二进制文件每次改动串动起来，也就知道文件从1kb变成了2kb，但是改了什么，版本控制也不知道。</p>
]]></content>
  </entry>
  <entry>
    <title>one_hot编码的意义</title>
    <url>/2021/10/29/one_hot%E7%BC%96%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>参考文章：<a href="https://blog.csdn.net/u013385925/article/details/80142310?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E6%A0%87%E7%AD%BE%E5%80%BC%E8%BF%9B%E8%A1%8Conehot%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-80142310.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/u013385925/article/details/80142310?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E6%A0%87%E7%AD%BE%E5%80%BC%E8%BF%9B%E8%A1%8Conehot%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-80142310.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187</a> </p>
<p><a href="https://www.quora.com/What-are-good-ways-to-handle-discrete-and-continuous-inputs-together" target="_blank" rel="noopener">https://www.quora.com/What-are-good-ways-to-handle-discrete-and-continuous-inputs-together</a> </p>
<p>对于离散型的特征值，普遍使用one_hot编码形式。当离散的特征值由多少个，one_hot的编码就有几维。例如阿拉伯数字的话，一共0-9个标签值的话，按照one_hot进行编码，就是采用10维。</p>
<p>为什么使用one_hot编码来处理离散型数据：</p>
<p>1️⃣ 使用one_hot编码，可以使得离散的特征值扩展到欧式空间中，离散特征的某个取值就对应欧式空间的某个点。 </p>
<p>2️⃣  将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。 </p>
<p>3️⃣  将离散型特征使用one-hot编码，确实会让特征之间的距离计算更加合理。比如，有一个离散型特征，代表工作类型，该离散型特征，共有三个取值，不使用one-hot编码，其表示分别是x_1 = (1), x_2 = (2), x_3 = (3)。两个工作之间的距离是，(x_1, x_2) = 1, d(x_2, x_3) = 1, d(x_1, x_3) = 2。那么x_1和x_3工作之间就越不相似吗？显然这样的表示，计算出来的特征的距离是不合理。那如果使用one-hot编码，则得到x_1 = (1, 0, 0), x_2 = (0, 1, 0), x_3 = (0, 0, 1)，那么两个工作之间的距离就都是sqrt(2).即每两个工作之间的距离是一样的，显得更合理。 </p>
<p>4️⃣  对离散型特征进行one-hot编码是为了让距离的计算显得更加合理。 </p>
<p>5️⃣  有些情况不需要进行特征的归一化：   基于树的方法是不需要进行特征的归一化，例如随机森林，bagging 和 boosting等。<strong>基于参数的模型或基于距离的模型，都是要进行特征的归一化。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>javaee</title>
    <url>/2021/05/21/javaee/</url>
    <content><![CDATA[<h3 id="maven"><a href="#maven" class="headerlink" title="maven:"></a>maven:</h3><p>[1] 根目录：工程名</p>
<p>[2] |—src：源码</p>
<p>[3] |—|—main:存放主程序,目录下是项目的主要代码</p>
<p>[4] |—|—|—java：java源码文件</p>
<p>[5] |—|—|—resource：存放框架的配置文件</p>
<p>[6] |—|—test：存放测试程序,目录下存放测试相关的代码</p>
<p>[7] |—pop.xml：maven的核心配置文件</p>
<p>webapp下存放Web应用相关代码</p>
<a id="more"></a>
<h3 id="常用maven命令"><a href="#常用maven命令" class="headerlink" title="常用maven命令"></a>常用maven命令</h3><p>[1] mvn clean：清理</p>
<p>[2] mvn compile：编译主程序</p>
<p>[3] mvn test-compile：编译测试程序</p>
<p>[4] mvn test：执行测试</p>
<p>[5] mvn package：打包</p>
<p>[6] mvn install：安装</p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h3><p><strong>1、modelVersion</strong></p>
<p>​    指定了当前Maven模型的版本号</p>
<p><strong>2、groupId</strong></p>
<p>　　顾名思义，这个应该是公司名或是组织名。一般来说groupId是由三个部分组成，每个部分之间以”.”分隔，第一部分是项目用途，比如用于商业的就是”com”，用于非营利性组织的就　　是”org”；第二部分是公司名，比如”tengxun”、”baidu”、”alibaba”；第三部分是你的项目名</p>
<p><strong>3、artifactId</strong></p>
<p>　　可以认为是Maven构建的项目名，比如你的项目中有子项目，就可以使用”项目名-子项目名”的命名方式</p>
<p><strong>4、version</strong></p>
<p>　　版本号，SNAPSHOT意为快照，说明该项目还在开发中，是不稳定的版本。在Maven中很重要的一点是，<strong>groupId、artifactId、version三个元素生成了一个Maven项目的基本坐标</strong></p>
<p><strong>5、packing</strong></p>
<p>​    项目打包的类型，可以使用jar，war，rar等，默认jar</p>
<p><strong>6、dependencies和dependency</strong></p>
<p> 前者包含后者。前面说了，Maven的一个重要作用就是统一管理jar包，为了一个项目可以build或运行，项目中不可避免的，会依赖很多其他的jar包，在Maven中，这些依赖就被称为dependency。 </p>
<p><strong>7、properties</strong></p>
<p> properties是用来定义一些配置属性的，例如project.build.sourceEncoding（项目构建源码编码方式），可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级。 </p>
<h3 id="maven-多模块"><a href="#maven-多模块" class="headerlink" title="maven 多模块"></a>maven 多模块</h3><p>Spring MVC：<br>    web开发中的请求-响应模型：<br>        web客户端如：IE浏览器先发送请求，web服务器接收请求，处理请求，然后产生响应，响应再返回网站首页内容，浏览器接收响应并渲染。<br>    web世界里：<br>        web浏览器（如IE）发送请求：如，访问<a href="http://sishuok.com" target="_blank" rel="noopener">http://sishuok.com</a><br>        web服务器（如tomcat）接收请求，处理请求（比如用户新增，则把用户保存一下），最后产生响应（一般为html）<br>        web服务器处理完成后，返回内容给web客户端（一般就是我们的浏览器），客户端对接收的内容进行处理（如web浏览器将会对接收到的html内容进行渲染，展示给客户）<br>        因此，都是web客户端发起请求，web服务器接收，处理并产生响应，一般web服务器不主动通知web客户端更新内容<br>    MVC模型：<br>        一种架构行的模式，本身不引入新的功能，只是将开发的结构组织的更加合理。<br>        展示和模型分离，流程控制逻辑，业务逻辑调用与展示逻辑分离。</p>
<pre><code>图片------

MVC：Model-View-Controller
Model（模型）：数据模型，提供要展示的数据，所以包括数据和行为，可以是领域模型或者JavaBean组件（包含数据和行为），不过现在一般分离开：Value Object（数据） 和 服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
View（视图）：负责进行模型的展示，一般就是看到的用户界面，客户想看到的东西。
Controller（控制器）：接收用户请求，委托模型进行处理（状态改变），处理完毕后把返回的数据返回给视图，视图进行展示。也就是说Controller作了一个调度的工作。

WebMVC：
    标准的MVC能主动推数据给视图进行更新，在web开发中模型无法主动推给视图（无法主动更新用户界面），因为web开发是请求-相应式模型</code></pre>]]></content>
  </entry>
  <entry>
    <title>tensorflow的onehot函数使用</title>
    <url>/2021/10/29/tensorflow%E7%9A%84onehot%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>原文地址：<a href="https://blog.csdn.net/dally2/article/details/108007756" target="_blank" rel="noopener">https://blog.csdn.net/dally2/article/details/108007756</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one_hot(</span><br><span class="line">    indices,        #输入的tensor，在深度学习中一般是给定的labels，通常是数字列表，属于一维输入，也可以是多维。</span><br><span class="line">    depth,          #一个标量，用于定义一个 one hot 维度的深度</span><br><span class="line">    on_value&#x3D;None,  #定义在 indices[j] &#x3D; i 时填充输出的值的标量，默认为1</span><br><span class="line">    off_value&#x3D;None, #定义在 indices[j] !&#x3D; i 时填充输出的值的标量，默认为0</span><br><span class="line">    axis&#x3D;None,      #要填充的轴，默认为-1，即一个新的最内层轴</span><br><span class="line">    dtype&#x3D;None,     #默认是int32</span><br><span class="line">    name&#x3D;None</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>indices是用来确定生成张量中哪些位置的值是on_value</p>
]]></content>
  </entry>
  <entry>
    <title>SQL语法</title>
    <url>/2021/06/04/SQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>模式定义了数据如何存储，存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋值给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准SQL由ANSI标准委员会管理，从而称为ANSI SQL。各个DBMS都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL不区分大小写，但数据库表名，列名和值是否区分依赖于具体的DBMS以及配置</p>
<p>SQL支持的注释：</p>
<a id="more"></a>
<p>注释：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure>

<p>数据库创建和使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<!--more-->
<h2 id="二，创建表"><a href="#二，创建表" class="headerlink" title="二，创建表"></a>二，创建表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create Table mytable(</span><br><span class="line">	#int 类型 ，不为空，自增</span><br><span class="line">	id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">	#int 类型，不为空，默认值为1，不为空</span><br><span class="line">	col1 INT NOT NULL DEFAULT1,</span><br><span class="line">	#变长字符串类型，最长为45个字符，可以为空</span><br><span class="line">	col2 VARCHAR(45) NULL,</span><br><span class="line">	#日期类型，不为空</span><br><span class="line">	col3 DATE NULL,</span><br><span class="line">	#设置主键id</span><br><span class="line">	PRIMARY KEY(&#39;id&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="三，修改表"><a href="#三，修改表" class="headerlink" title="三，修改表"></a>三，修改表</h2><p>添加列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">ADD col CHAR(20);</span><br></pre></td></tr></table></figure>

<p>删除列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">DROP COLUMN col;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE mytable;</span><br></pre></td></tr></table></figure>

<h2 id="四，插入"><a href="#四，插入" class="headerlink" title="四，插入"></a>四，插入</h2><p>普通插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytable(col1,col2)</span><br><span class="line">VALUE(val1,val2);</span><br></pre></td></tr></table></figure>

<p>插入检索出来的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytable(col1,col2)</span><br><span class="line">SELECT col1,col2</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>

<p>将一个表的内容插入一个新表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE newtable AS </span><br><span class="line">SELECT *FROM mytable;</span><br></pre></td></tr></table></figure>

<h2 id="五，更新"><a href="#五，更新" class="headerlink" title="五，更新"></a>五，更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mytable</span><br><span class="line">set col &#x3D; val</span><br><span class="line">WHERE ID&#x3D;1;</span><br></pre></td></tr></table></figure>

<h2 id="六，删除"><a href="#六，删除" class="headerlink" title="六，删除"></a>六，删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p> <strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE mytable;</span><br></pre></td></tr></table></figure>

<p>使用更新和删除操作时一定要用WHERE子句，不然会把整张表的数据都破坏了。</p>
<p>可以先用SELECT语句进行测试，防止错误删除。</p>
<h2 id="七，查询"><a href="#七，查询" class="headerlink" title="七，查询"></a>七，查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>相同的值只会出现一次。他的作用是用于所有列，也就是说所有的列的值都是相同的才算相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT col1, col2</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数，可以有两个参数，第一个参数为起始行，从0开始；</p>
<p>第二个参数为返回的总行数。</p>
<p>返回前五行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 0, 5;</span><br></pre></td></tr></table></figure>

<p>返回第3~5行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="八，排序"><a href="#八，排序" class="headerlink" title="八，排序"></a>八，排序</h2><p>ASC：升序（默认）</p>
<p>DESC：降序</p>
<p>可以按照多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="九，过滤"><a href="#九，过滤" class="headerlink" title="九，过滤"></a>九，过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用SQL语句来过滤不必要的数据，而不是传输所有的数据到客户端进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>WHERE子句的操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&gt; !=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;= !&gt;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;= !&lt;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center">为 NULL 值</td>
</tr>
</tbody></table>
<p>注意：NULL，0，空字符串都是不同的。</p>
<p>AND和OR用于连接多个过滤条件。优先处理AND，当一个过滤条件表达式涉及到多个AND和OR时，可以使用（）来决定优先级，使得优先级更加清晰。</p>
<p>IN操作符用于匹配一组值，其后也可以接一个SELECT子句，从而匹配子查询得到的一组值。</p>
<p>NOT操作符用于否定一个条件。</p>
<h2 id="十，通配符"><a href="#十，通配符" class="headerlink" title="十，通配符"></a>十，通配符</h2><p>通配符也是用在过滤语句中，但只用于文本字段。</p>
<ul>
<li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li>
<li><strong>_</strong> 匹配 ==1 个任意字符；</li>
<li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure>

<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h2 id="十一，计算字段"><a href="#十一，计算字段" class="headerlink" title="十一，计算字段"></a>十一，计算字段</h2><p>在数据库服务器上完成数据的</p>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 </p>
<p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。 </p>
<h2 id="十二，函数"><a href="#十二，函数" class="headerlink" title="十二，函数"></a>十二，函数</h2><p>各个DBMS的函数都是不相同的，因此不可移植，一下主要是MYSQL的函数。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th align="left">函 数</th>
<th align="right">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AVG()</td>
<td align="right">返回某列的平均值</td>
</tr>
<tr>
<td align="left">COUNT()</td>
<td align="right">返回某列的行数</td>
</tr>
<tr>
<td align="left">MAX()</td>
<td align="right">返回某列的最大值</td>
</tr>
<tr>
<td align="left">MIN()</td>
<td align="right">返回某列的最小值</td>
</tr>
<tr>
<td align="left">SUM()</td>
<td align="right">返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG()会忽略NULL行。</p>
<p>使用DISTINCT可以汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LEFT()</td>
<td align="left">左边的字符</td>
</tr>
<tr>
<td align="center">RIGHT()</td>
<td align="left">右边的字符</td>
</tr>
<tr>
<td align="center">LOWER()</td>
<td align="left">转换为小写字符</td>
</tr>
<tr>
<td align="center">UPPER()</td>
<td align="left">转换为大写字符</td>
</tr>
<tr>
<td align="center">LTRIM()</td>
<td align="left">去除左边的空格</td>
</tr>
<tr>
<td align="center">RTRIM()</td>
<td align="left">去除右边的空格</td>
</tr>
<tr>
<td align="center">LENGTH()</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="center">SOUNDEX()</td>
<td align="left">转换为语音值</td>
</tr>
</tbody></table>
<p> 其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</zero-width></li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="left">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDDATE()</td>
<td align="left">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center">ADDTIME()</td>
<td align="left">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="left">返回当前日期</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="left">返回当前时间</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="left">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="left">计算两个日期之差</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="left">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="left">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="left">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DAYOFWEEK()</td>
<td align="left">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="left">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="left">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="left">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">NOW()</td>
<td align="left">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="left">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">TIME()</td>
<td align="left">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="left">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="left">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="left">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="left">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="left">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="left">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="left">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="left">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="left">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="left">随机数</td>
</tr>
</tbody></table>
<h3 id="十三，分组"><a href="#十三，分组" class="headerlink" title="十三，分组"></a>十三，分组</h3><p>把相同的数据值的行放在同一组中。</p>
<p>可以最同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按照字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure>

<p> GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<p> WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h2 id="十四，子查询"><a href="#十四，子查询" class="headerlink" title="十四，子查询"></a>十四，子查询</h2><p>子查询中智能返回一个字段的数据</p>
<p>可以将子查询的结果作为WHERE语句的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p> 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="十五，连接"><a href="#十五，连接" class="headerlink" title="十五，连接"></a>十五，连接</h2><p>连接用于连接多张表，使用JOIN关键字，并且条件语句使用ON而不是WHERE。</p>
<p>连接可以代替子查询，并且比子查询效率一般会更快。</p>
<p>可以用AS给列名，计算机字段和表名取别名，给表名取别名是为了简化SQL语句以及连接相同表。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称为等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<p>可以不明确使用 INNER JOIN,而使用不同查询并在 WHERE 中将两张表中要连接的列用等等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接可以看成内连接的一种，只是表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找到与Jim处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，通名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接保留了没有关联的那些行，分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p> 检索所有顾客的订单信息，包括还没有订单信息的顾客。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h2 id="十六，组合查询"><a href="#十六，组合查询" class="headerlink" title="十六，组合查询"></a>十六，组合查询</h2><p>使用UNION来组合两个查询，如果第一个查询返回M行，第二个查询返回N行，那么组合查询的结果一般为M+N行。</p>
<p>每一个查询必须包含相同的列，表达式和聚合函数</p>
<p>默认会去处相同行，如果需要保留相同行，使用UNION ALL。</p>
<p>只能包含一个ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十七，视图"><a href="#十七，视图" class="headerlink" title="十七，视图"></a>十七，视图</h2><p>视图是虚拟的表，本身不包含数据，也就是不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图的好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure>

<h2 id="十八，存储过程"><a href="#十八，存储过程" class="headerlink" title="十八，存储过程"></a>十八，存储过程</h2><p>存储过程可以看成是对一系列SQL操作的批处理。</p>
<p>使用存储过程的好处:</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中存储过程需要自定义分隔符，因为命令行是以；为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
]]></content>
  </entry>
  <entry>
    <title>tf没有placeholder属性</title>
    <url>/2021/10/31/tf%E6%B2%A1%E6%9C%89placeholder%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>当使用tf的占位符属性的时候报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf </span><br><span class="line">X = tf.placeholder(<span class="string">"float"</span>)</span><br></pre></td></tr></table></figure>

<p>会出现：AttributeError: module ‘tensorflow’ has no attribute ‘placeholder’ 的错误。</p>
<p>解决办法：</p>
<p><a href="https://gimoonnam.github.io/machinelearning/tensorFlow_1/" target="_blank" rel="noopener">https://gimoonnam.github.io/machinelearning/tensorFlow_1/</a></p>
]]></content>
  </entry>
  <entry>
    <title>tf的Session语句报错</title>
    <url>/2021/10/31/tf%E7%9A%84Session%E8%AF%AD%E5%8F%A5%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>参考文章：<a href="https://www.cnblogs.com/123456www/p/12584427.html" target="_blank" rel="noopener">https://www.cnblogs.com/123456www/p/12584427.html</a></p>
<p>自己在查看tensor数据的时候，notebook显示报错信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError: module &#39;tensorflow&#39; has no attribute &#39;Session&#39;</span><br></pre></td></tr></table></figure>

<p>原因是 tensorflow 的2.0版本之后模块里面没有了Session属性，如果想用tf的Session属性，可以换成的语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.compat.v1.Session()</span><br></pre></td></tr></table></figure>

<p>要想运行时不再报错的话，再在程序开头加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.compat.v1.disable_eager_execution()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python错误,SyntaxError unexpected EOF while parsing</title>
    <url>/2021/11/01/python%E9%94%99%E8%AF%AF,SyntaxError%20unexpected%20EOF%20while%20parsing/</url>
    <content><![CDATA[<p> 原文地址：<a href="https://blog.csdn.net/huitinfeng/article/details/100051074" target="_blank" rel="noopener">https://blog.csdn.net/huitinfeng/article/details/100051074</a></p>
<p><strong>错误信息：SyntaxError: unexpected EOF while parsing</strong> </p>
<p>错误理解：循环结束不了。</p>
<p>①  <strong>这个后边的错误是说解释器循环完了到最后也没能找到它要的条件或是其他程序需要的</strong> </p>
<p>② <strong>有可能你哪个地方少了个括号或者中英文切换的时候输入了中文字符</strong></p>
<p><strong>③ 或者你的for循环有问题，仔细检查一下</strong></p>
<p><strong>④ 再有就是eval在处理空字符串时会返回EOF错误，然后一行一行的读下去就可以找到了</strong></p>
<p>我的错误是，with会话下面的一个语句写错了，print语句少了一个括号，😂。</p>
]]></content>
  </entry>
  <entry>
    <title>python错误 RuntimeError Attempted to use a closed Session</title>
    <url>/2021/11/01/python%E9%94%99%E8%AF%AF%20RuntimeError%20Attempted%20to%20use%20a%20closed%20Session/</url>
    <content><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/weixin_39390732/article/details/76474294?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163575595316780274122772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163575595316780274122772&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-76474294.first_rank_v2_pc_rank_v29&amp;utm_term=RuntimeError%3A+Attempted+to+use+a+closed+Session.&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39390732/article/details/76474294?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163575595316780274122772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163575595316780274122772&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-76474294.first_rank_v2_pc_rank_v29&amp;utm_term=RuntimeError%3A+Attempted+to+use+a+closed+Session.&amp;spm=1018.2226.3001.4187</a></p>
<p>自己出现这错误的原因是在开启一个session会话之前就使用了读写文件操作。</p>
<p>网上的报错情况是在关闭一个会话之后又使用了读写操作，也是不行的，必须都是在with语句代码块之内进行这些操作的。</p>
<p><img src="https://i.loli.net/2021/11/01/Qdsvj2pAMK3Zywa.png" alt="捕获.PNG"></p>
]]></content>
  </entry>
  <entry>
    <title>反射机制</title>
    <url>/2021/07/04/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>反射概念：程序能够访问，监测和修改自身状态和行为的一种能力</p>
<p>反射是一种强大工具，能够创建灵活代码，代码可以在运行时装配，无序在组件内进行源代码链接。<br>如果使用不当，成本很高</p>
]]></content>
  </entry>
  <entry>
    <title>中原工学院数据库系统概论试题</title>
    <url>/2021/06/05/%E4%B8%AD%E5%8E%9F%E5%B7%A5%E5%AD%A6%E9%99%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="《数据库系统概论》期末考试卷"><a href="#《数据库系统概论》期末考试卷" class="headerlink" title="《数据库系统概论》期末考试卷"></a>《数据库系统概论》期末考试卷</h1><h2 id="一，填空题"><a href="#一，填空题" class="headerlink" title="一，填空题"></a>一，填空题</h2><p>1.实体之间的联系按照联系方式的不同可分为  <u>一对一</u> 、 <u>一对多</u> 和 <u>多对多</u>   。  </p>
<p>2.数据库系统的核心是  <u>数据库管理系统（DBMS）</u>。</p>
<p>3.在关系模型中，实体以及实体间的联系都是用  <u>关系</u>  来表示的。</p>
<p>4.在关系代数中专门的关系运算包括   <u>选择   、投影、   连接    、除</u>等运算。</p>
<p>5.1975年由IBM公司的M.Zloof提出的QBE语言是一个很有特色的 <u>域关系演算</u>   语言。</p>
<p>6.SQL语言集<u>数据查询</u>、  <u>数据操作</u>    、  <u>数据定义</u>和  <u>数据控制</u>   功能于一体，充分体现了关系数据语言的特点和优点。</p>
<p>7.数据库管理系统保证数据安全的主要措施是进行  <u>存取控制</u>     。</p>
<p>8.人们已经提出了许多种类型的数据依赖，其中最重要的是  <u>函数依赖</u>    和 <u>多值依赖</u>  。</p>
<p>9.关系模式由3NF转化为BCNF是消除了主属性对码的  <u>部分函数依赖</u>   和 <u>传递函数依赖</u>    。</p>
<p>10.数据库设计应包括两个方面的内容： <u>结构设计</u>和   <u>行为设计</u>。</p>
<p>11.CGI规范允许Web服务器执行  <u>外部程序</u>    ，并将它们的输出发送给浏览器。</p>
<p>12.数据库技术与  <u>面向对象</u>    技术相结合，形成了面向对象数据库系统。</p>
<a id="more"></a>
<h2 id="二，单项选择"><a href="#二，单项选择" class="headerlink" title="二，单项选择"></a>二，单项选择</h2><p>1.数据库类型是按照(  B  )来划分的。</p>
<p> A.文件形式    B.数据模型  C.记录形式    D.数据存取方法</p>
<p>2.关系演算的基础是(   C  )</p>
<p> A.形式逻辑中的逻辑演算   B.形式逻辑中的关系演算 C.数理逻辑中的谓词演算  D.数理逻辑中的形式演算</p>
<p>3.若要求分解保持函数依赖，那么模式分解一定能够达到(  B   )</p>
<p> A. 2NF      B. 3NF      C. BCNF      D. 1NF</p>
<p>4.1级封锁协议加上T要读取的数据R加S锁，这是(   C  )</p>
<p> A. 3级封锁协议   B. 4级封锁协议   C. 2级封锁协议  D. 1级封锁协议</p>
<p>5.建立数据字典的时机是(  A  )</p>
<p> A.需求分析阶段   B.数据库物理设计阶段   C.数据库实施  D.概念结构设计阶段</p>
<h2 id="三，简答题"><a href="#三，简答题" class="headerlink" title="三，简答题"></a>三，简答题</h2><p>1.简述数据库管理系统的功能。</p>
<p>DBMS功能包括：</p>
<p>数据定义，数据操纵，数据库运行管理，数据组织，存储和管理，数据库的建立和维护，数据通信接口。</p>
<p>2.简述SQL语言的特点。</p>
<p> SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，充分体现了关系数据库语言的特点和优点。其特点如下：</p>
<p>综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供两种操作方式，语言简洁，易学易用</p>
<p>3、什么是数据库系统?</p>
<p>答：数据库系统是实现有组织地、动态地存储大量关联数据，方便多用户访问的计算机软、硬资源组成的系统。它包含关联数据的集合，DBMS和用户应用程序等。</p>
<p>4、试述数据库完整保护的主要任务和措施。</p>
<p>主要任务是保障数据的正确性，有效性，协调性，提高数据对用户的可用性。</p>
<p>其措施如下：适时检查完整约束条件，保证语义完整。控制并发操作，使其不破坏完整性。在系统出现故障后，即时恢复系统。</p>
<p>5、在倒排文件中，如果只建立了部分关键字的辅索引，如何进行查找？</p>
<p>对询问中涉及的关键字，首先在已建立的辅索引中求指针的交集P，而后对P中所指记录逐个验证其它关键字是否与询问条件匹配，所有匹配的记录即为查询结果。</p>
<h2 id="四，综合题"><a href="#四，综合题" class="headerlink" title="四，综合题"></a>四，综合题</h2>]]></content>
  </entry>
  <entry>
    <title>学习资料链接</title>
    <url>/2021/06/04/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>01 Java基础阶段：<br>链接:<a href="https://pan.baidu.com/s/1IGjSH_y8oSthPP3DDzauKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IGjSH_y8oSthPP3DDzauKw</a>  密码:koa9<br>02 数据库阶段：<br>链接:<a href="https://pan.baidu.com/s/1tzAzYP5CbPbaPgTeQ1tqZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tzAzYP5CbPbaPgTeQ1tqZw</a>  密码:sbog<br>03 Web前端：<br>链接:<a href="https://pan.baidu.com/s/1uVWEaJ9Ie8xu7BQle_7peQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1uVWEaJ9Ie8xu7BQle_7peQ</a>  密码:p0wy<br>04 Javaweb阶段：<br>链接:<a href="https://pan.baidu.com/s/1haw_v4KEWwXPg4-wnM3-9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1haw_v4KEWwXPg4-wnM3-9w</a>  密码:njpq<br>05 Web进阶：<br>链接:<a href="https://pan.baidu.com/s/1dAMOUJzqrMfX0Eg91k8m3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1dAMOUJzqrMfX0Eg91k8m3g</a>  密码:9w0s<br>06 Web项目实战：<br>链接:<a href="https://pan.baidu.com/s/1J-o7w-l_UT5InxM81raDkA" target="_blank" rel="noopener">https://pan.baidu.com/s/1J-o7w-l_UT5InxM81raDkA</a>  密码:ekn5<br>07 Java框架阶段：<br>链接:<a href="https://pan.baidu.com/s/104vUkuyV4VQz_G9ExraJuQ" target="_blank" rel="noopener">https://pan.baidu.com/s/104vUkuyV4VQz_G9ExraJuQ</a>  密码:2jqq<br>08 互联网分布式技术：<br>链接:<a href="https://pan.baidu.com/s/1cv8dng3Ht0p6LQmLFbvVwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1cv8dng3Ht0p6LQmLFbvVwg</a>  密码:6t3d<br>09 项目实战：<br>链接:<a href="https://pan.baidu.com/s/1UNfGhadLOrAmdsmePaO7Dw" target="_blank" rel="noopener">https://pan.baidu.com/s/1UNfGhadLOrAmdsmePaO7Dw</a>  密码:gplw<br>10 Java开发工具：<br>链接：<a href="https://pan.baidu.com/s/10bKNbe0Jx6wF1jx9TMhqZA" target="_blank" rel="noopener">https://pan.baidu.com/s/10bKNbe0Jx6wF1jx9TMhqZA</a> 提取码：krpc</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>tf报错TypeError Value passed to parameter  indices has DataType float32 not in list of allowed values uint8, int32, int64</title>
    <url>/2021/10/31/%7Ftf%E6%8A%A5%E9%94%99TypeError%20Value%20passed%20to%20parameter%20%20indices%20has%20DataType%20float32%20not%20in%20list%20of%20allowed%20values%20uint8,%20int32,%20int64/</url>
    <content><![CDATA[<p>完整报错信息：</p>
<p>TypeError: Value passed to parameter ‘indices’ has DataType float32 not in list of allowed values: uint8, int32, int64</p>
<p>参考一些博客后，应该是这里的 indices 在uint8, int32, int64这几种类型的，但是被定义成了 float32  </p>
<p>之前的代码是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = tf.one_hot(y, depth=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">	    print(sess.run(y))</span><br></pre></td></tr></table></figure>

<p>之后的代码是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    y = tf.one_hot(y.eval(), depth=<span class="number">10</span>)</span><br><span class="line">    print(sess.run(y))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>如何查看tensor</title>
    <url>/2021/10/31/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Btensor/</url>
    <content><![CDATA[<p>原文地址：<a href="https://blog.csdn.net/Sunflower_ke/article/details/98500056?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163564494216780271570973%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163564494216780271570973&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-98500056.pc_search_result_control_group&amp;utm_term=%E6%9F%A5%E7%9C%8Btensor&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/Sunflower_ke/article/details/98500056?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163564494216780271570973%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163564494216780271570973&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-98500056.pc_search_result_control_group&amp;utm_term=%E6%9F%A5%E7%9C%8Btensor&amp;spm=1018.2226.3001.4187</a></p>
<p>如果只是使用Python的print语句输出tensor的话，只能输出tensor的一些shape信息，不能直接显示tensor的值。</p>
<p>解决办法1：在会话中print(sess.run(x))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"># 定义tensor常量</span><br><span class="line">x &#x3D; tf.random_uniform((2, 3), -1, 1)</span><br><span class="line"> </span><br><span class="line">#开启会话</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    print (sess.run(x))</span><br></pre></td></tr></table></figure>

<p>解决办法2： 使用.eval()相当于将tensor类数据转为numpy，再输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">#定义tensor常量</span><br><span class="line">x &#x3D; tf.random_uniform((2, 2), -1, 1)</span><br><span class="line">#开启会话</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	print (x.eval())</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>插值拟合</title>
    <url>/2021/08/26/%E6%8F%92%E5%80%BC%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h1 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h1><h2 id="一，概述"><a href="#一，概述" class="headerlink" title="一，概述"></a>一，概述</h2><p>  我们经常会遇到大量的<strong>数据需要处理</strong>，而处理数据的关键就在于这些算法。<strong>插值与拟合属于数值分析中函数逼近的内容。</strong><br>        在数学建模竞赛中，插值与拟合是一种常用的数据分析手段，被公认为建模中的十大算法之一。数据拟合、参数估计、插值等数据处理算法等问题在MATLAB中有很多现成的函数可以调用，熟悉MATLAB，这些方法都能游刃有余地用好。<br>         数据拟合在很多赛题中有应用，与<strong>图形处理有关的问题很多与插值和拟合有关系</strong>，例如98年美国赛A题，生物组织切片的三维插值处理，94年A题逢山开路，山体海拔高度的插值计算，2003年的“非典”问题也要用到数据拟合算法，观察数据的走向进行处理， 2005年的雨量预报的评价的插值计算。2001年的公交车调度拟合问题，2003年的饮酒驾车拟合问题。</p>
<h2 id="二，引例"><a href="#二，引例" class="headerlink" title="二，引例"></a>二，引例</h2><p>​    矿井中某处的瓦斯浓度 y 与该处距地面的距离 x 有关，用仪器测得从地面到井下距离 x 有关，现用仪器测得从地面到井下500米每隔50米的瓦斯浓度数据（x<sub>i</sub>,y<sub>i</sub>）,(i = 0,1,2,3……10 )，根据这些数据完成下列工作：</p>
<p>​    1️⃣：寻找一个函数，要求由此函数可以近似求得从地面到井下500米之间任一点瓦斯浓度。<br>​    可归结为“已知函数在x<sub>i</sub>x<sub>n</sub>处的值，求在函数在区间[x<sub>i</sub>,x<sub>n</sub>] 内其他点处的值，适宜用插值方法解决。</p>
<p>​    2️⃣：估计井下600米处的瓦斯浓度。<br>​        不适宜用插值方法解决，600米超过所给数据范围，用插值函数外的数据会产生较大误差。<br>​        解决方法：根据已有数据求出瓦斯浓度与井下距离500米之间近似函数关系 f（x），由 f（x）求600米处的瓦斯浓度。</p>
<p><strong>插值&amp;拟合：</strong>函数要求过已知点，拟合函数不一定过已知点。通常，插值主要求函数值，而拟合主要求函数关系。</p>
<h2 id="三，基本概念"><a href="#三，基本概念" class="headerlink" title="三，基本概念"></a>三，基本概念</h2><p>​    在实际中，常常要处理由实验或测量所得到的一些离散数据。<strong>插值与拟合方法</strong>就是要通过这些数据去<strong>确定某一类已知函数的参数或寻求某个近似函数</strong>，使所得到的近似函数与已知数据有较高的拟合精度。<br>​    如果<strong>要求</strong>这个近似函数（曲线或曲面）<strong>经过所已知的所有数据点</strong>，则称此类问题为<strong>插值问题</strong>。（不需要函数表达式）；<br>​    如果<strong>不要求</strong>近似函数<strong>通过所有数据点</strong>，而是要求它能较好地反映数据变化规律的近似函数的方法称为<strong>数据拟合</strong>。（必须有函数表达式）近似函数不一定（曲线或曲面）通过所有的数据点；</p>
<h2 id="四，插值与拟合的区别和联系"><a href="#四，插值与拟合的区别和联系" class="headerlink" title="四，插值与拟合的区别和联系"></a>四，插值与拟合的区别和联系</h2><p><strong>Ⅰ，联系</strong><br>    都是根据实际中一组已知数据来构造一个能够反映数据变化规律的近似函数的方法。</p>
<p><strong>Ⅱ，区别</strong><br>    <strong>插值问题不一定得到近似函数的表达形式</strong>，仅通过插值方法找到未知点对应的值。<strong>数据拟合要求得到一个具体的近似函数的表达式。</strong> </p>
<h2 id="五，插值的使用及求解"><a href="#五，插值的使用及求解" class="headerlink" title="五，插值的使用及求解"></a>五，插值的使用及求解</h2><h3 id="5-1引言"><a href="#5-1引言" class="headerlink" title="5.1引言"></a>5.1引言</h3><p>​    当<strong>数据量不够，需要补充</strong>，且认定已有数据可信时,  通常<strong>利用函数插值方法</strong>。</p>
<p>​    实际问题当中碰到的函数 f (x) 是各种各样的，有的表达式很复杂，有的甚至给不出数学的式子，只提供了一些离散数据，譬如，某些点上的函数值和导数值。</p>
<h3 id="5-2插值方法"><a href="#5-2插值方法" class="headerlink" title="5.2插值方法"></a>5.2插值方法</h3><p>选用不同类型的插值函数，逼近的效果就不同，一般有：<br><strong>（1）</strong>拉格朗日插值（Lagrange插值）<br><strong>（2）</strong>分段线性插值<br><strong>（3）</strong>Hermite<br><strong>（4）</strong>三次样条插值。</p>
<h3 id="5-3Matlab实现插值"><a href="#5-3Matlab实现插值" class="headerlink" title="5.3Matlab实现插值"></a>5.3Matlab实现插值</h3><p>Matlab 实现：实现分段线性插值<strong>不需要编制函数程序</strong>，它自身提供了内部的功能函数<br>interp1(一维插值)<br>interp2(二维)<br>interp3(三维)<br>interpn(n维) </p>
<h3 id="5-4插值定义"><a href="#5-4插值定义" class="headerlink" title="5.4插值定义"></a>5.4插值定义</h3><p>当函数 <strong>y = f(x)</strong>非常复杂或未知时，在区间[a, b]上一系列节点x<sub>0</sub>, …, x<sub>n</sub>处测得对应的函数值分别为y0 , …, yn ，由此构造一个简单易算的函数 p(x) ，满足条件p(x<sub>i</sub>) = y<sub>i</sub>   (i = 0, …, n) ；此时 p(x) ≈ f(x) ，这个问题就称为“<strong>插值问题</strong>”。这里 p(x) 称为f(x) 的插值函数，节点 x0 ,…, xn称为插值节点，区间[a, b]称为插值区间， <strong>f(x)称为被插函数</strong></p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/06/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程：<br>    进程：正在运行的程序，是系统进行资源分配和调度的独立单位，每一个进程都有自己的内存空间和系统资源<br>    线程：在进程中的单个顺序控制流，是一条执行路径<br>        单线程：一个进程如果只有一条执行路径，则称为单线程程序<br>        多线程：一个进程有多个执行路径，则称为多线程程序</p>
<p>线程调度的两种方式：<br>    分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间<br>    抢占式调度：优先让优先级高的线程使用CPU，如果线程优先级相同，那么会随机选择一个，优先级高的线程获取CPU时间片相对较多。</p>
<p>Java使用的是抢占式调度模型</p>
<p>随机性：<br>    假如计算机只有一个CPU，那么CPU只能在一个时刻只能执行一条命令，线程只有得到CPU的时间片，也就是使用权才能执行命令。<br>    所以多线程程序的执行是有随机性的</p>
<p>final int getPriority()：返回线程的优先级<br>final void setPriority(int newPriority)：更改线程的优先级，线程优先级默认为5，优先级范围是：1-10</p>
<p>线程控制：<br>    static void sleep(long millis)：是当前正在执行的线程停留（暂停执行），指定的毫秒数<br>    void join()：等待这个线程死亡<br>    void setDaemon(boolean on) 将线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</p>
<p>实现多线程的方式：<br>    继承Thread类或者实现Runnable接口<br>    相比继承Thread类，实现Runnable接口的好处：<br>        避免了Java的单继承的局限性<br>        适合多个相同程序的代码，去处理同一个资源的情况，把线程和程序的代码，数据有效分离，体现面向对象思想</p>
<p>同步代码块解决数据安全问题：<br>    出现条件：在多线程环境下，有个共享数据，多条语句操作共享数据<br>    如何解决：让程序没有安全问题的环境<br>    如何实现：把多条语句操作数据的代码给锁起来，让任何时刻只能有一个线程执行就行了</p>
<pre><code>同步代码块：   
    synchronized(任意对象){
        多条语句操作工具数据的代码
    }
    synchronized(任意对象)：相当于给代码加锁，任意对象就可以看做为一把锁
    好处和弊端：
        解决多线程的数据安全问题
        当线程很多的时候，因为每个线程都会去判断同步上的锁，这就很耗费资源，无形中降低程序的运行效率</code></pre><p>线程安全的类：</p>
<pre><code>StringBuffer:
    线程安全，可变的字符串序列，从JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为执行不同步。
Vector：
    该类改进了List接口。与新的集合实现不同，Vector被同步。如果不需要线程安全实现，建议使用ArrayList代替Vector
Hashtable:
    该类实现哈希表，将键映射到值，任何非null对象都可以作为键或者值，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashable</code></pre><p>生产者消费者模式：<br>    待理解</p>
<p>Thread.sleep():<br>    是Thread类的一个静态方法，使当前线程休眠，进入阻塞状态（暂停执行），如果线程在睡眠状态被中断，将会抛出IterruptedException中断异常。</p>
<p>代码练习：<br>public class SellTicketDemo {<br>    public static void main(String[] args) {<br>        //创建SellTicket类对象<br>        SellTicket st = new SellTicket();</p>
<pre><code>    //创建三个Thread类对象，把SelllTicket对象作为构造方法的参数，并给对应窗口进行命名
    Thread thread1 = new Thread(st,&quot;窗口1&quot;);
    Thread thread2 = new Thread(st,&quot;窗口2&quot;);
    Thread thread3 = new Thread(st,&quot;窗口3&quot;);

    thread1.start();
    thread2.start();
    thread3.start();
   /*
   出现问题：
        相同的票出现多次
        出现负数票
    出现原因：
        线程执行的随机性导致
    */

}</code></pre><p>}</p>
<p>public class SellTicket implements Runnable{<br>    private int tickets = 100;</p>
<pre><code>@Override
public void run() {
    while (true){
        if(tickets&gt;0){
            System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;张票&quot;);
            tickets--;
        }
    }
}</code></pre><p>}</p>
<p>public class priorityDemo {<br>    public static void main(String[] args) {<br>        MyThread myThread =new MyThread();<br>        MyThread myThread1 =new MyThread();<br>        MyThread myThread2 =new MyThread();<br>        MyThread myThread3 =new MyThread();<br>        MyThread myThread4 =new MyThread();<br>        MyThread myThread5 =new MyThread();<br>        MyThread myThread6 =new MyThread();<br>        myThread.setName(“my”);<br>        myThread1.setName(“my1”);<br>        myThread2.setName(“my2”);<br>        myThread3.setName(“my3”);<br>        myThread4.setName(“my4”);<br>        myThread5.setName(“my5”);<br>        myThread6.setName(“my6”);<br>        //其他的线程默认为5<br>        myThread6.setPriority(10);//进程my6是最高的<br>        myThread1.setPriority(1);//进程my是优先级最小的<br>       //测试<br>        myThread.start();<br>        myThread1.start();<br>        myThread2.start();<br>        myThread3.start();<br>        myThread4.start();<br>        myThread5.start();<br>        myThread6.start();</p>
<pre><code>}</code></pre><p>}</p>
<p>public class MyThreadTest {<br>    public static void main(String[] args) {<br>        MyThread my1 = new MyThread();<br>        MyThread my2 = new MyThread();<br>        my1.setName(“my1”);<br>        my2.setName(“my2”);<br>        my1.start();<br>        my2.start();<br>        String my1Name = my1.getName();<br>        String my2Name = my2.getName();<br>        System.out.println(“my1name:”+my1Name);<br>        System.out.println(“my2name:”+my2Name);<br>    }<br>}</p>
<p>public class MyThread extends Thread{<br>    @Override<br>    public void run(){<br>        for(int i = 0; i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>        System.out.println(this.getName());<br>    }</p>
<p>}</p>
]]></content>
  </entry>
  <entry>
    <title>学习资源链接</title>
    <url>/2021/05/04/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="MySQL系列学习目录："><a href="#MySQL系列学习目录：" class="headerlink" title="MySQL系列学习目录："></a>MySQL系列学习目录：</h2><h3 id="MYSQL文章学习："><a href="#MYSQL文章学习：" class="headerlink" title="MYSQL文章学习："></a>MYSQL文章学习：</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933257&idx=1&sn=0f0086a2465a2fcae13d3fea65064803&chksm=88621bb7bf1592a1ac94fe4107ba1ef26a0fa97e1bf9aea7279009d8bd240f1ef7d27aa10393&token=1876080189&lang=zh_CN#rd" target="_blank" rel="noopener">第一篇:MySQL基础</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933270&idx=1&sn=409080e17352da2035b0bfdf63ccdfde&chksm=88621ba8bf1592beb2ef6106d6bf9f3eccd48d6814c7031f36e3c8be68821f17cf065129688c&token=1876080189&lang=zh_CN#rd" target="_blank" rel="noopener">第二篇:详解MySQL数据类型</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933279&idx=1&sn=f8591b95362cb3c352d895b1289d665a&chksm=88621ba1bf1592b72a43a62e3f310695e8b87f17932d052145622c3edbb70ef8cb987849fc3e&token=516655478&lang=zh_CN#rd" target="_blank" rel="noopener">第三篇:管理员必备技能（必须掌握）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933289&idx=1&sn=c4f212c312ea86e08ad322caddd05e38&chksm=88621b97bf159281156ee3be510a1a15234531d2c97d66957e67377829ab23779809ea55bbde&token=1484565200&lang=zh_CN#rd" target="_blank" rel="noopener">第四篇:DDL常见操作</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933296&idx=1&sn=1c56256d60c5847a944d87c8cfc9c14d&chksm=88621b8ebf159298b0789e2994d2aaf8b582effc7d8c1ba715deaca11c86a9dc8ac730878dc0&token=2000571846&lang=zh_CN#rd" target="_blank" rel="noopener">第五篇:DML操作汇总（insert，update，delete）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933300&idx=1&sn=bedef4d430dc76141e42e42ef6acfaa6&chksm=88621b8abf15929caae7904019c946a396885a33855ca465bacdd4187538005ebc3c116888f5&token=1814800041&lang=zh_CN#rd" target="_blank" rel="noopener">第六篇:select查询基础篇</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933305&idx=1&sn=2c5ba0bea6fcdd57d86cecd63541f91a&chksm=88621b87bf1592915086c1e945119fcc95af6aa1127b90ef1b56b018083bfd787ad95efde918&token=1144227002&lang=zh_CN#rd" target="_blank" rel="noopener">第七篇:玩转select条件查询，避免采坑</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933309&idx=1&sn=0f7dfec8bc70e67daa7159ee219325b8&chksm=88621b83bf1592951d949179061f39a1f4266b2879bc9a25af4da3b4b29f69ab1fcc595a462f&token=516674265&lang=zh_CN#rd" target="_blank" rel="noopener">第八篇:详解排序和分页(order by &amp; limit)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933315&idx=1&sn=4abf2b34a53a85cbd4a3b9ee31fcd398&chksm=88621bfdbf1592eb6a5a13202588dde9068ac7e6391d8dbf3fde33647bf0e044839ba4228216&token=1937580929&lang=zh_CN#rd" target="_blank" rel="noopener">第九篇:分组查询详解(group by &amp; having)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933321&idx=1&sn=110f6cacb90845bf2327fbcd7acd708c&chksm=88621bf7bf1592e1f1c0f2f01e40d4bd63a48d98daa4ba1157ecad4c6c6520d18b4b2c24c906&token=1096041061&lang=zh_CN#rd" target="_blank" rel="noopener">第十篇:常用的几十个函数详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933325&idx=1&sn=33274227db275a3570e1e43ccdd4f49c&chksm=88621bf3bf1592e5b75f537e21961c4295fafb782dbf31c0c1cbf9e36f5f4ed44d31cdad68b3&token=1832579722&lang=zh_CN#rd" target="_blank" rel="noopener">第十一篇:深入了解连接查询及原理</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933342&idx=2&sn=2e41daa0926a9c32d5fddd23590391aa&chksm=88621be0bf1592f66904a184858df7c11129e8b545c7626b8b6c1fcc32d3dfdd9ab21aeda8e5&token=386795745&lang=zh_CN#rd" target="_blank" rel="noopener">第十二篇:子查询</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933349&idx=1&sn=6e81f9046119cda43f8eb602d1139ef0&chksm=88621bdbbf1592cd9a20ec4715fe9f9459d079b641b04f607999c106cd52453d8c8508d939d7&token=386795745&lang=zh_CN#rd" target="_blank" rel="noopener">第十三篇:细说NULL导致的神坑，让人防不胜防</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933355&idx=1&sn=b426ad28dfc2a64bba813df5b7c341a4&chksm=88621bd5bf1592c3c08e441398f699d0a4c2303a51519aac169447f22765cc613dfc3d991f8b&token=385335213&lang=zh_CN#rd" target="_blank" rel="noopener">第十四篇:详解事务</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933370&idx=1&sn=4fe9b8e2aba766988c503737d34d9836&chksm=88621bc4bf1592d2b06d659884bf9881bd207a042ac36176f12808bd72f235e8e3404366259e&token=84059034&lang=zh_CN#rd" target="_blank" rel="noopener">第十五篇:详解视图</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933374&idx=1&sn=c294b6a69564a4c98d4c0cb29aeb9ac0&chksm=88621bc0bf1592d650752c44ca50540c1fa0c88c0a514019f1317559e13098de7dac37ddfc05&token=1531009350&lang=zh_CN#rd" target="_blank" rel="noopener">第十六篇:变量详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933382&idx=1&sn=4cf80b4f50c80dcc8171d2128b47cf63&chksm=88621c38bf15952e193177a0ba3e03beeaeed996553ce6900f91518310332e99c915e8be2566&token=1341741305&lang=zh_CN#rd" target="_blank" rel="noopener">第十七篇:存储过程&amp;自定义函数详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933388&idx=1&sn=59cb1d23845e45894bb72c1e2479f074&chksm=88621c32bf1595241573e4194912ca60a51eb8477f4b49492e26668c9bebc032e9d6672e7fdd&token=1832749573&lang=zh_CN#rd" target="_blank" rel="noopener">第十八篇:流程控制语句</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933392&idx=1&sn=ff29e380b42a0aa7cb1dc7659d745686&chksm=88621c2ebf1595380f99d9c4c89581638a27a5cf356de35d31aa9ae7ac17e63abe0e4adc813c&token=1479782197&lang=zh_CN#rd" target="_blank" rel="noopener">第十九篇:游标详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933396&idx=1&sn=b6cc5d5287bf43d94e6706fa217aa8cb&chksm=88621c2abf15953c3200c6d4d945ad70bdd2177f020f8e2229ae269153bbc8bf251af83e1135&token=1846211483&lang=zh_CN#rd" target="_blank" rel="noopener">第二十篇:异常捕获及处理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933400&idx=1&sn=61af771f10342ee4956efea6749abd71&chksm=88621c26bf15953041a6bc65734edf788af711ff176ad36884fe6411e5c4cfd0bf967e0e33fc&token=1781447741&lang=zh_CN#rd" target="_blank" rel="noopener">第二十一篇:什么是索引?</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933422&idx=1&sn=f28a92c195d914d636117c2316524c5e&chksm=88621c10bf159506af8a3c6b947e32b11414ff72ed3ad19a9fa0b0cec0be6c3ae3931117b3d2&token=1928746279&lang=zh_CN#rd" target="_blank" rel="noopener">第二十二篇:mysql索引原理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933427&idx=1&sn=d9cb0317b50c76519291d2e4311b887f&chksm=88621c0dbf15951b1d4d37da57f88a7b026d2bb656234a738f8660be4c5750f82300c20be779&token=410060235&lang=zh_CN#rd" target="_blank" rel="noopener">第二十三篇:mysql索引管理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933439&idx=1&sn=a1eddd36a6f597b9cd43e39e9f1b9d76&chksm=88621c01bf1595175894d27c996a49c9305c59bf23250f165943f91fcf35076813cf832985f7&token=410060235&lang=zh_CN#rd" target="_blank" rel="noopener">第二十四篇:如何正确的使用索引?</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933444&idx=1&sn=2d0c3ca9ba1275aa9dceac367d7b21a9&chksm=88621c7abf15956c9fae6cb4e68663263979a9aef7bec617c235032b03bc874e2dab0ef28fe1&token=164798892&lang=zh_CN#rd" target="_blank" rel="noopener">第二十五篇:sql中where条件在数据库中提取与应用浅析</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933457&idx=1&sn=b1e9e38bdcc3e3cf5e67e040ab4a4f94&chksm=88621c6fbf1595793a369015b88df0332c6bfab43ff6a8b35423797beaacf0f9632132e353e4&token=164798892&lang=zh_CN#rd" target="_blank" rel="noopener">第二十六篇：聊聊mysql如何实现分布式锁?</a></p>
<h3 id="MYSQL视频学习："><a href="#MYSQL视频学习：" class="headerlink" title="MYSQL视频学习："></a>MYSQL视频学习：</h3><p><a href="https://www.bilibili.com/video/BV1Vt411z7wy" target="_blank" rel="noopener">b站MYSQL基础课</a></p>
<p><a href="https://www.bilibili.com/video/BV1hE411V7vu" target="_blank" rel="noopener">数据库关系代数</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ez411b7hb/?spm_id_from=333.788.recommend_more_video.-1" target="_blank" rel="noopener">关系代数操作哈工大</a></p>
<h2 id="机器学习相关资料"><a href="#机器学习相关资料" class="headerlink" title="机器学习相关资料:"></a>机器学习相关资料:</h2><h3 id="吴恩达机器学习系列课程"><a href="#吴恩达机器学习系列课程" class="headerlink" title="吴恩达机器学习系列课程"></a>吴恩达机器学习系列课程</h3><p><a href="http://www.ai-start.com/ml2014/" target="_blank" rel="noopener">斯坦福大学2014机器学习教程中文笔记目录在线阅读</a><br><a href="https://www.bilibili.com/video/BV164411b7dx" target="_blank" rel="noopener">视频地址(中文字幕版):</a><br><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">视频视频原地址(打开不流畅，建议b站观看):</a><br><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">吴恩达老师的机器学习课程个人笔记+资料+码源 github地址:</a></p>
<h3 id="学习网站："><a href="#学习网站：" class="headerlink" title="学习网站："></a>学习网站：</h3><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程（编程基础知识）</a></p>
<p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school（web技术教程）</a></p>
<p><a href="https://www.yiibai.com/" target="_blank" rel="noopener">易百教程</a></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>数学建模Lingo学习</title>
    <url>/2021/08/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Lingo%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>红色靶心运行程序</p>
<p>每一句语句以 “;‘’ 结尾</p>
<p>Lingo默认所有变量大于等于0，所以非负的条件不需要多写。</p>
<p>Lingo不区分大小写。</p>
<p>变量均由字母数字下划线组成，字母放首位。</p>
<p><strong>线性规划基础：</strong></p>
<p>​    一个线性规划只有一个目标函数（两个以上的多目标函数规划，Lingo无法求解）<br>​    求解目标函数的最大值或者最小值分别用max = …  或者  min…来表示。<br>​    注释：！开头，；结尾。<br>​    线性规划和非线性规划的本质区别是 ：目标函数是否是线性的，其余一致。<br>​    非线性规划的求解非常困难，基本上找不到全局最优解。</p>
<p>例题：<br>    某工厂有两条生产线，分别用来生产 M 和 P 两种型号的产品，利润分别为 200 元/个 和 300 元/个，生产线的最大生产能力分别为每日 100 和 120，生产线每生产一个 M 产品需要 1 个劳动日（1 个工人工作 8 小时称为 1 个劳动日）进行调试、检测等工作，而每个 P 产 品需要 2 个劳动日，该厂工人每天共计能提供 160 劳动日，假如原材料等其他条件不受限制，问应如何安排生产计划，才能使获得的利润最大？ </p>
<p>​    求解：</p>
<p>​        目标函数：max z = 200x1 +300x2<br>​        约束条件：x1&lt;=100 ; x2&lt;=120; x1+2*x2&lt;=160;  x1&gt;=0,i=1,2;<br>​    代码：<br>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max &#x3D; 200*x1 + 300*x2; </span><br><span class="line">x1 &lt;&#x3D; 100; </span><br><span class="line">x2 &lt;&#x3D; 120; </span><br><span class="line">x1 + 2*x2 &lt;&#x3D; 160;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>集合和矩阵工厂：</strong></p>
<p>​    矩阵工厂：生产一维矩阵</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set:</span><br><span class="line">factory &#x2F;1..6&#x2F; : a,b;!a和b没有联系，都是一行六列的矩阵;</span><br><span class="line">plant &#x2F;1..3&#x2F; : x,y;</span><br></pre></td></tr></table></figure>

<p>程序知识点：</p>
<p>以上程序对应知识点： </p>
<p>① factory 和 plant 都是制造矩阵的工厂，但它们是两家不同的工厂。<br>② factory 工厂后面的 /1..6/ 说明它专门生产 1 x 6 的矩阵。<br>    factory 工厂最后面出现的 <em>a</em> 和 <em>b</em>，都是 1 x 6 的矩阵。<br>③ plant 工厂后面的 /1..3/ 说明它专门生产 1 x 3 的矩阵。<br>    plant 工厂最后面出现的 <em>x</em> 和 <em>y</em>，都是 1 x 3 的矩阵。<br>④ 矩阵工厂的名字 factory 是随便起的，工厂所生产行矩阵的名字 <em>a</em> 和 <em>b</em> 也是随便起的。<br>⑤ 以上这四句话，本质是定义了四个行矩阵的大小，矩阵工厂只是中介。<br>⑥ 生产完矩阵后，工厂和矩阵之间将脱开联系。<br>⑦ Lingo 不是一行一行读代码的，所以用 sets: 和 endsets 表示矩阵工厂生产流程的起止。 </p>
<p><strong>矩阵的赋值</strong></p>
<p>矩阵不能只生产矩阵，还要给矩阵赋初值。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sets:</span><br><span class="line">factory &#x2F;1..6&#x2F; : a,b;</span><br><span class="line">plant &#x2F;1..3&#x2F; : c,x;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:</span><br><span class="line">a &#x3D; 1, 2, 3, 4, 5, 6;</span><br><span class="line">b &#x3D; 6.0, 5.0, 4.0, 3.0, 2.0, 1.0;</span><br><span class="line">c &#x3D; 10, 20, 30;</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure>

<p>① 不是每个矩阵都要赋值，有些矩阵正是我们要求解的变量。<br>② 需要赋值的矩阵必须赋满，不能给 6 个元素的矩阵只赋 3 个数值。<br>③ Lingo 中可以给矩阵赋整数，也可以赋小数。<br>④ Lingo 不是一行一行读代码的，所以用 data:和 enddata 表示矩阵赋值的起止。</p>
<p><strong>循环和求和</strong></p>
<p>循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@for( gc(i) : a(i)*x(i) &#x3D; S );! gc表示矩阵工厂，a，x分别是矩阵。</span><br></pre></td></tr></table></figure>

<p>① for 循环，括起整行语句，因为 S = a <sub>i</sub>  x<sub>i</sub> ，i = 1,2,3,4,5 相当于是五个约束条件。<br>② for 循环内部，先写工厂，以告诉 for 循环几次，之后再上接约束条件。<br>③ 此处的 <em>i</em> 可带可不带，甚至可以换成 <em>j</em>、<em>k</em> 或 <em>m</em> 等等。<br>④ 二维矩阵工厂出现后，同时会出现 <em>i</em> 和 <em>j</em>，那时必须带 <em>i</em> 和 <em>j</em>。</p>
<p>求和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@sum( gc(i) : x(i) ) &#x3D; 5000;</span><br></pre></td></tr></table></figure>

<p>① sum 求和，不可以括起完整的约束条件，因为一般的求和的结构是这样的：<br>                                                        x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> + x<sub>4</sub> + x<sub>5</sub> = 5000</p>
<p>② sum 求和内部，先写工厂，以告诉 sum 求和几次，之后再上接约束条件。<br>③ 此处的 <em>i</em> 可带可不带。<br>④ 二维矩阵工厂出现后，同时会出现 <em>i</em> 和 <em>j</em>，那时必须带。</p>
<p><strong>for 和 sum 出现的标志</strong></p>
<p>① 约束条件后面有 <em>i</em> =1,2, ,5 ，一定在最外层套上 for。<br>② 约束条件前面是 ∑ 标志 ，一定在中间加上 sum。</p>
<p>例题：<br>    max S；约束条件：S = ai*xi，i从1到5，x1 + x2 + x3 + x4 + sx5 = 5000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">gc &#x2F;1..5&#x2F; : a,x;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">a &#x3D; 1,2,3,4,5;</span><br><span class="line">enddata</span><br><span class="line">max &#x3D; S;</span><br><span class="line">@for( gc(i) : a(i)*x(i) &#x3D; S );</span><br><span class="line">@sum( gc(i) : x(i) ) &#x3D; 5000;</span><br><span class="line">end</span><br><span class="line">!使用矩阵工厂创建矩阵后，整个程序需要 model: 和 ; 包起来。</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>工厂合并：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sets:</span><br><span class="line">factory &#x2F;1..6&#x2F; : a;</span><br><span class="line">plant &#x2F;1..8&#x2F; d;</span><br><span class="line">Cooperation(factory,plant) : c,x;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure>

<p>以上程序可以得到以下结论： </p>
<p>① Cooperation 大工厂是由 factory 和 plant 两家小工厂合并而办，可生产 6x8 的矩阵。<br>② <em>a</em> 是 1 x 6的矩阵，<em>d</em> 是 1 x 8 的矩阵，<em>c</em> 和 <em>x</em> 都是 6 x 8 的矩阵。<br>③ 如果将 Cooperation(factory,plant)中的 factory 与 plant 调换位置，则生产 8 x 6 的矩阵。<br>④ 工厂合并的名字 Cooperation 是随便起的，矩阵的名字 <em>c</em> 和 <em>x</em> 也是随便起的。</p>
<p><strong>算术运算符</strong></p>
<p>加减乘数：+，-，*，/<br>关系运算符：等于=，大于等于&gt;=，小于等于&lt;=。</p>
<p>tips:没有单独的“&lt;”和“&gt;”，如果出现，则视为小于等于和大于等于。<br>实现严格等于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B &#x3D; 10;</span><br><span class="line">e &#x3D; 0.0001;</span><br><span class="line">A - e &gt; B;</span><br></pre></td></tr></table></figure>

<p>逻辑运算符：</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th>运算符</th>
<th>理解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">两个数字之间</td>
<td>#eq#</td>
<td>equal</td>
<td>两个运算对象为真</td>
</tr>
<tr>
<td align="center">两个数字之间</td>
<td>#ne#</td>
<td>not equal</td>
<td>两个运算对象不相等为真</td>
</tr>
<tr>
<td align="center">两个数字之间</td>
<td>#gt#</td>
<td>greater than</td>
<td>左边大于右为真</td>
</tr>
<tr>
<td align="center">两个数字之间</td>
<td>#ge#</td>
<td>greater equal</td>
<td>左边大于等于右边为真</td>
</tr>
<tr>
<td align="center">两个数字之间</td>
<td>#lt#</td>
<td>less than</td>
<td>左边小于右边为真</td>
</tr>
<tr>
<td align="center">两个数字之间</td>
<td>#le#</td>
<td>less equal</td>
<td>左边小于等于右边为真</td>
</tr>
<tr>
<td align="center">两个逻辑表达式</td>
<td>#not#</td>
<td>非门</td>
<td>单目运算符，表示取反</td>
</tr>
<tr>
<td align="center">两个逻辑表达式</td>
<td>#and#</td>
<td>与门</td>
<td>左右两边均为正确为真</td>
</tr>
<tr>
<td align="center">两个逻辑表达式</td>
<td>#or#</td>
<td>或门</td>
<td>左右两边均为错误为真</td>
</tr>
</tbody></table>
<p>tips：逻辑运算符唯一出现的位置：<br>1）：for循环与sum求和。<br>2）：if判断中。</p>
<p>例题：若矩阵 <em>a</em> =[6，5，4，3，2，1]，用集合的语言求解a(5)+a(6)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">factory &#x2F; 1..6 &#x2F; : a;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">a &#x3D; 6,5,4,3,2,1;</span><br><span class="line">enddata</span><br><span class="line">y &#x3D; @sum( factory(i) | i#ge#5 : a(i) );</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>若矩阵 <em>a</em> 由六个元素组成，且a(i)&gt;5,i=1,2,5,6 。求矩阵 <em>a</em> 各元素求和的最小值。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">factory &#x2F; 1..6 &#x2F; : a;</span><br><span class="line">endsets</span><br><span class="line">min &#x3D; @sum(factory : a);</span><br><span class="line">@for( factory(i) | i#lt#3 #or# i#ge#5 : a(i) &gt; 5 );</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p><strong>Lingo内置函数</strong></p>
<p>@if():</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 1500; ! 给 x 一个随机的初值</span><br><span class="line">!表达函数为：当0&lt;&#x3D;x&lt;&#x3D;500,y&#x3D;4x。当500&lt;&#x3D;x&lt;&#x3D;1000,y&#x3D;500+3x。当x&gt;1000,y&#x3D;1500+2x;</span><br><span class="line">y &#x3D; @if( x#le#500 , 4*x , @if( x#gt#1000 , 1500+2*x , 500+3*x ));</span><br></pre></td></tr></table></figure>

<p>tips: if函数通常仅存在分段函数处，出现频率非常低；Lingo中的if函数，必须自带一个else。</p>
<p><strong>变量定界函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@bin(x)</td>
<td>限制 <em>x</em> 只能取 0 或 1,0,0-1规划特别有用</td>
</tr>
<tr>
<td>@gin(<em>x</em>)</td>
<td>限制 <em>x</em> 为整数，在整数规划中特别有用</td>
</tr>
<tr>
<td>@bnd(a,x,b)</td>
<td>限制 <em>a &lt;=x&lt;= b</em> 推荐直接替换两个约束条件</td>
</tr>
<tr>
<td>@free(<em>x</em>)</td>
<td>取消对变量 <em>x</em> 非负的限制，使其定义域自由</td>
</tr>
</tbody></table>
<p><strong>数学函数</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>函数名</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>三角函数</td>
<td>@sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>三角函数</td>
<td>@cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>三角函数</td>
<td>@tan(x)</td>
<td>返回x的正切值</td>
</tr>
<tr>
<td>指数函数</td>
<td>@log(x)</td>
<td>返回x的自然对数值，其他底数用换底公式</td>
</tr>
<tr>
<td>指数函数</td>
<td>@exp(x)</td>
<td>返回e<sup>x</sup>的值</td>
</tr>
<tr>
<td>其他</td>
<td>@abs(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>其他</td>
<td>@sigh(x)</td>
<td>返回x的符号值，x&gt;=0为1，x&lt;0为-1</td>
</tr>
<tr>
<td>其他</td>
<td>@floor(x)</td>
<td>返回x的整数部分，向靠近0的方向取整</td>
</tr>
<tr>
<td>比较大小</td>
<td>@smax(x)</td>
<td>返回其中的最大值</td>
</tr>
<tr>
<td>比较大小</td>
<td>@smin(x)</td>
<td>返回其中的最小值</td>
</tr>
</tbody></table>
<p><strong>集合操作函数</strong></p>
<p>设factory工厂生产6个元素的矩阵：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@for(factory:a&gt;0)</td>
<td>循环</td>
</tr>
<tr>
<td>@sum( factory : a )</td>
<td>求和</td>
</tr>
<tr>
<td>@prod( factory : a )</td>
<td>求积</td>
</tr>
<tr>
<td>@max( factory : a )</td>
<td>求最大值</td>
</tr>
<tr>
<td>@min( factory : a )</td>
<td>求最小值</td>
</tr>
<tr>
<td>@in( factory , c )</td>
<td>判断常数c是否在集合中</td>
</tr>
<tr>
<td>@size( factory )</td>
<td>返回工厂可生产矩阵的长度</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>软件建模工具</tag>
      </tags>
  </entry>
  <entry>
    <title>学习记录</title>
    <url>/2021/05/13/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>2021-5-25<br>idea启动tomcat，8080端口被占，已解决<br><a href="https://blog.csdn.net/qq_33198758/article/details/82924561?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">https://blog.csdn.net/qq_33198758/article/details/82924561?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
<p>tomcat启动项目报错：<br>    查看tomcat日志： C:\Users\（用户名）.IntelliJIdea2017.3\system\tomcat  </p>
<pre><code>错误信息：Error during artifact deployment. See server log for details.
    解决办法：https://blog.csdn.net/qq_39095899/article/details/106604228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162192913216780255278525%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162192913216780255278525&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-7-106604228.first_rank_v2_pc_rank_v29&amp;utm_term=Error+during+artifact+deployment.+See+server+log+for+details.&amp;spm=1018.2226.3001.4187</code></pre><p>【cmd命令】‘netstat’不是内部命令：<br><a href="https://blog.csdn.net/m18633778874/article/details/80441536?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162280993916780264039009%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162280993916780264039009&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80441536.first_rank_v2_pc_rank_v29&amp;utm_term=netstat%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/m18633778874/article/details/80441536?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162280993916780264039009%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162280993916780264039009&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80441536.first_rank_v2_pc_rank_v29&amp;utm_term=netstat%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187</a></p>
<p>UTF-8的BOM：<br>    <a href="https://blog.csdn.net/qq_38929030/article/details/73920996?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs" target="_blank" rel="noopener">https://blog.csdn.net/qq_38929030/article/details/73920996?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs</a></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>数据库零碎知识点</title>
    <url>/2021/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p> 一些最重要的 SQL 命令</p>
<ul>
<li><p><strong>SELECT</strong> - 从数据库中提取数据</p>
</li>
<li><p><strong>UPDATE</strong> - 更新数据库中的数据</p>
</li>
<li><p><strong>DELETE</strong> - 从数据库中删除数据</p>
</li>
<li><p><strong>INSERT INTO</strong> - 向数据库中插入新数据</p>
</li>
<li><p><strong>CREATE DATABASE</strong> - 创建新数据库</p>
</li>
<li><p><strong>ALTER DATABASE</strong> - 修改数据库</p>
</li>
<li><p><strong>CREATE TABLE</strong> - 创建新表</p>
</li>
<li><p><strong>ALTER TABLE</strong> - 变更（改变）数据库表</p>
</li>
<li><p><strong>DROP TABLE</strong> - 删除表</p>
</li>
<li><p><strong>CREATE INDEX</strong> - 创建索引（搜索键）</p>
</li>
<li><p><strong>DROP INDEX</strong> - 删除索引</p>
<p>SELECT DISTINCT：<br>选取出来列中唯一不同的值（重复的值出现一次）</p>
</li>
</ul>
<a id="more"></a>

<p>SQL的四种连接查询：<br>    内连接（内联查询，就是两张表中的数据，通过某个字段相对，查询出相关记录数据）</p>
<p>​        inner join 或者 join      （后加on表示条件）</p>
<p>​        例如：select * from person inner join card on person.cardId=card.id;</p>
<p>​    外连接</p>
<p>​        1.左连接 left join 或者 left outer join  (会把左边表里的数据全部取出来，而右边表的数据，如果有的话，显示出来，没有的话，就会补NULL。)</p>
<p>​        2.右连接 right join 或者 right outer join (和左外连接相似)</p>
<p>​        3.完全外连接 full join 或者 full outer join (mysql  不支持full join)</p>
<p>只能通过左右外连接，然后union起来，例如：<br>select * from person left join card on person.cardId=card.id</p>
<p>union</p>
<p>select * from person right join card on person.cardId=card.id</p>
<p>​        </p>
<p>unique约束，可以为空，但为空只能有一个，</p>
<p>视图：</p>
<p>​    虚表，是从一个或多个</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习实训：手写体数字识别</title>
    <url>/2021/10/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%AE%AD%EF%BC%9A%E6%89%8B%E5%86%99%E4%BD%93%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>资料搜集：</p>
<p>​    可使用MNIST数据集中的60000个自带样本进行深度学习模型训练，再利用另外的10000个样本进行模型精确度验证。<br>得到数字识别模型的参数，运用到用户真实手写数字的情景中去。</p>
<p>需要运用的技术，知识点：TensorFlow，深度学习，机器学习，卷积，非线性分类函数softmax，CNN。</p>
<p>神经网络进行多任务分类，使用softmax来实现的话，有几个分类，最后一层（输出层）就具有几个神经元。每个神经元表示属于特定类别的概率。最终的分类，就是概率值最大的那一个。</p>
<p>DBRHD数据集获取：</p>
<p>大概步骤：</p>
<p>安装tensorflow<br>    Anaconda prompt命令行敲入：pip install tensorflow </p>
<p>下载MINST和DBRHD图片数据集<br>    TensorFlow自带MINST数据，网络问题可能出现下载数据失败。</p>
<p>训练集和验证集的数字标签 0-10 都用one_hot编码表示</p>
<p>每一个图片是28x28的矩阵灰度图，把图像进行横向拉伸，拉伸成为一个784x1的矩阵，使得神经网络的输入层为184个神经元。</p>
<p>输出层具有一共10个神经元，输入一个图像，就输出十个神经元结果，一个神经元对应一个数字，利用softmax函数可以求出</p>
<p>笔记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pureloveljc&#x2F;tensorflow-mnist.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加载必要的库</span><br><span class="line">import tensorflow as tf</span><br><span class="line">#tensorflow 提供了相关的手写数字识别相关的类型，通过input_data可以方便的获取手写数字数据</span><br><span class="line">from tensorflow.examples.tutorials.mnist import import input_data</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下载数据集</span><br><span class="line"># 下载指定的数据集到知道指定目录</span><br><span class="line"># 读取数据集，第一个参数指定数据的位置，如果在指定目录下没有数据集，则会自动下载；</span><br><span class="line"># onehot指定是否按照这种编码返回标签。</span><br><span class="line"></span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;data&#x2F;&quot;,one_hot &#x3D; True)</span><br><span class="line"></span><br><span class="line">#数据集的查看</span><br><span class="line">#MNIST数据集共有70000张图片，训练集60000张，测试集10000张，训练集中的55000张训练图片和5000张验证图片。</span><br><span class="line">#MNIST图片为单通道的图片，每张图片是28x28的结构进行拉伸存储，每张图片的形状图片为（784，）</span><br><span class="line">display(mnist.train.images.shape)#（55000，784）</span><br><span class="line">display(mnist.train.labels.shape)# （55000，10）</span><br><span class="line"></span><br><span class="line"># 获取训练集的样本mnist.train.images</span><br><span class="line">#获取训练集的标签mnisttrain.labels</span><br><span class="line"># 显示训练集的第一张图片</span><br><span class="line">display(mnist.train.images[0])</span><br><span class="line"># 显示训练集第一章图片的标签</span><br><span class="line">display(mnist.train.labels[0])</span><br><span class="line"></span><br><span class="line"># 获取验证集和测试集</span><br><span class="line">display(mnist.validation.images.shape)</span><br><span class="line">display(mnist.validation.labels.shape)</span><br><span class="line">display(mnist.test.images.shape)</span><br><span class="line">display(mnist.test.test.labels.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示指定的图像</span><br><span class="line"># 可以通过matplotlib库显示指定的图像。注意，在显示图像的时候，需要将形状结构（784，）重构为（28x28）。</span><br><span class="line">plt.imshow(mnist.train.image[3].reshape(28,28),cmap&#x3D;&quot;gray&quot;)</span><br><span class="line"></span><br><span class="line">#神经网络的多分类任务，使用softmax来实现</span><br><span class="line">#有几个分类，最后一层（输出层）就具有几个神经元</span><br><span class="line"># 每个神经元表示属于特定神经元的概率。最终的分类，就是概率值最大的那个。</span><br><span class="line">#softmax 最后一层的神经元，净输入得到的，就是属于每个类别的分值（logits），然后，通过softmax激活函数进行转换，将得分值转化为概率值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用tensorflow构建单层神经网络</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义占位符吗，占位符通常用来接收输入数据</span><br><span class="line"># type :指定元素的类型</span><br><span class="line"># shape：张量的形状，None表示可以是任意长度。</span><br><span class="line">X &#x3D; tf.placeholder(dtype &#x3D; tf.float32,shape &#x3D; [None,784])</span><br><span class="line">Y &#x3D; tf.placeholder(dtype &#x3D; tf.float32,shape &#x3D; [None,10])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#假设训练样本有M个，那么训练集就是一个【M x 784】的矩阵，一行就代表着一个图像</span><br><span class="line">#每一张的图像的每一个元素都是一个特征，一个特征就对应一个权重值，一张图像整体对应一个偏置项</span><br><span class="line"># 一张图像进行计算的大致流程是：</span><br><span class="line">【       1                 x           784                】· 【         784             x              10     】         +【b1,b2,b3,b4,b5,b6,b7,b8,b9,b10】              &#x3D;           【   1    x    10   】</span><br><span class="line">      1张图像                   784个图像 (特征)             784个权重      输出层具有10个结点      每1个输出结点再加上1个偏置项，一共10个结点      1个图像属于10个阿拉伯数字各自的概率</span><br><span class="line">#大概的计算过程：【M x 784】· 【    784 x 10  】</span><br><span class="line">【1 x 784】· 【784 x 10】&#x3D; 【1 x 10】</span><br><span class="line"></span><br><span class="line">#对于单层的神经网络，权重初始化不是特别重要，但是对于多层的神经网络，权重的初始化比较重要</span><br><span class="line">#W &#x3D; tf.Variable(tf.random_nomal(shape &#x3D; [784,10],stddev &#x3D; 0.1))</span><br><span class="line"></span><br><span class="line"># 定义变量，通常用来表示模型中的参数</span><br><span class="line">W &#x3D; tf.Variable(tf.zeros(shape &#x3D; [784,10]))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros(shape[1,10]))</span><br><span class="line">#进行矩阵的点乘运算 </span><br><span class="line">z &#x3D; tf.matmul(X,W) + b # z 矩阵是【M，10】的矩阵</span><br><span class="line"># 通过softmax激活函数，将分值转换成概率值</span><br><span class="line">a &#x3D; tf.nn.softmax(z) #softmax函数不改变矩阵的形状</span><br><span class="line"># 定义损失目标函数（损失函数）</span><br><span class="line"># 在这里不推荐定义成平方误差函数，因为平方误差函数比较适合于连续变量，因为这里的分类，分类对了就是对了，分类成其他几种都是一样的错误分类，没有哪个错误分类值的惩罚值更大一说</span><br><span class="line"># 这里使用的是交叉熵损失函数，这里的矩阵相乘是对应位置相乘</span><br><span class="line">loss &#x3D; -tf.reduce_sum(y*tf.log(a))</span><br><span class="line"># 定义梯度下降优化器，对神经网络进行训练</span><br><span class="line"># 0.01是学习率，minimize是让参数值（损失值）最小化</span><br><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.01).minimize(loss)</span><br><span class="line"># correct 是一个【M,】元素值是布尔类型</span><br><span class="line">correct &#x3D; tf.equal(tf.argmax(y,axis&#x3D;1) , tf.argmax( a , axis&#x3D;1))</span><br><span class="line"># 求解出正确率；tensorflow对类型要求是非常严格的，不能直接使用布尔类型的张量直接进行数学计算，如果需要计算，使用tf的cast函数</span><br><span class="line">rate &#x3D; tf.reduce_mean(tf.cast(correct,tf.float32))</span><br><span class="line"># 定义会话，进行求值</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    #定义全局初始化器，用来对变量进行初始化，tensorflow，变量必须进行初始化</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    #迭代训练</span><br><span class="line">    for i in range(3000):</span><br><span class="line">        #获取下一个批次样本的数量,进行下批量梯度下降 </span><br><span class="line">        batch_X , batch_y &#x3D; mnist.train.next_batch(100)</span><br><span class="line">        # 使用feed_dict来填充占位符张量的数据</span><br><span class="line">        sess.run(train_step,feed_dict &#x3D; &#123;X:batch_X,y:batch_y&#125;)</span><br><span class="line">        if i %500 &#x3D;&#x3D; 0:</span><br><span class="line">            print(sess.run(rate,feed_dict &#x3D; &#123;X:mnist.test.images,y:mnist.test.labels&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">对单层神经网络进行改进，添加一层隐藏层，隐藏层的节点数，不固定，可任意。</span><br><span class="line"></span><br><span class="line">X  &#x3D; tf.placeholder(dtype &#x3D; tf.float32,shape &#x3D; [None,784])</span><br><span class="line">y &#x3D; tf.placeholder(dtype &#x3D; tf.float32,shape &#x3D; [None,10])</span><br><span class="line"># 如果将权重初始化为0，则准确率非常低</span><br><span class="line">#W &#x3D; tf.Variable(tf.random.normal(shape &#x3D; [784,256]))</span><br><span class="line"># 使用标准正态分布，标准是0.05，准确率是97%左右</span><br><span class="line"># W &#x3D; tf.Variable(tf.random_normal(shape&#x3D;[784,256],stddev &#x3D; 0.1))</span><br><span class="line"># 也可以使用截断正态分布，准确率和标准正态分布相似</span><br><span class="line">W &#x3D; tf.Variable(tf.truncated_normal(shape&#x3D;[784,256],stddev &#x3D; 0.1))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros(shape &#x3D; [1,256]))</span><br><span class="line">z &#x3D; tf.matmul(X,W)+b</span><br><span class="line"># 使用relu激活函数</span><br><span class="line">a &#x3D; tf.nn.relu(z)</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模比赛</title>
    <url>/2021/05/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="基本要求："><a href="#基本要求：" class="headerlink" title="基本要求："></a>基本要求：</h2><p>1：不要就题论题，寻一个一般性的数学模型，解决特定问题<br>2：文献查阅能力 把方程拿过来用，不需要搞太清楚<br>3：学习建模能力最重要</p>
<p>赛题结构：实际问题背景，若干假设条件，要求回答问题</p>
<p>标题和摘要部分很重要。</p>
<p>题目：写出比较确切的题目</p>
<p>论文排版问题很重要！！</p>
<p>论文写作：多个方法作对比，进行分析，做写点总结性话语，页数20-25</p>
<p>查重，高于30%基本上没有成绩，问题分析部分不能直接复制题目，论文题目，摘要，关键词是重中之重！！！</p>
<p>题目：基于<strong>__</strong>模型的<strong>____</strong>研究与分析<br>        • 摘要备战：总结归纳能力，通过看高水平论文或优秀论文掌握<br>        • 问题重述：切记直接抄袭问题，对描述简短的拆建，描述复杂的精炼<br>        • 问题假设：明确假设点是关键，只要对我们的结果有影响，但又是小概率事件；<br>                              或者对结果有影响，但难以计算获取这类的<br>        • 问题分析：动脑能力是关键，先将问题进行定性，然后说明如何求解这类 问题<br>        • 符号说明：文中出现的符号均需说清楚，<strong>用希腊字母</strong><br>        • 模型建立：将常见模型进行归纳整理，形成算法库<br>        • 模型求解：对编程语言熟练掌握，如 Ｍatlab，Lingo等<br>        • 模型优缺点评价：对模型的不足提前掌握，并在应用中的不足阐述<br>        • 参考文献：掌握标准格式</p>
<p>选完题及时上报选择的题目<br>A4版面；<br>上下左右页边距至少2.5cm；<br>标题前后空格<br>分号：中文分号；<br>论文题目三号黑体居中；<br>一级标题四号黑体居中；<br>二级三级标题小四黑体左端对齐；<br>其他汉字小四宋体；论文中的符号均为英文下的符号；<br>行间距：1.3<br>二级标题：段前段后0.5<br>参考文献书写规范：序号自动编号<br>摘要部分加粗部分不包括标点；<br>每行两端对齐；<br>英文变量：mathtype<br>页码数字：times new Roman<br>关键词：4-6个<br>公式：+句号或者逗号，下面一行顶格或者空两格，公式序号英文括号+数字Times New Roman<br>编号：自动编号；<br>图表：“图一”、“图二”加粗，图表不要太大，注意页边距；<br>文字表述：不要太重复；<br>摘要页开始编辑页码；<br>附录内容包括支撑材料文件列表和源代码（包含EXCEL和SPSS交互命令），没用到程序，在附录明确说明“本论文没有用到程序”；<br>论文pdf和支撑材料大小都不能超过20MB；<br>电子版论文命名：A/B/C+202116059004_ <em>张一诺</em> <em>刘慧盈</em> _ 崔金浩.pdf<br>支撑材料命名：A/B/C+202116059004_ <em>张一诺</em> <em>刘慧盈</em> _ 崔金浩_ 支撑材料.zip</p>
<h2 id="层次分析法（AHP）：一种定性和定量相结合，系统化的，层次化的分析方法"><a href="#层次分析法（AHP）：一种定性和定量相结合，系统化的，层次化的分析方法" class="headerlink" title="层次分析法（AHP）：一种定性和定量相结合，系统化的，层次化的分析方法"></a>层次分析法（AHP）：一种定性和定量相结合，系统化的，层次化的分析方法</h2><p><strong>适用于评价类问题,主观性较强，数据量较少</strong></p>
<p>层次分析法的三大典型应用：<br>        1：用于最佳方案的选取（选取运动员，选取地址）<br>        2：用于评价类问题（评价水质状况，评价环境）<br>        3：用于指标体系的优选（兼顾科学和效率）</p>
<p>特点：半定型，半定量问题转化为定量问题的行之有效的一种方法，使人们的思维过程层次化。</p>
<p>用途：通过逐层比较多种关联因素为 分析评估，决策，预测，或者控制事物的法发展提供定量依据，适用于<strong>难于完全定量方法进行分析的复杂问题</strong></p>
<p>层次结构：目标层（最高层），准则，指标层（中间层），方案层（最底层）</p>
<p>步骤：<br>    one：构造两两比较矩阵，对于同一层次的各因素关于上一层中某一目标的重要性进行两两比较<br>    two：由比较矩阵计算被比较因素对每一准则的相对权重，并进行<strong>判断矩阵的一致性检验。</strong><br>    three：计算方案层对目标层的组合权重，并进行排序。</p>
<h2 id="微分和差分"><a href="#微分和差分" class="headerlink" title="微分和差分 :"></a>微分和差分 :</h2><h2 id="概率与统计："><a href="#概率与统计：" class="headerlink" title="概率与统计："></a>概率与统计：</h2><p>​    伯努利方程，泊松分布，正态分布。<br>​    正态分布：期望就是平均数，什么时候是正态分布：多个因素影响最后结果。</p>
<p>生命问题还有器件的使用寿命问题—-&gt;指数分布</p>
<p>统计：在总体中抽出个别的样本，看样本来分析总体</p>
<p>极大似然估计法</p>
<p>假设检验：<br>    基本步骤：1假设      H0—-&gt;真         H1——-&gt;假</p>
<h2 id="聚类分析："><a href="#聚类分析：" class="headerlink" title="聚类分析："></a>聚类分析：</h2><p>​    层次聚类，K均值聚类</p>
<p>SPSS分类软件，Mpai</p>
<p>综合评价方法及其应用：<br>长江水质排名 </p>
<h2 id="灰色系统分析方法（用于预测）"><a href="#灰色系统分析方法（用于预测）" class="headerlink" title="灰色系统分析方法（用于预测）"></a>灰色系统分析方法（用于预测）</h2><p>灰色系统：介于白黑系统之间，系统内部特性是部分已知的，另一部分是未知的。<br>灰数：信息不完全的数<br>灰数的白化：确定数的值</p>
<p>总成分分析法：</p>
<p>lingo用来解决优化问题，可以解决线性规划和非线性规划的问题<br>Model开头，end结束</p>
<p>lingo不区分大小写；<br>以！开始以;结尾是一句注释</p>
<p>点击solve进行求解</p>
<p>Lingo编程语言</p>
<p>随机分析</p>
<p>线性规划问题：<br>    目标函数和约束函数均为线性函数，故称为线性规划问题，是在一组线性规划约束条件限制下，求解一个线性目标函数最大或者最小的问题。</p>
<p>可行解：满足约束条件的决策变量的取值<br>可行域：所有可行解构成的集合，简称为R</p>
<p>整数规划：<br>    规划中的变量（部分或者全部）限制为整数时，被称为整数规划。若在线性规划中，变量被限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法，往往只适用于整数线性规划。目前还没有一种 方法能有效地求解一切整数规划。<br>    整数规划的特点：<br>    1 原线性规划有最优解，当自变量限制为整数后，其整数规划解出现下述情况<br>        （1）原线性规划最优解全是整数，则整数规划最优解与线性规划最优解一致。<br>        （2）整数规划无可行解。<br>        （3）有可行解（当然就存在最优解），但最优解值变差。<br>    2 整数规划最优解不能按照实数最优解简单取整而获得。</p>
<p>整数规划按照对决策变量的要求可分为：纯整数规划，全整数规划，混合整数规划，0-1整数规划。</p>
<p>通过四舍五入得到的解不一定是最优解，甚至不能保证所得到的的整数是可行解</p>
<p>分支定界法：用来解决松弛问题没有可行解和松弛问题下的最优解不满足整数条件。<br>割平面法：用来解决解中含有非整数分量的情况。</p>
<p>0-1变量使用：用来解决互斥约束问题。两个东西只选其一</p>
<p>非线性规划问题：</p>
<p>定义：如果目标函数或者约束条件中包含非线性函数，则规划问题为非线性规划问题</p>
<p>一般来说，解非线性规划比解线性规划困难的多<br>非线性规划现在还没有适用于各种问题<br>一般形式：在一组等式或者不等式的约束下，求一个函数的最大值或者最小值，其中一个是非线性函数。</p>
<p>二次规划：如果非线性规划的目标函数为自变量的二次函数，约束<br>条件全是线性的，则称规划为二次规划。</p>
<p>层次分析法（AHP）：<br>    用于解决规划问题，解决多目标的复杂问题的定性与定量想结合的决策分析方法。衡量目标之间的相对重要程度，有效应用于难以定量方法解决的课题。</p>
<p>灰色预测模型：<br>    灰色预测法是一种对含有不确定因素的系统进行预测的方法，是对既含有已知信息又含有不确定信息的系统进行预测，就是对一定范围内变化的，与时间有关的灰色过程进行预测。</p>
<p>原理：通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，并生成较规律性的数据序列，然后建立相应的微分方程模型，从而进行预测未来的发展趋势的状况。</p>
<p>灰色预测法用等时距观测到的反映预测的对象的特征的一系列数量值构造灰色预测模型，预测未来某一刻的特征值，或达到某一特征量的时间。</p>
<p>灰色预测的四种常见类型：<br>    灰色时间序列预测：即用观察到的反映预测对象特征的时间序列来构造灰色预测模型。预测未来某一时刻的特征值，或者达到某一特征量的时间。<br>    畸变预测：通过灰色模型预测异常值出现的时刻，预测异常值出现时候出现在特定时区内。<br>    系统预测：通过对系统行为特征指标建立一组互相关联的灰色预测模型，预测系统中众多变量间的相互协调关系的变化。<br>    拓扑预测：将原始数据做成曲线，在曲线上按定值寻找该定值发生的所有时间点，并以该定值为框架构成时间点数列，然后建立预测该定值所发生的时间点。</p>
<p>灰色关联度：是分析向量与向量之间，矩阵与矩阵之间的关联度，需要一个参考物（比较序列）进行计算。</p>
<p>插值与拟合基本原理<br>    插值用拟合是数学建模中基本的数据分析手段，公认的常用算法。<br>    一个插值多项式如果次数太高，会出现严重的震荡现象（Runge现象）<br>    插值多项式的次数越高，精度不一定越高，在实际的应用中，不应该使用七次以上的插值。<br>    解决办法：将插值区间分成若干的小区间，小区间内用低次的（一次，二次）插值，即分段低次插值<br>    插值包括：一元插值，二元插值，散乱点插值</p>
<p>拟合问题：<br>    插值问题与拟合问题的区别：<br>        插值函数过已知点，拟合函数不一定过已知点。<br>        插值只要用于求函数值，而拟合的主要目的就是求函数关系，从而进行预测等一系列分析。<br>    线性拟合中的参数的计算，采用最小二乘法，而非线性拟合参数的计算需要运用Gauss-Newton迭代法    </p>
<p>模糊综合评价模型原理</p>
<p>模糊数学：现实世界的许多现象和关系具有不确定性，不确定性的表现形式有很多：随机性，灰色性，模糊性和粗糙性。</p>
<p>模糊数学多用于评价问题</p>
<p>模糊集：许多现象和关系具有模糊性，例如，长与短，贫与富等</p>
<p>隶属度：一个成员元素所属模糊集的程度</p>
<p>确定隶属度的常用方法是模糊分布法，模糊分布将隶属函数看成一种模糊分布，首先根据问题性质选取适当的模型分布，然后根据相关数据确定分布中的参数</p>
<p>模糊分布的常用梯形分布：偏小型，偏大型，中间型<br>偏小型一般适用于描述‘小’，‘少’，‘浅’等模糊现象;偏大型正好与偏小型相反;中间型用于描述中间状态。</p>
<p>模型综合评价：对一个事物的评价要涉及到很多因素或者多个指标，评价是在多因素作用下的一种综合评价。<br>    评价的方法又很多：灰色评价法，层次分析法，模糊综合评价法，网络包络分析法人工神经网络评价法，理想解法等。</p>
<p>模糊评价是模糊数学的一种具体应用，该方法简单易掌握，对多层次的复杂问题评价效果比较好。</p>
<p>相关性分析：</p>
<p>如果一个变量的取值发生变化，另一个变量也发生了变化，则称为两个变量有关，否则无关。</p>
<p>关系变量强度：指两个变量之间的关联程度的高低。<br>统计学中，是已准实验的思想分析变量相关的，通常以以下角度分析：<br>    1，两个变量是否独立；2，两个变量是否有共变趋势。3，一个变量的变化多大程度上能由另一个变量来解释。</p>
<p>Pearson相关系数：适用于定距，定比的类型的变量，是运用最广的一种相关程度统计量<br>Pearson相关系数的计算适用条件：<br>    两变量均是由测量得到的连续变量。<br>    两变量所来自的总体都是正态分布，或者接近正态分布。、<br>    变量必须是成对出现的<br>    两变量必须是线性关系。</p>
<p>相关系数性质：相关系数r的绝对值越接近1，表明两个变量的相关程度越高，关系越密切。</p>
<p>hold on，hold off：matlab中画图时加入，hold on 在已经显示的图画上继续显示，hold off 取消这种显示方式。</p>
<p>整数规划模型：<br>    数学规划中的变量（部分或全部）限制为整数时，称为整数规划。若在 线性规划模型中，变量限制为整数，则称为整数线性规划。整数规划只适用于整数线性规划</p>
<p>整数规划模型：<br>1)变量全部限制为整数，成为完全整数规划。<br>2）变量部分限制为整数，称为混合整数规划。</p>
<p>tip：整数规划最优解不能由实数最优解简单取整获得。</p>
<p>​        </p>
]]></content>
  </entry>
  <entry>
    <title>考研信息整理</title>
    <url>/2021/08/15/%E8%80%83%E7%A0%94%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>初试时间：</p>
<p>​    每年12月份的最后一个星期左右</p>
<p>​    第一天：政治+英语    第二天：数学+专业课</p>
<p>​    上午8：30-11：30，下午14：00-17：00</p>
<hr>
<p>时间节点：</p>
<p>​    9月中旬公共课考纲公布；<br>​    9月24-27号 每天9点-22点预报名；<br>​    10月10号-31号正式报名；<br>​    11月中旬现场确认或者网上确认。12月打印准考证</p>
<hr>
<p>政治：马原24分，毛特30分，史纲14分，思修与法律基础16分，当代世界经济与形式与政策16分</p>
<p>​    政治单科划线50-55左右，70+算高分。</p>
<p>​    试卷内容分为两大模块：主观题（5道，每题10分）客观题（16道单选一题1分，14道多选一题2分）多选选全给分</p>
<p>​    估分：选择题分数*2，历年真题选择题平均分29分左右。</p>
<p>​    复习规划：</p>
<p>​        7-10月：</p>
<p>​            《肖秀荣知识点精讲精练》+《肖秀荣1000题》，可以先不做真题，真题除了马原不会有考的题目。快速阅读《肖秀荣知识点精讲精练》有不错的知识印象，形成大概的知识点框架。一天一节，看完一节将1000题中的选择题做完，可以先不做大题，一天1-2小时。</p>
<p>​        10-12月：</p>
<p>​            《疾风劲草冲刺背诵核心考点》可以不加配套试题+《肖秀荣1000题》+《肖秀荣形势与政策》。需要专门背诵选择题的考点。每天先背诵一节《核心考点》然后凭借刚背诵的知识点做肖秀荣1000，核心考点看完开始看形势政策，形势政策可不不用看完，挑今年大事。一天2小时</p>
<p>​        12月-考前：主攻政治大题，每天2-3小时</p>
<p>​            《肖秀荣8套》+《肖秀荣4套》8套11月下旬卖，4套12月上旬卖。每天一张卷子，只做选择题部分，大题用来背，大题重点背加黑部分，同时也要写写，找找题感。肖4大题重中之重，马原大题部分可以独立做，锻炼自己思考能力，【马原找原理需要题量】，其他的分析题直接过答案，分析今年的出题角度。押题班压题课可以听听，不要全信。</p>
<hr>
<p>英语：</p>
<p>​    英语1：（完形填空10分，阅读A40分，阅读B（新题型）10分，翻译10分，大作文20分，小作文10分）英语二：（完形填空10分，阅读A40分，阅读B（新题型）10分，翻译15分，大作文15分，小作文10分）                    </p>
<hr>
<p>数学：数1注重知识点的宽度，数2侧重知识点的深度。</p>
<p>​    数1：高数60%，线代20%，概率20%<br>​        选择：6高数+2线代+1概率，一题5分；<br>​        填空：4高数+1线代+1概率，一题5分；<br>​        解答题：4高数+1线代+1概率，高数40分，线代15分，概率15分；<br>​    数2：高数80%，线代20%<br>​        选择：8高数+2线代，一题5分；<br>​        填空：5高数+1线代，一题5分；<br>​        解答：5高数+1线代，高数55分，线代15分；</p>
<p>数2复习规划：多做题，相对少看视频</p>
<p>​    7-10月：同济课本+数学二公式手册+李永乐数学历年真题权威解析（分章节）+汤家凤1800题<br>​        可以对照着公式手册画课本上的知识点，剔除掉书上不考的内容。每天复习每章节考察的知识点，复习完一章就去做李永乐数学历年真题权威解析。一天4-5小时。</p>
<p>​    10-12月：模拟题，一天一套</p>
<p>​        李永乐冲刺6+2；汤家凤绝对考场最后8套卷；张宇8套卷；考研数学决胜考场8套卷；海文考前预测8套卷；终极密押5套卷；tip：注意时间分配，重视考场心态调整，严格按照3小时考试进行答题。做好错题笔记。</p>
<p>12月-考前：</p>
<p>​    模拟做真题由于第一阶段做过李永乐数学历年真题权威解析，因为是分章节，最后一个阶段对真题进行模拟考试，时间紧的话只做近几年的。最后两个星期重点对前面的错题笔记进行回顾。</p>
<p><strong>PS</strong> ：数二可以适当放弃物理应用部分，考察范围太广。</p>
<hr>
<p>专业课：408–&gt;统考，其他–&gt;自主命题</p>
<p>​            </p>
<p>试考408，调剂能调自主命题的学校吗？</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2021/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习资料来源：GitChat《机器学习极简入门》,黄广海《吴恩达机器学习笔记》</p>
<p>监督学习：就是我们给学习算法一个数据集，这个数据集由“正确答案”组成。</p>
<p>监督学习基本思想：我们每个数据集的每个样本都有相应的正确答案，再根据这些样本进行预测。</p>
<p>回归：就是我们推测这一系列连续值属性</p>
<p>分类：就是我们试着推测出离散的输出值，目标是推出一组离散的结果</p>
<p>无监督学习：无监督学习中没有任何标签或者是有相同的标签或者就是没有标签</p>
<p><em>聚类是无监督学习的一种</em></p>
<p>无监督学习：是一种学习策略，交给算法大量数据，并让算法为我们从数据中找出某种结构</p>
<p>代价函数也称为平方误差函数</p>
<p>梯度下降算法：一种用来求函数最小值的算法</p>
<p>正规方程：可以直接计算出函数最小值</p>
<p><em>正规方程和梯度下降：在数据量较大的时候，梯度下降法比正规方程更适用</em></p>
<a id="more"></a>

<p>深度学习与机器学习具有传承关系，学习后者对于理解前者有很大帮助。</p>
<p>有监督学习（监督学习）VS无监督学习<br>有监督学习，有标签，对数据有标注<br>无监督学习，没有标签值</p>
<p>机器学习3要素：数据，模型，算法<br>    算法通过在数据上进行运算产生模型<br>    向量空间模型（Vector Space Model/VSM），VSM负责将各种格式（图片，文字，视频）转化为一个个向量。<br>    有监督学习除了和无监督学习有标注样本的X，还有无标注样本的标签向量Y。</p>
<p>特征工程：确定哪些特征来表示数据；确定用什么方式表达这些特征。</p>
<p>代价函数一般写成：<br>    J（theta），代价函数的自变量是f（X）函数中的待定的参数，theta可以是一个向量，如果是向量的话，说明待定的参数不止一个，一个维度代表一个参数。</p>
<p>让代价函数最小的theta就是最好的theta，代入到原函数中，函数也是最终的模型函数。</p>
<p>找到最好的theta的方法：<br>    梯度下降法（Gradient Descent);共轭梯度法（Conjugate Gradient）;牛顿法和拟牛顿法;模拟退火法（Simulated Annealing）等等。</p>
<p>构建模型的基本步骤：    </p>
<p>Step-1：数据准备。<br>    Step-1.1 数据预处理：收集数据、清洗数据、标注数据。<br>    Step-1.2 构建数据的向量空间模型（将文本、图片、音频、视频等格式的数据转换为向量）。<br>    Step-1.3 将构建好向量空间模型的数据分为训练集、验证集和测试集。</p>
<p>Step-2：<br>    训练——&gt;将训练集输入给训练程序，进行运算。训练程序的核心是算法，所有输入的向量化数据都会按该训练程序所依据的算法进行运算。<br>    训练程序输出的结果，就是模型。</p>
<p>Step-3：<br>    测试——&gt;将测试集数据输入给训练获得的模型，得到预测结果；再将预测结果与这些数据原本预期的结果进行比较。</p>
<p>训练集：用来做训练的数据集合<br>验证集：用来在训练的过程中每个训练轮次结束后验证当前模型性能，为进一步优化模型提供参考的数据的集合。<br>测试集：用来测试的数据的集合，用于检验最终得出的模型的性能</p>
<p>tip：每个集合应是独立的，和另外两个没有重叠。</p>
<p>有些情况，验证和测试可以合二为一；<br>验证集：可以理解为小规模的对于已经生成模型的测试。</p>
<p>Step-2 训练过程：</p>
<p>Step-2.1： 编写训练程序。<br>    Step-2.1.1： 选择模型类型；<br>    Step-2.1.2： 选择优化算法；<br>    Step-2.1.3： 根据模型类型和算法编写程序。<br>    Step-2.2： 训练 -&gt; 获得临时模型。</p>
<p>Step-2.3： 在训练集上运行临时模型，获得训练集预测结果。</p>
<p>Step-2.4： 在验证集上运行临时模型，获得验证集预测结果。</p>
<p>Step-2.5： 综合参照 Step-2.4 和 Step-2.5 的预测结果，改进模型。</p>
<p>Step-2.6： Step-2.2 到 Step-2.5 反复迭代，直至获得让我们满意，或者已经无法继续优化的模型。</p>
<p><em>机器学习的模型质量往往和训练数据有直接关系。</em></p>
<p>有限的数据，提高模型质量的手段：<br>    1对数据进行归一化处理(Normalization),正则化(Regularization)等标准化操作；<br>    2采用BootStrap等采样方法处理有限的训练/测试数据，已达到更好的运算效果。<br>    3根据业务进行特征选取：从业务角度区分输入数据包含的特征，并理解这些特征对结果的贡献。</p>
<p>超参数：是需要模型训练者自己设置和调整的，许多算法库都有算法的默认超参数。</p>
<p>模型训练得出结果容易，得到优质结果难。</p>
<p>分类模型评判指标： Precision，Recall 和 F1Score<br>    对于分类，简单的常见的验证指标：精准率，召回率，为了综合两个指标并量化结果，又出现F1Score。</p>
<p>精准率：Precision=TP/（TP+FP），即在所有被预测为 Class_A 的测试数据中，预测正确的比率。</p>
<p>召回率：Recall=TP/（TP+FN），即在所有实际为 Class_A 的测试数据中，预测正确的比率。</p>
<p>F1Score = 2*(Precision * Recall)/(Precision + Recall)</p>
<p>显然上面三个值都是越大越好，但往往在实际当中 P 和 R 是矛盾的，很难保证双高。</p>
<p>偏差和过拟合：<br>    如果一个模型，在训练集上的预测结果就不佳，指标偏低，一般就是欠拟合的；<br>    如果在训练集上指标很好的话，在验证集和测试集指标偏低，则可能过拟合；<br>    欠拟合情况：多数情况下是选择模型太过简单，特征选取不够导致的。<br>    过拟合情况：模型太过复杂，特征选取不当（过多，或者组合不当）造成的。<br>    解决方法：针对性的选择更简单/复杂的模型类型；增加减少特征；减小/增大正则项比重；增大训练数据的训练量</p>
<p>凸函数：<br>    机器学习的凸函数，不是高等数学的凸函数，是高等数学的凹函数。</p>
<p>线性回归：<br>    线性回归模型是：利用线性回归对一个或者多个自变量和因变量之间的关系进行拟合的模型。</p>
<pre><code>当训练数据的特征是一维的时候，线性回归可以在之间坐标系中表示，形式是一条直线。</code></pre><p>一元函数在某一点处沿着x轴的正方向的变化率称为导数，二元或者多元的情况，则某一点处沿着某一维度坐标正方向的变化率称为偏导数</p>
<p>——————————–第十一篇的偏微分部分不是很理解———————————————————-</p>
<p>当我们求出了一个函数的（偏）微分函数后，将某个变量带入其中，得出的（偏）微分函数对应的函数值，就是原函数在该点处，对该自变量求导的导数值。<br>所以，只要我们求出了目标函数的（偏）微分函数，那么目标函数自变量值域内每一点的导数值也就都可以求了。</p>
<hr>
<p>线性回归的超参数：<br>    对于梯度下降法而言，是要用到梯度下降，就会有步长alpha这个超参数。<br>    如果训练结果偏差较大，可以尝试调小步长；<br>    如果模型质量不错但是训练效率太低，可以适当放大步长；<br>    也可以尝试使用动态步长，开始步长较大，随着梯度的缩小，步长同样缩小……<br>    如果训练程序是通过人工指定迭代次数来确定退出条件，则迭代次数也是一个超参数。<br>    如果训练程序以模型结果与真实结果的整体差值小于某一个阈值为退出条件，则这个阈值就是超参数</p>
<hr>
<p>正则化：为了防止</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模常用算法汇总</title>
    <url>/2021/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>建模步骤：模型准备–&gt;模型准备–&gt;模型建立–&gt;模型求解–&gt;模型分析–&gt;对于模型假设进行检验–&gt;模型应用</strong></p>
<p><strong>（1）数据处理问题&amp;数据预处理</strong></p>
<p>差值拟合：主要用于对数据的补全和基本的趋势分析</p>
<p>小波分析，聚类分析（高斯混合聚类，K-均值聚类等等）：主要用于诊断数据异常值并进行剔除</p>
<p>主成分分析、线性判别分析、局部保留投影等：主要用于多维数据的降维处理，减少数据冗余</p>
<p>均值、方差分析、协方差分析等统计方法：主要用于数据的截取或者特征选择</p>
<p><strong>（2）关联与因果</strong></p>
<p>灰色关联分析方法（样本点的个数较少）</p>
<p>Superman或kendall等级相关分析</p>
<p>Person相关（样本点的个数比较多）</p>
<p>Copula相关（比较难，金融数学，概率密度） </p>
<p>典型相关分析（因变量Y1234,自变量组X1234，各自变量组相关性比较强，问哪一个因变量与哪一个自变量关系比较紧密？）</p>
<p><strong>（3）分类与判别</strong></p>
<p>距离聚类（系统聚类）常用；关联性分析（常用）；层次聚类；密度聚类；其他聚类；贝叶斯判别法（统计判别方法）；费舍尔判别（训练的样本比较少）；模糊识别（分好类的数据点比较少）</p>
<p><strong>(4)评价与决策</strong></p>
<p>模糊综合判别：评价一个对象优，良，中，差等层次判别，评价一个学校等，不等排序；</p>
<p>主成分分析法：评价多个对象的水平并排序，指标间关联性强；</p>
<p>层次分析法：做决策，通过指标，综合考虑做决定；</p>
<p>数据包络（DEA）分析法：优化问题，对各省发展状况进行评价；</p>
<p>秩和比综合评价法：评价各个对象并排序，指标间关联性不强；</p>
<p>神经网络评价法：适用于多指标非线性关系明确的评价；</p>
<p>优劣解距离法（TOPSIS法）</p>
<p>投影寻踪综合评价法：糅合人多种算法，比如多种算法，比如遗传算法，最优化理论；</p>
<p>方差分析：看几类数据之间有无差异，差异性影响，例如元素对麦子的产量有无影响差异值的多少；</p>
<p>协方差分析：有几个因素，我们只考虑一个因素对问题的影响，忽略其他因素，但是注意初始数据的量纲以及初始情况。（2006年，艾滋病疗法的评价以及预测问题）</p>
<p><strong>（5）预测与预报</strong></p>
<p>场景主要分5种：小样本内部预测，大样本内部预测，小样本未来预测，大样本的随机因素或者周期特征的未来预测，大样本的未来预测。</p>
<p>灰色预测模型（必须掌握）：<br>    满足两个条件：a 数据样本点个数少，6-15个；b数据呈现指数或者曲线形式；</p>
<p>微分方程预测（备用）：<br>    无法直接找到原始数据之间的关系，但是可以找到原始数据变化速度之间的关系，通过公式推导转化为原始数据之间的关系。</p>
<p>回归分析预测（必须掌握）：<br>    求一个因变量与若干自变量之间的关系，若自变量变化之后，求因变量如何变化。<br>    样本点的个数要求：<br>        a自变量之间协方差比较小，最好趋于零，自变量间的关系小；<br>        b样本点的个数n&gt;3k+1,k为自变量的个数；<br>        c因变量要符合正态分布；</p>
<p>马尔科夫预测（备用）：<br>    一个序列之间没有信息的传递，前后没有联系，数据与数据之间随机性强，相互不影响；今天的温度与昨天、后天没有直接联系，预测后天温度高、中、低的概率，只能得到概率</p>
<p>时间序列预测（必须掌握）：<br>    与马尔科夫预测互补，至少有2个点需要信息的传递，ARMA模型，周期模型，季节模型等。</p>
<p>小波分析预测 ：</p>
<p>神经网络预测</p>
<p>混沌序列预测</p>
<p><strong>（6）优化与控制</strong></p>
<p>①线性规划，整数规划，0-1规划（有约束，确定的目标）</p>
<p>②非线性规划与智能化优化算法</p>
<p>③多目标规划和目标规划（柔性约束，目标含糊，超过）</p>
<p>④动态规划</p>
<p>⑤图论，网络优化（多因素交错复杂）</p>
<p>⑥排队论与计算机仿真</p>
<p>⑦模糊规划（范围约束）</p>
<p>⑧灰色规划（难）</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/06/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>计算机网络：<br>    是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及其网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>网络编程：<br>    在网络通信协议下，实现网络互联的不同计算机运行的程序间可以进行数据交换。</p>
<p>网络编程3要素：</p>
<pre><code>IP地址：
    要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

端口：
    网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识

协议：
    通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</code></pre><p>IP地址：网络中设备的唯一标识<br>    IPV4：为每个连接在网络上的主机分配的32bit的地址，也就是4字节，例如11000000 10101000 00000001 01000010，为一个ipv4的地址，利用点分十进制表示法可以看成192.168.1.66<br>    IPV6：v4的地址不够用，v6重新定义地址空间，采用128为地址长度，16字节一组，8组十六进制数，来解决网络地址不足的问题<br>    DOS常用命令：<br>        ipconfig：查看本机IP地址<br>        ping IP地址：检查网络是否连通<br>    特殊IP地址：<br>        127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</p>
]]></content>
  </entry>
  <entry>
    <title>英语学习</title>
    <url>/2021/06/07/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="人人词典-六级乱序-必拿下！！！"><a href="#人人词典-六级乱序-必拿下！！！" class="headerlink" title="人人词典-  六级乱序,必拿下！！！"></a>人人词典-  六级乱序,必拿下！！！</h1><p>​    <strong>议论文</strong></p>
<p>​    In the contemporary world ,the ability to meet challenges has become increasingly important. It is of great necessity for students to solve problems when facing difficulty .The following are my reasons and concrete evidence support my view point.</p>
<p>​    <strong>翻译词汇：</strong></p>
<p>​    socialist prosperity 社会主义财富</p>
<p>universal common prosperity 全民共同富裕</p>
<p>build a harmonious society 构建和谐社会</p>
<p>livelihood 民生问题</p>
<p>employment 就业</p>
<p>pension 养老金</p>
<p>people of all nationalities 各族人民</p>
<table>
<thead>
<tr>
<th align="left"><strong>spectacular</strong> 壮丽的</th>
<th align="left">extravagant 奢侈的</th>
<th align="left">magnificent 壮丽的</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>corporation 公司，社团</strong></td>
<td align="left">*<em>temperament *</em> 性格，气质</td>
<td align="left"><strong>recognition</strong> 识别，承认</td>
</tr>
<tr>
<td align="left"><strong>temperature</strong> 温度，体温</td>
<td align="left"><strong>susceptible</strong> 易受影响，感染的</td>
<td align="left"><strong>immediately</strong> 立即，马上</td>
</tr>
<tr>
<td align="left"><strong>implication</strong> 含义，暗指</td>
<td align="left"><strong>incorporate</strong> 组成公司，包含混合</td>
<td align="left"><strong>philosopher</strong> 哲学家，思想家</td>
</tr>
<tr>
<td align="left"><strong>predecessor</strong> 前辈，前任</td>
<td align="left"><strong>orientation</strong> 方向，取向，向东方</td>
<td align="left"><strong>preliminary</strong> 初步的，初级的</td>
</tr>
<tr>
<td align="left"><strong>installment</strong> 部分，分期付款</td>
<td align="left"><strong>appropriate</strong> 适当的，合适的</td>
<td align="left"><strong>proposition</strong> 建议，主张</td>
</tr>
<tr>
<td align="left"><strong>consecutive</strong> 连续的，不间断的</td>
<td align="left"><strong>hospitality</strong> 好客的</td>
<td align="left"><strong>predominant</strong> 主要的，主导地位的</td>
</tr>
<tr>
<td align="left"><strong>sympathetic</strong> 同情的，赞同的</td>
<td align="left"><strong>bureaucracy</strong> 官僚的，官僚作风</td>
<td align="left"><strong>indignation</strong> 愤怒，气氛</td>
</tr>
<tr>
<td align="left"><strong>precipitate</strong> 下掷，突然发生</td>
<td align="left"><strong>thermometer</strong> 温度计，体温计</td>
<td align="left"><strong>ultraviolet</strong> 紫外线</td>
</tr>
<tr>
<td align="left">*<em>homogeneous *</em> 同类的，同性质的</td>
<td align="left"><strong>proficiency</strong> 熟练的，精通的</td>
<td align="left"><strong>renaissance</strong> 重生</td>
</tr>
<tr>
<td align="left"><strong>provocative</strong> 挑衅的，刺激的</td>
<td align="left"><strong>exclusively</strong> 专一地，唯一地</td>
<td align="left"><strong>destination</strong> 目的地</td>
</tr>
<tr>
<td align="left"><strong>forthcoming</strong> 即将到来的</td>
<td align="left"><strong>conjunction</strong> 结合，同时发生的</td>
<td align="left"><strong>discrepancy</strong> 差异，不一致</td>
</tr>
<tr>
<td align="left">*<em>contemplate *</em>考虑，沉思</td>
<td align="left"><strong>commemorate</strong> 纪念</td>
<td align="left"><strong>conspicuous</strong> 显眼的</td>
</tr>
<tr>
<td align="left"><strong>investigate</strong> 调查研究</td>
<td align="left"><strong>distinction</strong> 差别，差异，特质</td>
<td align="left"><strong>deteriorate</strong> 恶化，变化</td>
</tr>
<tr>
<td align="left">*<em>spontaneous *</em>自发的，天然的</td>
<td align="left"><strong>hypothesis</strong> 假说，假设</td>
<td align="left"><strong>prosperous</strong> 兴旺的，繁荣的</td>
</tr>
<tr>
<td align="left"><strong>infectious</strong> 传染的，有感染力的</td>
<td align="left"><strong>exposition</strong> 说明，阐述</td>
<td align="left"><strong>inhabitant</strong> 居住</td>
</tr>
<tr>
<td align="left">*<em>lieutenant *</em>陆军中尉</td>
<td align="left"><strong>suspicious</strong> 怀疑，可以</td>
<td align="left"><strong>indication</strong> 表明，象征</td>
</tr>
<tr>
<td align="left"><strong>degenerate</strong> 退化，恶化</td>
<td align="left"><strong>vegetation</strong> 蔬菜的</td>
<td align="left"><strong>deficiency</strong> 缺乏，不足，缺陷</td>
</tr>
<tr>
<td align="left">*<em>suspension *</em>暂停，悬浮，悬挂</td>
<td align="left">*<em>navigation *</em>航行</td>
<td align="left"><strong>compliment</strong> 赞美，恭维</td>
</tr>
<tr>
<td align="left">*<em>exaggerate *</em>夸大，夸张</td>
<td align="left"><strong>conviction</strong> 判罪，坚定，坚信</td>
<td align="left"><strong>competence</strong> 能力，技能，权限</td>
</tr>
<tr>
<td align="left"><strong>contradict</strong> 反驳，矛盾</td>
<td align="left"><strong>supersonic</strong> 超声，超音速的</td>
<td align="left"><strong>facilitate</strong> 促进，使便利</td>
</tr>
<tr>
<td align="left">*<em>philosophy *</em>哲学的</td>
<td align="left"><strong>transistor</strong> 晶体管，收音机</td>
<td align="left"><strong>applicable</strong> 适当的，可应用的</td>
</tr>
<tr>
<td align="left"><strong>arithmetic</strong> 算数的</td>
<td align="left"><strong>intimidate</strong> 恐吓，威胁</td>
<td align="left"><strong>revelation</strong> 启示，启发，揭露</td>
</tr>
<tr>
<td align="left"><strong>presumably</strong> 推测，大概</td>
<td align="left"><strong>ridiculous</strong> 荒唐的，荒谬的</td>
<td align="left"><strong>negligible</strong> 可忽略的</td>
</tr>
<tr>
<td align="left"><strong>stationary</strong>  不动的，静止的</td>
<td align="left"><strong>propaganda</strong> 宣传</td>
<td align="left"><strong>Fahrenheit</strong> 华氏温度</td>
</tr>
<tr>
<td align="left"><strong>subsidiary</strong> 附带，附属的</td>
<td align="left"><strong>delegation</strong> 代表团</td>
<td align="left"><strong>investigation</strong> 调查</td>
</tr>
<tr>
<td align="left"><strong>Mediterranean</strong> 地中海</td>
<td align="left"><strong>sophisticated</strong> 复杂的，精致的，有经验的</td>
<td align="left"><strong>entrepreneur</strong> 企业家</td>
</tr>
<tr>
<td align="left"><strong>bibliography</strong> 书目，文献</td>
<td align="left"><strong>headquarters</strong> 总部</td>
<td align="left"><strong>proportional</strong> 比例，呈比例的</td>
</tr>
<tr>
<td align="left">*<em>simultaneous *</em>同时的</td>
<td align="left"><strong>intermittent</strong> 间歇，间断</td>
<td align="left"><strong>quantitative</strong> 定量的，数量上的</td>
</tr>
<tr>
<td align="left"><strong>confidential</strong> 机密的</td>
<td align="left"><strong>intersection</strong> 横断，切断</td>
<td align="left"><strong>discriminate</strong> 区分，辨别</td>
</tr>
<tr>
<td align="left">*<em>metropolitan *</em> 大都市，宗主国</td>
<td align="left"><strong>complication</strong> 困难，并发症</td>
<td align="left"><strong>respectively</strong> 各自地，分别地</td>
</tr>
<tr>
<td align="left"><strong>rectangular</strong> 矩形的</td>
<td align="left"><strong>agony 极度痛苦</strong></td>
<td align="left"><strong>alloy 合金(金属的 )成色</strong></td>
</tr>
<tr>
<td align="left"><strong>ampere 安培</strong></td>
<td align="left"><strong>amplify 放大，增强</strong></td>
<td align="left"><strong>annoy 使恼怒；打搅</strong></td>
</tr>
<tr>
<td align="left"><strong>apparatus 器械，仪器；器官</strong></td>
<td align="left"><strong>arrow 箭；箭状物</strong></td>
<td align="left"><strong>assemble 集合，召集；装配</strong></td>
</tr>
<tr>
<td align="left"><strong>attentive 注意的；有礼貌的</strong></td>
<td align="left"><strong>aural 耳的，听觉的</strong></td>
<td align="left"><strong>auxiliary 辅助的；附属的</strong></td>
</tr>
<tr>
<td align="left"><strong>aviation 航空，航空学</strong></td>
<td align="left"><strong>ax n.斧子</strong></td>
<td align="left"><strong>bacteria n.细菌</strong></td>
</tr>
<tr>
<td align="left"><strong>baggage n.行李</strong></td>
<td align="left"><strong>bare a.赤裸的；仅仅的</strong></td>
<td align="left"><strong>barn n.谷仓；牲口棚</strong></td>
</tr>
<tr>
<td align="left"><strong>barrel n.桶；圆筒；枪管</strong></td>
<td align="left"><strong>barrier n.栅栏，屏障；障碍</strong></td>
<td align="left"><strong>beam n.梁；横梁；束，柱</strong></td>
</tr>
<tr>
<td align="left"><strong>blame vt.责备，把…归咎于</strong></td>
<td align="left"><strong>blast n.爆炸，冲击波 vt.炸</strong></td>
<td align="left"><strong>blaze n.火；闪光 vi.燃烧</strong></td>
</tr>
<tr>
<td align="left"><strong>blend vt.&amp;vi.&amp;n. 混和</strong></td>
<td align="left"><strong>bolt n.螺栓；插销 vt.闩门</strong></td>
<td align="left"><strong>booth n.货摊；公用电话亭</strong></td>
</tr>
<tr>
<td align="left"><strong>bosom n.胸，胸部；内心</strong></td>
<td align="left"><strong>brandy n.白兰地酒</strong></td>
<td align="left"><strong>brass n.黄铜；黄铜器</strong></td>
</tr>
<tr>
<td align="left"><strong>bread n.面包；食物，粮食</strong></td>
<td align="left"><strong>breadth n.宽度，幅度；幅面</strong></td>
<td align="left"><strong>breeze n.微风，和风</strong></td>
</tr>
<tr>
<td align="left"><strong>brim n.边，边缘；帽沿</strong></td>
<td align="left"><strong>brisk a.活泼的；清新的</strong></td>
<td align="left"><strong>bristle n.短而硬的毛；鬃毛</strong></td>
</tr>
<tr>
<td align="left"><strong>brittle a.脆的；易损坏的</strong></td>
<td align="left"><strong>bronze n.青铜；青铜制品</strong></td>
<td align="left"><strong>brood n.同窝幼鸟 vt.孵(蛋)</strong></td>
</tr>
<tr>
<td align="left"><strong>brook n.小河，溪流</strong></td>
<td align="left"><strong>bruise n.青肿，伤痕；擦伤</strong></td>
<td align="left"><strong>brute n.禽兽，畜生</strong></td>
</tr>
<tr>
<td align="left"><strong>bucket n.水桶；吊桶；铲斗</strong></td>
<td align="left"><strong>bud n.芽，萌芽；蓓蕾</strong></td>
<td align="left"><strong>bundle n.捆，包，束；包袱</strong></td>
</tr>
<tr>
<td align="left"><strong>bureau n.局，司，处；社，所</strong></td>
<td align="left"><strong>butcher n.屠夫；屠杀者</strong></td>
<td align="left"><strong>cabinet n.橱，柜；内阁</strong></td>
</tr>
<tr>
<td align="left"><strong>canteen n.小卖部；临时餐室</strong></td>
<td align="left"><strong>canvas n.粗帆布；一块油画布</strong></td>
<td align="left"><strong>carpet n.地毯，毡毯，毛毯</strong></td>
</tr>
<tr>
<td align="left"><strong>cathedral n.总教堂；大教堂</strong></td>
<td align="left"><strong>cease vi.&amp;vi.&amp;n.停止，停息</strong></td>
<td align="left"><strong>cellar n.地窑，地下室</strong></td>
</tr>
<tr>
<td align="left"><strong>cable n.缆，索；电缆；电报</strong></td>
<td align="left"><strong>cannon n.大炮，火炮；榴弹炮</strong></td>
<td align="left"><strong>canoe n.独木舟，皮艇，划子</strong></td>
</tr>
<tr>
<td align="left"><strong>chalk n.白垩；粉笔 chamber n.会议室；房间；腔</strong></td>
<td align="left"><strong>chill vt. 使变冷 n.寒冷</strong></td>
<td align="left"><strong>chimney n.烟囱，烟筒；玻璃罩</strong></td>
</tr>
<tr>
<td align="left"><strong>chin n.颏，下巴</strong></td>
<td align="left"><strong>chop vt.砍，劈；切细 vi.砍</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>commentary</strong> 评论，注释</td>
<td align="left"><strong>hypothesis</strong> 假说</td>
<td align="left"><strong>prosperous</strong> 繁荣</td>
</tr>
<tr>
<td align="left"><strong>respectful</strong> 恭敬的，有礼貌的</td>
<td align="left"><strong>diplomatic</strong> 外交的，策略的</td>
<td align="left"><strong>lieutenant</strong> 中尉 助理</td>
</tr>
<tr>
<td align="left"><strong>invariably</strong> 总是，不变的</td>
<td align="left"><strong>ultimately</strong> 最后，基本上</td>
<td align="left"><strong>suspicious</strong> 可疑的，多疑的</td>
</tr>
<tr>
<td align="left"><strong>instrument</strong> 乐器，仪器，工具</td>
<td align="left"><strong>indication</strong> 表明</td>
<td align="left"><strong>complicate</strong> 复杂化</td>
</tr>
<tr>
<td align="left"><strong>intensity</strong> 强烈</td>
<td align="left"><strong>cafeteria</strong> 自主餐厅</td>
<td align="left"><strong>identical</strong> 统一的，同样的</td>
</tr>
<tr>
<td align="left"><strong>multitude</strong> 大量，许多</td>
<td align="left"><strong>Wednesday</strong> 星期三</td>
<td align="left"><strong>parameter</strong> 参数</td>
</tr>
<tr>
<td align="left">*<em>formulate *</em>构想，规划</td>
<td align="left">*<em>aeroplane *</em>飞机</td>
<td align="left"><strong>propagate</strong> 繁殖，扩散</td>
</tr>
<tr>
<td align="left">*<em>continent *</em>大陆，欧洲大陆</td>
<td align="left"><strong>ingenious</strong> 灵巧，精巧</td>
<td align="left"><strong>privilege</strong> 特权，优惠</td>
</tr>
<tr>
<td align="left">*<em>correlate *</em>关联</td>
<td align="left"><strong>committee</strong> 委员会</td>
<td align="left"><strong>generator</strong> 发电机，生产者</td>
</tr>
<tr>
<td align="left"><strong>incentive</strong> 动机，刺激</td>
<td align="left"><strong>submarine</strong> 潜艇，海底生物</td>
<td align="left"><strong>patriotic</strong> 爱国的</td>
</tr>
<tr>
<td align="left"><strong>collision</strong> 碰撞冲突</td>
<td align="left"><strong>terminate</strong> 结束，终结，解雇</td>
<td align="left"><strong>cathedral</strong> 大教堂</td>
</tr>
<tr>
<td align="left"><strong>competent</strong> 有能力的</td>
<td align="left"><strong>dictation</strong> 口述</td>
<td align="left"><strong>recollect</strong> 回忆，记起</td>
</tr>
<tr>
<td align="left"><strong>restraint</strong> 抑制克制</td>
<td align="left"><strong>redundant</strong> 多余的，累赘的</td>
<td align="left"><strong>thickness</strong> 浓厚的</td>
</tr>
<tr>
<td align="left"><strong>ventilate</strong> 通风的，公开的</td>
<td align="left"><strong>quotation</strong> 引用，引证</td>
<td align="left"><strong>longitude</strong> 经度纬度</td>
</tr>
<tr>
<td align="left">*<em>regarding *</em>关于，至于</td>
<td align="left"><strong>fascinate</strong> 深深吸引</td>
<td align="left"><strong>versatile</strong> 多才多艺，多技能的</td>
</tr>
<tr>
<td align="left"><strong>indignant</strong> 愤怒的</td>
<td align="left"><strong>variation</strong> 变化</td>
<td align="left"><strong>tentative</strong> 试探的，实验的</td>
</tr>
<tr>
<td align="left">*<em>narrative *</em>记述的，故事</td>
<td align="left">*<em>transient *</em>短暂的，临时的</td>
<td align="left"><strong>surrender</strong> 投降，自首</td>
</tr>
<tr>
<td align="left"><strong>principal</strong> 重要的，主要的，资本的</td>
<td align="left"><strong>speculate</strong> 思索，猜测</td>
<td align="left"><strong>appraisal</strong> 评估，评定</td>
</tr>
<tr>
<td align="left">*<em>magnitude *</em>  巨大的，重大的</td>
<td align="left"><strong>sovereign</strong> 君主，独立的，至高无上的</td>
<td align="left"><strong>synthesis</strong> 综合，合成</td>
</tr>
<tr>
<td align="left"><strong>resonance</strong> 共鸣，反响，共振</td>
<td align="left">*<em>postulate *</em>假定，基本原理</td>
<td align="left"><strong>rehearsal</strong> 排练，彩排，演习，复述</td>
</tr>
<tr>
<td align="left"><strong>partition</strong> 划分，分割，隔离</td>
<td align="left"><strong>intuition</strong> 直觉，直觉力</td>
<td align="left"><strong>miserable</strong> 悲惨的，痛苦的，太少的，卑微的</td>
</tr>
<tr>
<td align="left">*<em>fluctuate *</em>波动，涨落</td>
<td align="left"><strong>Brazilian</strong> 巴西人</td>
<td align="left"><strong>culminate</strong> 结束，告终</td>
</tr>
<tr>
<td align="left">*<em>inventory *</em>货存清单，目录</td>
<td align="left">*<em>undermine *</em>逐渐削弱，暗中破坏</td>
<td align="left"><strong>spectator</strong> 观众，旁观者</td>
</tr>
<tr>
<td align="left"><strong>municipal</strong> 市政的，都市的</td>
<td align="left"><strong>intervene</strong> 出面，介入，插嘴</td>
<td align="left"><strong>reception</strong> 接待，欢迎</td>
</tr>
<tr>
<td align="left"><strong>implement</strong> 实施，执行，落实</td>
<td align="left"><strong>attentive</strong> 注意的，殷勤的</td>
<td align="left"><strong>retention</strong> 保留，记忆力，扣留</td>
</tr>
<tr>
<td align="left"><strong>prevalent</strong> 流行的，普遍存在的</td>
<td align="left"><strong>execution</strong> 处决，实施，表演</td>
<td align="left"><strong>sceptical</strong> 怀疑</td>
</tr>
<tr>
<td align="left">*<em>marvelous  *</em> 不可思议的，非凡的</td>
<td align="left"><strong>remainder</strong> 剩余物，其他人员，廉价出售</td>
<td align="left"><strong>primarily</strong> 首先，首要的</td>
</tr>
<tr>
<td align="left"><strong>evaporate</strong> 蒸发，挥发</td>
<td align="left"><strong>exclusive</strong> 独有的，高档的，排外的</td>
<td align="left"><strong>antarctic</strong> 南极的</td>
</tr>
<tr>
<td align="left">****</td>
<td align="left">*<em>segregate *</em>分开，隔离</td>
<td align="left">*<em>offspring *</em>后代，结果，产物</td>
</tr>
<tr>
<td align="left"><strong>preceding</strong>在先的，前面的</td>
<td align="left"><strong>skeptical</strong> 怀疑的</td>
<td align="left"><strong>reconcile</strong> 和好的，调停</td>
</tr>
<tr>
<td align="left">*<em>synthetic *</em>合成的，人造的</td>
<td align="left">*<em>irregular *</em> 不规则的，无规律的</td>
<td align="left"><strong>dissipate</strong> 驱散，消散</td>
</tr>
<tr>
<td align="left"><strong>stimulate</strong> 刺激</td>
<td align="left"><strong>complaint</strong> 抱怨</td>
<td align="left">*<em>radiation *</em>辐射</td>
</tr>
<tr>
<td align="left"><strong>eccentric</strong> 古怪</td>
<td align="left"><strong>empirical</strong> 经验主义</td>
<td align="left"><strong>fabricate</strong> 编造，制造</td>
</tr>
<tr>
<td align="left">*<em>clockwise *</em>顺时针的</td>
<td align="left"><strong>alert</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*<em>council *</em>委员会</td>
<td align="left">*<em>engage *</em>吸引，参与</td>
<td align="left"><strong>remedy</strong> 治疗，纠正</td>
</tr>
<tr>
<td align="left"><strong>recipe</strong> 食谱，秘诀</td>
<td align="left"><strong>reap</strong> 收割，收获</td>
<td align="left"><strong>religious</strong> 宗教，虔诚</td>
</tr>
<tr>
<td align="left">*<em>Prince *</em>王子</td>
<td align="left">*<em>proposal *</em>提议，建议</td>
<td align="left">*<em>protest *</em>抗议，反对</td>
</tr>
<tr>
<td align="left"><strong>poetry</strong> 诗歌，诗词</td>
<td align="left">*<em>pension *</em>养老金</td>
<td align="left">*<em>persist *</em>坚持，固执</td>
</tr>
<tr>
<td align="left">*<em>neutral *</em>中立的，中性的</td>
<td align="left"><strong>obligation</strong> 义务</td>
<td align="left"><strong>plunge</strong> 插入，陷入</td>
</tr>
<tr>
<td align="left">*<em>nasty *</em>肮脏的，下流的</td>
<td align="left">*<em>nerve *</em>神经，勇气，胆量</td>
<td align="left"><strong>obstacle</strong> 障碍物</td>
</tr>
<tr>
<td align="left">*<em>migrate *</em>迁移，易居</td>
<td align="left">*<em>miserable *</em>悲惨的，痛苦的</td>
<td align="left"><strong>myth</strong> 神话，奇人奇事</td>
</tr>
<tr>
<td align="left"><strong>inevitable</strong> 不可避免的，必然发生的</td>
<td align="left">*<em>jail *</em>监狱，看守所</td>
<td align="left"><strong>miracle</strong> 奇迹</td>
</tr>
<tr>
<td align="left"><strong>immense</strong> 巨大的，极大的</td>
<td align="left"><strong>inquiry</strong> 调查，询问</td>
<td align="left"><strong>intimate</strong> 亲密的，亲近的，私人的</td>
</tr>
<tr>
<td align="left"><strong>heal</strong> 康复，治愈</td>
<td align="left"><strong>grace</strong> 恩泽，恩惠</td>
<td align="left">*<em>forum *</em>论坛，讨论会</td>
</tr>
<tr>
<td align="left">*<em>facilitate *</em>促进，使便利</td>
<td align="left">*<em>fatal *</em>致命的，灾难性的</td>
<td align="left"><strong>enroll</strong> 注册，登记</td>
</tr>
<tr>
<td align="left">*<em>disguise *</em>伪装，掩饰</td>
<td align="left"><strong>evil</strong> 邪恶，有害的</td>
<td align="left">*<em>estate *</em>庄园，住宅</td>
</tr>
<tr>
<td align="left">*<em>cue *</em> 暗示，提示</td>
<td align="left"><strong>digest</strong> 消化</td>
<td align="left"><strong>compensate</strong> 补偿，赔偿</td>
</tr>
<tr>
<td align="left"><strong>trail</strong> 踪迹，小路</td>
<td align="left">*<em>spill *</em> 溢出，蜂拥而至</td>
<td align="left"><strong>perceive</strong> 意识到，察觉</td>
</tr>
<tr>
<td align="left">*<em>mission *</em>代表团，使命</td>
<td align="left"><strong>induce</strong> 引诱，劝说</td>
<td align="left">*<em>feasible *</em>可行的</td>
</tr>
<tr>
<td align="left">*<em>excursion *</em>短途旅行</td>
<td align="left"><strong>cling</strong> 抓紧，坚持</td>
<td align="left">*<em>hinder *</em>阻碍，障碍</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>exert 运用，施加</th>
<th>derive 起源于</th>
<th>component 组成</th>
</tr>
</thead>
<tbody><tr>
<td>*<em>enhance *</em>提高，提升</td>
<td>*<em>preserve *</em>保护，保持</td>
<td>*<em>revenue *</em>税收，财政收入，收益</td>
</tr>
<tr>
<td>*<em>strategy *</em>策略，部署</td>
<td><strong>whereas</strong> 然而</td>
<td>*<em>tension *</em>紧张，气氛，焦虑</td>
</tr>
<tr>
<td>*<em>prompt *</em>敏捷的</td>
<td><strong>collapse</strong> 崩塌，瓦解</td>
<td><strong>assign</strong> 指派，给予</td>
</tr>
<tr>
<td><strong>sigh</strong>  叹气，悲鸣</td>
<td><strong>sign</strong> 招牌，签字</td>
<td><strong>clue</strong> 线索，提示</td>
</tr>
<tr>
<td><strong>extreme</strong> 极端的，偏激的</td>
<td>retail 零售</td>
<td>scarce 缺乏，稀少的</td>
</tr>
<tr>
<td>scratch 抓，挠</td>
<td>semester 一学期</td>
<td>shed 流泪， 庇护所</td>
</tr>
<tr>
<td>slippery 油滑的，不可靠的</td>
<td>spite 怨恨，憎恨</td>
<td>terminal 学期的，期末的</td>
</tr>
<tr>
<td>tender  嫩的，温柔呃</td>
<td>sway 摆动，摇摆</td>
<td>suspect 怀疑</td>
</tr>
<tr>
<td>territory 领土，领地</td>
<td>therapy 治疗，心理治疗</td>
<td>thrive 兴旺繁荣</td>
</tr>
<tr>
<td>trace 踪迹，痕迹</td>
<td>tremendous 巨大的，极好的</td>
<td>utility 有用的，实用的</td>
</tr>
<tr>
<td>utter 彻底的，完全的</td>
<td>victim 牺牲品，受害者</td>
<td>backup 备用品</td>
</tr>
<tr>
<td>beverage 饮料🥤</td>
<td>bible 圣经</td>
<td>caption 说明文字，字幕</td>
</tr>
<tr>
<td>bubble 泡沫，冒泡</td>
<td>bucket 桶</td>
<td>bundle 大量，成批，一束，一批</td>
</tr>
<tr>
<td>cabinet 文件柜，储藏柜</td>
<td>carriage 马车，客厢</td>
<td>collective 集体，共同</td>
</tr>
<tr>
<td>combat 战斗，殴斗，防止，抑制</td>
<td>commitment 委托，承担</td>
<td>consent 同意 ，赞成</td>
</tr>
<tr>
<td>confirmation 证明，证实</td>
<td>compound 化合物，复合物</td>
<td>commodity 商品</td>
</tr>
<tr>
<td>composition 构成，组成，作品</td>
<td>intensive 集中的，加强的 密集的</td>
<td>inferior 下等的，下级的</td>
</tr>
<tr>
<td>inflation 通货膨胀</td>
<td>virtue 美德，善</td>
<td>vigorous 有力的，精力旺盛的</td>
</tr>
<tr>
<td>wholly 完全的</td>
<td>surge 飞涨，涌起，激增</td>
<td>subtract 减掉，减去</td>
</tr>
<tr>
<td>tangible 可触碰的，可感知的，确实的</td>
<td>tendency 趋向，趋势</td>
<td>thrust 挤，戳，插，要点，宗旨</td>
</tr>
<tr>
<td>torture 拷问 折磨</td>
<td>trash 垃圾 废物 破坏</td>
<td>triumph 胜利</td>
</tr>
<tr>
<td>ultimate 最终，最糟糕的，最出色的</td>
<td>undermine 侵蚀，暗中破坏</td>
<td>upright 垂直的，正直的</td>
</tr>
<tr>
<td>vacuum 真空，隔绝的</td>
<td>vanish 消失，绝迹</td>
<td>verify 证明，核实</td>
</tr>
<tr>
<td>versus 以……为对手，做对比</td>
<td>stir 激发，搅拌，激动</td>
<td>stiff 僵硬的，酸痛的</td>
</tr>
<tr>
<td>sticky 粘的 困难的 湿热的</td>
<td>stem 阻止，堵住</td>
<td>stale 没有心意的，乏味的</td>
</tr>
<tr>
<td>stake 桩，冒险</td>
<td>spray 喷射</td>
<td>sphere 球，球体，范围</td>
</tr>
<tr>
<td>speculate 推测</td>
<td>specimen 标本，样本</td>
<td>soak 浸泡</td>
</tr>
<tr>
<td>initivative 主动性</td>
<td>snack 小吃，点心</td>
<td>infrastructure 基础设施，基础建筑</td>
</tr>
<tr>
<td>situate 使坐落于</td>
<td>seminar 研讨会</td>
<td>segment 部分，分割</td>
</tr>
<tr>
<td>script 原稿，剧本</td>
<td>saint 圣徒，圣人</td>
<td>saddle 马鞍，使承担任务</td>
</tr>
<tr>
<td>rural 农村的，乡村的</td>
<td>reservoir 水库，蓄水池，存储</td>
<td>instant 立刻，立即</td>
</tr>
<tr>
<td>retreat 撤退</td>
<td>rod 杆子，棒子</td>
<td>renovate 修复，修整</td>
</tr>
<tr>
<td>religion 宗教，信仰</td>
<td>refusal 拒绝</td>
<td>reckon 估算，认为</td>
</tr>
<tr>
<td>reception 接待，迎接</td>
<td>rack 架子，使痛苦</td>
<td>profile 轮廓，外形，形象</td>
</tr>
<tr>
<td>punishmet 惩罚，处罚，虐待</td>
<td>pitch 投球，使跌倒</td>
<td>phase 阶段，时期</td>
</tr>
<tr>
<td>perception 观念，看法</td>
<td>invade 入侵 侵略</td>
<td>penetrate 穿过，看</td>
</tr>
<tr>
<td>pave 铺路</td>
<td>panic 恐慌的，慌乱的</td>
<td>owing 应付的，未付的</td>
</tr>
<tr>
<td>oven 烤箱，烤炉</td>
<td>mode 款式，风格</td>
<td>melt 融化的，逐渐消失</td>
</tr>
<tr>
<td>manipulate 操纵，控制，影响</td>
<td>lane  乡下小路，车道</td>
<td>intangible 无形的</td>
</tr>
<tr>
<td>intact 完好无缺的</td>
<td>instant 立刻的</td>
<td>intensify 使加强，使加剧</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>记录生活，感想，还有你……</title>
    <url>/2021/08/26/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%84%9F%E6%83%B3%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BD%A0%E2%80%A6%E2%80%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f7993b5b942246a70f2abcb18987238f30cd2f2094736c7f0136dd61a68d476b">10d79030e8222445804370796b90fca148aa6855d970246f117c47b7ad826a66ce89e3ee11d0afd98fd826766b0ee88d8730894cf65b821c280b3877a82cf6f394bb52b66f57723f1b91b26e135ca5dbf2bcc0fc326d4115b72042906e6e7e267d17a789d8bc5cab976b71fd9d5f56668288b2777bf33c79a6d3853ecbaaa1dc4a2a81ad1d8dfc2e1163b5f2f0f029c1f6cb9f1d6ffc20fa4a075d356ccd788a28de8652f2e668b0b9284c7c9c96919b2a2e70e43cf394e11727b8247abc938729e1665f696b3d6a309c2eef07eca9a163d3303bda045765cadef51ee09b026e52ae691a98d61447d165020f8a0c8124982d8ec947b89c6c12ffcebd94808ed1f34bf19b06a5a2c2afc393a0eaa0a90603fbb3a609d82aa4b94614ca0b861240c6cbb81dc2fc827369fa38f345614ac219e5f6624041239a3a650104f9c8cf8caa0aebbdd406c3dfd0846e0acd53b7d51ac5be84072bd9dcad9fda6cc27c30771a7d45e486c0ff9c621ab8135d20cffbfe6b7865506b85d4e06860f29e1c616a0c6a566414eaf3479f40a50b085611d778e51453b014c4ac1b45a9c05e786fe7153f360d35bdd821dec7ae9829f9a6420593d64e78220b8796abc013a85d6832c8143d93dce7d260f714564d882b124edf2366ed13c0cd7009fa28aae571452aff020d38aec910befb3970809c936c556b471ff561b8b4708bd4432ccf954a4144ece82afc67868d71ace71bf13728b96bd5ac4335657abf3353ec8f60354105802227881bb40e81a3a75e1a4c42af08a7dd82872a9aebc49fb9f16dec25ebcf4febb9e532ffc2e5fc2f681415074773df420815f11e2c63a0747f6f49153baf8372e47e370048abf92b53c8905d841bccf44a479d30fbfa4bad9153fc8326eae6b8510c363703efd0f98a23ba311c8990d41834205d32af86c74a739a79c22034c74bbc6b185443f7ee832bfb29e46b111d44544cab2bee015a8be67c7a513348f4e30f9ae0cdcebbef0c60c0ab30879ae6c86a17b66322f6fa48cd1e61e980b041529adcbfd845d3cf8cdd535b68a64266360154c9481f48c219b094192db28959c322a7507e5c44217f6f4a42ead026419b4719a5f6940b6ad8908bc3a3ad5987704b8e71d3e47a4c1e38c4a743b42f4796a5ac32310b66699a8d4f1aa618260a14f1a9ff5ecdb741aaa02ac1571aaeea11fd245024e21e2daea19eff6b1c1d3cceb8cae25243aab1113d300ac0263ca104abb7cfe913b414a5463a7dcd18959f3ecbdaf38bfba0099a28f5b80df2754d1ba4aae88745b4d37076597ec58d92cec96ce289c3a601ad5f01f10f7b8a83def9adc062612ed4247d04c32aec6d152bfc8336fb2a69d77d0b73472576a890a6b9ec306428880e2e933ac17df7c7bc72bf71bde582897bb826b6fe7c61562cdaaf4a605300f1417b4c1c24229a37af699e8c518b2998fdc95360c8563cd7d9b820dbeef9d25a0610185d5b2d982a98f75202b702aea00e53b82029465d0b2153919648646b6a22003c0478acbf1ddfdad24d5de2e4c67c8506d5b32554e2e46d1282b455c1eb305153fa5c56a0eefbfbb74c3e46cc89f6cfa23cfe32f6cbc63ff0b730db47aef248e5b9e87937cc4aca6960740257e000bf7dd7a6c1614f2d22b6c74aeb85420af37a183ecb4a0d1839fed1c861c373f8b5c118791aa357b0f67353cbc80faac1cf59db417f5a0ccf435eeb7b888e11bf0adfcc6582d9e1d95c25d0e3939b089af72d1e8e903cb9d9d6202f590425e93bbc370a43521501237a10cab52545a2f8a08f9f3e1692815795ed53e97761a1cc8a8974756c810705327bf9ccfca30bc649ac685614303ad1bd68c0c805b6a0e5693d7844cf1f4f742b260f0c7c14d51141707b474ddf4857a0aa8292490d7a6677b59114ebbdefe99ac2feddf92c7ebfe1b7fe594d2b3934118f2d4aa547417c8dc62998ce22f8207b0c186c578b13e05f6a768e838ab42a32c5123308699d9d1ad2d3608e42bdc09e903c0c1f75a94150a3e66f1b7a8a734a71ecf67672f2a1c7406c214000e7b70f42e7bd8f5691c2a823edce9f2f8b1b63a6ec748da403324055c61aeb89d7754a113941d7126f9ecd1a8c86f08a8cd349c19af9a7be1b9acb82dc43b8a8267b65c38cc83ec5fdbd4a393b358bf151a3ffb25186becee232241b2e41450bfddb782762046b4fe3980cfbcb3d1bb626567e77b45cb17d97545f9a3201364697696ac4cc551a3673b45f85b74c0bcf27a5beaaa8c645d0dd05e6933daef96326ccc8a90498c0d69c25d0fefb97ac5670def1ea6c0f80385dba26bd39eaf30c1294e6d136dc06943d71ccdc8fca958b248d25c314533c211896dfb13491d9d3442794c9528fbd7ba0509afe7a26a2d68910f6a37d3bd66dcb28d94fe85250349c95c501232613b3b3a1a9bf9e6732cddf640ab2db0d3e9abeb1293eb05f22fb62ebeb7e41d9c425229211d2f40eb4b0418a50919c8e80473b8fbbcb29068cc595968cc98d2334e97827d594ed23ce0f43edf003fa7c1f8621912b1016c60f091d70f50a4af32b0e6624a9aa72f0b14a0d38cdc6aa64f38e6a05eaeffab6cc34071f037dc52771963f70ee8f3635068b65373e116a146b76c3b0060a9329dddc5c8a52cec5a441303cbfdad5c0d7a194242cef58eafca84ba4d63941ad0c338c8277f02db6c999fa0ecc4f7880565d879b18abb7cff6ca590612de3ed88cbdf7d8109533ffa860ea0013a1eed56c89722ec985618593c4f4c21a087423b3e6fdad78208de00daced2217dcc229d46f1970e6e846e5f92e973ef53bee1df2cadecdaceb6b63f4c7f1d5f19b3aaeee72dae0536959dea24426516198545504c21679126ee98bfd14f1c26fa89490ea2c55ee5ab1bc9b95d869dfd1da754f24c5585ef6170c2d5fed2680258e4df93a0b177b5473eaa9811349bcdc8e4878b7ba388869a9d8514b82da37935c62e3a7588cebe04abc56ba4e904692938b9be0e7dff322431c49c35827b0cd691e094e29b2093ded354cec482431e795ff50bbc062aa86aa495edd20a7014c10b776915397dcb5c667222a6725d1b272874920b112ac7a21677ad005c85bb72f15388a92f6f9de3fad289f400f8088c104c0d25f837b09aab58b0c625f28cfc5e0b8b2c9001b4506a5193212a1b3af007e389055716acac213bdb0294b50b685fa6f5057a335e548a257d7beab5431a46d84d3304bbb2d2a655a445beb5a506f1d55b8fda321c8de1e2d1b7cc785d6bfc409fa1e7d4fef716379a5cc2130ac9ff5096d69a2209aef508cf94407ac5df1d36c7cdcb646253d441778a95e4d67009184dcf7a9a372c460b35a2fc3c73fd3f1772506099893e25e5baf8fc829a1e5372b2915f658d72bf985540e72e25a0d65a6ae886753ca138b43b52bfa8a6b88346dea6a774d38ab71b3eed9585f9f0ed1fe7177eaf72a623cec1cf443e1f78818729603685624a2b20291c7b1b140dfa6de363abf0c6d806e8d53bfe4ab68f26c7587060c1bbd58546e295a4c7a4fea54cbdd306f6e4391930a5ab07db045a58fc22da5ce0d6d5dac555e20e79d22ec5f87a31d9b14fff6611292c469cf55819aa7d77721379aa5efe45504c2be0a26f43958bc84fe84760e79320d969b8d955c047c60bc2aa630c1d6dc6f5c932f11e2c510f7ac4442a0a042cb92606d95f6f03f036d641ae94f30330e9d63ddc9e80230da07ddc6ea29809f51fdaded940a2e44f94326c662e5d4c514c6c46d76dac46390cf75857cadd7a006f163be21aee32127044469444d261f36c98981fdf36406fffaa1794782c93aada601c3355429273ebd67419cdd122f9d15c0c55f0faa53fddb8413f29f2fd639cefc6a303fe611a73880c9181ac726027fe7b35e1fa00eeba831c8c6fe868c8f74fb124b04d649ae7e5ec5500e8f650da2a8b03453102c16aa8432c95f908ccbe4d3f0e60f14e1d949464a7d7eee193c6acb3d7b651be65ddef64637a797344ef7215c2ded896bebc85c12262a4a656649a215be2b768ac03332f51fb6729653b3903a6aafaa34cf67af20d11d689642dba884eb5c521699194562ee61e51f1bf496729cc67b4f8a6eb5793c9d3a7e1e49482693f20eae0a4a55b73cb0e2a98155b80ff029f31b936c41d0ef623573fbaef9c30211ada056f8805428d581800fae0e8ac9df34e4723a930f68602a3abbeb3c7496a34b020732dd412633c8ddead208284c8c9d1356151258a1ab9daa264de029e22735ff596e6f6b8cfe563903bfd6e4a1329b1d774f01e9bac7c148ba5218247a895b7b8572791651b28b4cd12d553c52f1bd0c37cf94df1f3987df7fc54994acb0fc0ac142ba2a8e7f351651f71195721c87e881de975720948dfa1e140db22b2e049ae97d4a019682dfde2187a1d13c3ae9cbc3395e961758f40b926198935759971a7b82e1f6f059263437e59b8c2f7861c9ffe469f97b8db57ba56dad74b0555871d7fcd97b11a94845fe78863c5d4b6efe4108161f08315dbf83695428c152aaf1ebc5fbc7b404192ad949b5f7f0620e48ce4bd16b5ee751a96953e70c25e38c6f167f6bd3bef35d1c2915248b709442e6602a0eca1226b594e24d7207aa327b0408e14b9801da9ebab53fc7524d07f0c4e38aa6ba7b0ea18cbf31a6a28dd7522bd0c055d8de971de1be1bad1a01fa52fdaa55ec7503a0e79147461b8527842883257c692c7da102f4387a2983024a8ac568ca4d0d133ab2fd4d0faf5c346dadb27d581ce8812ebf5094f977a9be34881df68a6af016a89e56da7ac62967f07f3e792bb097382293dff55277764edd3838d8361b90b2f1b3ac72b7e2c96a75fbef983cc6accc1a142b9ddab3c3a193215006df53a2bb0786250d6ffce971c9c66ee9bcdf8f5862a490a6a80a513d58dc8f8aa6cd8f9607cd69fc7c88236d07a6bb80a16e2dfda48cbc1d23de41ec04d90f7ede20daec005c8bac5f7cc4b40be51d17232679c86d1350a84b0a780e34cc20b5dd91ff7ac9cf156386fa49da98def1cc3e31a1adb811cdfa98b1ba6f5f722ea1f249cc3d842637e3ee290634070b90d7c57382b7303e2ce7b3dae81dc66c1244f0ea2f0d10e5e20df0406beb86f838a927a2658061c136335b5308a47c83bcf1eb83463ef0c0d72efb4d1055946287141dfc8e82e351ab03dec941619a7a90f4288625f0cec28e423bf9d247769772a2bd8ff96eba1c59ec700e4503aad3b324f0d00455ff31f48fca36dbf99c73c27959ba49c5a1c8204c1634673a830e43b81dea079242500abf7dfb05a0a8d2c9e26cbbdabfa72993668f6e6dd5345080c500ee3c1f71c247a6c1e7cc2761410186238a696f21adda2ef80c53f41aeec853e860e5a66a7caca5a9e736290d7f712930e6784d9c4a238626dcbb6dd2f3c747588e178cc2cafcdec14e272264c078f306fc7ccc0101aaf00e263d71213fc1d04378cfb04a492177fce273d5230b758cf5fe64268e2d99c3137462247da8781274a9f6cff160d32b0738ebd03c6c3c274b670715d5c1e9a9752aff27889e8011d8255c60f1f53c7806d00b24abbe8c700cd2f329df60323adc439312cb779d4f2e4f839ea2f8b635d575cdea7a0c5e716e7dcc888a52bd8cf4728dd30167f681fcc46579efade51478fe5b6ba13112d9b5e3aaa37e28eda90d197fc023fdb5656ae62a9fb699afc5568b192d494f199c7cf08b6b700152cdd1024730a21d223b4a6b70d99b75c4149d266a70c300fbf65830da664b16d19964d5b34fa761af223c280324218b16bf5199e1c45f562407b4de54f9f5e6b7999a26cfc8a3b20abc0bab827c30ce3d602fe3960386ab3b1101962e585843b09a2461b7bba9f4537a240960b20b8cfc664acf2b18d7023f1eb1354f12e7a920c6b87765a58bb67128ad1084857fd7d24830d538b5cf14b1ed7849de5f332fc2715efcff05eee55eccde8707de5bace149f09d40516c38aba060227446f5ef736f53a3f185bb5761564f40b56eabb3daf708f2a664efb200b11b5c0773c1887a3f9d02cfb2114a5cf4ceef3208c0a72e27e0ee1c1971a57444562f6128bc2e1128feff882a05c5fe0930e6cb26fcb3504cbfdb77bf239e8cf0614fd5e98ff284ef7d163bb9879025e5b2d4d9795c640fe11f64603a5c93f3a88408057ad3e97f49d9d84d3cbcbd2d1a064f4723d2ea92bf84f86a1b81014d4992715cb21b682f7129033c2d684054a3857d35a863506f4fb5f12102ba90779ded6c39690214ad7c810a3cb7e2f96874354aa911206bfdaf38956a09473a93efc128d2f96c431f8c49926d3d8d3ec10de8ef8a38781d01afa2f3167208dec674da1bfe5903963e14769905165cdb68b29a440096a82c365be51df25afd1a9846f1a16caa1bf7b0e1d7675d782a4325f6d7ae005c3068a9cab5d6e041c5a06df75e2fda8ea7d8194c2c50a118835ac4f3cf1f92a04c41ee994a76c89a194e9306d6a5addb5cbebcd375905da520ede82b644d4ca0171540af427c323d633bf6ddf01fdd2e720a057566e258ee799cb9b04311a8614f290b456214b2fa5a8bdf826bbc31dd6fe8ca0c37fa37cc9c601609237e1f0c20b9b0dbbf7bc059fa898c7abfbfc96dd6f94f0467f780e0dfa0bca122e8b15b3b0218ff15e9c55e1b233be713c6d673828d7df8b5cc9688aec25103419373c057d7896c78b830207cf15119859a4d3581d635193ebf5fb6fd24dd40dab56d5642fd5c54d7a9cfec2f5aa78ee94c135ff26028e814f9f95b3ae31677154970edfb8f6c7430e8ffd53e72c1d67e509a258c4795cc1e018a54a078c2a08b5ce45a02d6c38d1d31ee557e56c74b176109032702b20b2189bf9706fd351fcdeb7dde47e45c7a1b357771b2377149d35f466cdb575256bd5d109843c6d9d9b3c88cec548240b1d4a066407db6ea4e0d8c7c3355c19efca7d3019077b414f35efaf472d8252049e455f8ec36463b29641d45c1967d495ab515600e31ec8fe5d34d0f55cdbea5e6236261bb327876c7223142b6bf2510e52eeb0c00380ef65c26d7ce9b151086ceaf888fae19dff7c6f0f626593c77025d442ea5954f3394c71513ca5b48945578853b82d8c747683cb4a1e8e581ba85ae566f1cee4c93a80b0b2508595ddb3df8bf533b3022d2b236b165e0643ff11e79dae4fe3e4c845e45777aa7be80727d4fff5f216beafb126626f6905928012b22ed73cdfbb0893522f886a9cd684afb037fc51744d9cf054e7d0c5fc209ac87c5d18e1f4dabdd5509154cbb93526fc7982d07e9a50c764c13f54686fdd425db7727cd0d9184e11d8c63cd04d06bc35bcc315daae21b515639f605e0c795865fc2cae3331c84e2cd8487a4153cd460592fe9f89151aba03dde96926e2e73626c6e6fbe8df0d228fc002e3b3bb45849d8246b3696e3c1e7dce47b1a03792d9bb9224b7b200523f4065ea733ebb33180cfc2d5d0bee2cb93fc96e7a1b7880f616fd976d78bd649152ac632e7294342a3b3f5d0f80a54ba9c8b7fcda98c12bdc8eed92338f2b0cbac9e539e61d6cfdfbbf929d8cf1149479dfa05ea7b05d39b622f05ab13004c9ed4bb61225f9189a658387324db5bdda72b0e8f3ad171c90f4dc39c90c521261670f6bdaba381c84a1430920376a1b53304ec91071f021e866a0ce77353fe29e78ec61c7bc8cf71723b3396a4e7a275fe1efadb237ffdc938c99de5e3f1779ca0edd17031ec44c5b25ab3b71a0b30a904d121cf91e103069e10dc656845606a4f67ea45fe45f7c01f98b3705bbf1cf06502054f452d9e4563494e9e28664098c6912e9bfed398653719d48c221c1a1330614a051ce8578f4fd6fb67d81f1f2966acc2ad656dc031460b32bb9bbc9b5ecf188145a28c4e1a2c7179c62ee539dc376e2928e08ce467e9895318122f4fd3c31e12ea7fe5c07fedcf4ea120c5f4d3c98b88fe2f0837b57186b7d92ce0bb9f5156ee95eaa34fc47815480165c36898d1f0c004ea2df9e3dd19d24f5741fd68198804babb52ce8220f669988db5e70138428e2456247ee9b7ba2ba6be97333c78ad444e7262ab28e5e78fe6bea8a07684b47d3531de2db8fb39fe6c4844b5a063b836ed0d62f6a9c42b5308d9955e2fb4636b13d69f490b2a3b53303626eebf4e20e96daef2a96885d724b95bf0d1cfdc73d180ed1377c6881b75d09b1642097f9c17ce6854e5d5984e7426c546aa373a77043e4f9b1c9dab54399669495e6c19bb4b3a8d7f412169c5f77f88bdc32c96f222dae5c131b98aabdc748309a7f700cfe4f65561526fbae30742a3516b5b875dd29a1915c93ce48134d590ace80080d3ee6bbe86a8de58cb9487dfd5a7497e1d1438d95c8dd273538e2ba2a78dbc7bdcc8918a78d9f30a6be25eda32fc458c901fb9a3024206dd80f21b2415e12a1302cfefb1084b34117196c5115a53e51d45ad58ce4d57e1a52d2fe7d751a1abe9c4046092d5e3488fb888895c5d143e8887416d4986aba2472c6a4a0fbf58639cc9f5904e5ac397fdd4551a5679d75e34fb6b310be6039ecd6b8f4f0179d8960802036e8f0b1707d2cbc3abbfdff134bf69229bdaad70fb5b871f26b46c296d9d3189b1573dc25e60ecb90a439f7da856f76dc0e8c20ce8fd507271fea7ed77ef14f006692d2fb68b6989c369ff439d25b58405654761fc6715cb4b353522d390b1959de13e241665655c5ab2a042f1f306bf1e01ccf309dfaf79cce6b5fb397c5909e5fbafab8eda22ec591173def15dc852493075dae4348364a1513be208db0e217d5798c0994b03d8acdc1c42ba53bd56df872e9aeb011cecd3f171286113b5714d7c64a669dca9e022e9d7e68774d51547ff7c692d7326ff3cd197a63454c21bb56ba1430c071432c8e08b435de67dc49d8640cb254210056cb94e73546ddf88b3bba09c2bddcbc25dfc6831af41e96fe8c2b817a41bd1af958e8e674b5e9551954706ebc267a94ba0725b84c4d79b969ec1a6a63d800e80f5de047a6421c7c7a8113bd00a4b13b40e5d8e854fac3e8b017c854c0d0eca881c2b43b74124d8a0a9978188264f356729092665e93233324d6fe275d17c2d617a37fe58b6f50b4f9e34d4d3c037d14f8ce9ce902dae29d9c5ff8749359bcb26e15b4a49dd2b7a08ce77e3f5b6f62839669ff668b7b91a438c943e4da302c792f6a7ac391757378a1383d64071b277c0fc3658555b53739ead31f613a1eaf7ca3e937651ad608f8d56fa472414422d379806a8a4ff146cb8547acc6f2d32b247e7e916e68e5dfbe5e5595cbdbebd13fdc0ca542c895e78438519bf7a53b6e0d9cd2c488f81457381fa261006fc69945bc66823d21802e22687393f507daa17655bf5e15bb1c01d1a9688a727ade0c669d48815cdd44be1fd59020b4799f84fc45e944af3bec7ed464e55f99016edb47a5d89746dfe3f572096c9747dc63d0dca5a3e01274c158cb6d18d64426ebcc38099b2143dc0ca8054a406863a0cdc202ef550d165fa9576176169f20818bd7f0c4aeddf1c103b324f701e03a499a0f87b2001512610f1385b405bc11d9a1e0da8e8472861fbce9f64bec4c07831429c06643bd11acf1fa67b718255eba77e55647750a38bc2d842f07f1eee43b74bd84177b69d2b22cd78654f668c550352309510f1513d629957b1cf676588b249bc234735fb00675d4b453f6b707ab4eb4e759c59ba15324307621045faacc34cf4b6ca6b4e8d1d2f5024915b3ef29b5aaac82a458dee08797fecf3caaab3ce51ab4f5a080156fc5e694e6b1578bbcefd79c35c9f0d5b09e39421fc47461a621dc017c05b184c90fcd24c8a09bd5a47f6ac793755d3bde2cccaa1723fec6d57665b3a89329e305b76b20928a2433ae2589eaf3460e1c731437ac63ea2e72d9cec1452d92a79e4448bcd6211189d8eadb2ef42b3d5256a769b6aaccc73e7ac7797ee31478a48347c0742ce2b9911c8593b03eda7044999598eb42ca603aed7e3b0a960145ba841e015fb25255fa312e691c0a301728afbbe9cad191b6ac71173a4933aae9d691ecaba44a9772aedc53cbfd36059fb213bc355771e84320eb74f413e5873c7a8b07de826723496387698ecfe36a532d038290fd079bc82e14dea1be0958457d1e27daf3efa7e0bbe7cd646722d13d4c6920abd52cea489cf993e24fbada422f9097ae8c6cc10d815e18a96261c06fb9623fa6fd0bf3ee60fcdc1c6678fad4fe537dbcbb022065978d503e8a1d00a82e6fc066568698c40a06c26298f3aae3c9356abf83343ab3d7ef87ba98a05f7d3b0a64f1ddd856ed98e9ed559734dd78cf9a4e5d34b246a7c560fdf70074682eb419d20b30a997d9ba6744327c730307080f064bb99a731a24a2cfce811f56bf5f3241256616534065a9f31498b1d2b0a204f4b7f3581cb9db9b6781541a4fe2b0606c5782c32550534849ae0c062e3926ec03b9cf8114939417b44da5fccf3b03ee406d76a5089ccab397bf24720a1bdd92c3b2bfe468289d06ca151e13b5d2c9727ee42282e35ea52d22e91d364d658611e024d29d796bdbe1448e6412378022e7a740b7903e4e244f8d1732daa40edc90b1934a2b632179016080b6ede602662f16b4b17e5923fe6b9e0ce952915de51128712662f4e64f44e24b35140f3463bfe6690dadeacac1f80214728b65be781676150a05de876bd2704e63df66fbb15f88c48b616987bd3674f7d44ed999d4cb008611ef196b0956388c8cb9a5a32223a3d32fec28f95533756be39650d89c16c220967bf1fb9dc7a2f91c801c0ea41cc020398b48d10f2724da67cc0f44a759f1f26550cefa3d7f9fde848cacc86149d5ea2d1f47ba9b3738beff8ee9bc55955710bcc5189ab517c787d15e9661de548c815d689f33d24b9defbcc1dddebcc495f758a7601d5a78447ed26bab973680d5fbd41adeec50bdb614a2727980a2fd481e866b79e7df8ba3df30d583f07c292e03995dab6eef4b7da7e1b65dad5aae2dd4062e422fa45abc5c7787854b78566773c9d94df6228023c563c57d3e22efccc32f6da97b646a1ec4271b368e82e199a70696491e425325025c35c7fce8315e552d537b2b2d15b11b6c7a7e092dd14097b89c1bdf37cfcf4c3e32bc337ddd6ee56a982c8d03241200bac7831fac2faaec38776c86456bb1b9fd84c563df27713ba6e92d44f1699b6f4bbfa151c2f6ec18c1abc9cbb31cde24cab479561d1c3ea62edc11443a08747d1acf867f7ea22e576c6ea3a6ae5ca0cc32da6aefb39447fd7509003e041b4f54b1ac622614846a4971c868927b1186bcba77425abb3a93d70e27a3ee67900a36cc88090cd95e98ef12e17326dff56ccdabf0935b6c090adbc80e1f3ae3750bc9399f7ea426fa08f2a573a5aae47bbaa79641a860c7fc6cc9d52d2d4e9783da7401a725330808fde92bab87023f2b8f602407f143e9b290f11d809909def7e586cf46f6eb9d432b7b15e979fb6a41b4414b828253f302479f86cd189fb3f87a4583ec6de6362b34aa563694988b9811652e8d0e0fbb08464c6640e07be8079d2044525fe8bb6d3906bf89391f903eda13c67340d5116e1f6788597800f701a7a5122fc0bf144b788641ea083d4fcdf9a0cfabbb85051b022c5ecea6319d79ed297faa28533a078f4cf07236ed387ff44c11b94631d49fe8a24145b50e299f38f61cb0b7bca5e9fd2801710d12f8f396e947321cfcafeb6c4f6d4bde78a06603a11b64adb51f8dedd838c72071a5843</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理笔记</title>
    <url>/2021/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>吞吐量：<br>    表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S）。</p>
<p>响应时间：<br>    表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。</p>
<p>利用率 ：<br>    表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。</p>
<p>处理机字长：<br>    指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位，字长越长，表示计算的精度越高。</p>
<p>总线宽度：<br>    一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。 </p>
<p>存储器容量：<br>    存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。</p>
<p>存储器带宽：<br>    存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。</p>
<p>主频/时钟周期：<br>    CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是 MHz（兆赫兹）、GHz（吉赫兹）。例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。 </p>
<p>CPU时钟周期（T）：<br>    主频的倒数，即 T = 1/f ，度量单位是微秒，纳秒。</p>
<p>CPU执行时间：<br>    CPU执行一段程序所占用的CPU时间，CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周期长。</p>
<p>CPI（每条指令周期数）：<br>    表示每条指令周期数，即执行一条指令所需的平均时钟周期数。用下式计算：<br>    CPI = 执行某段程序所需的CPU时钟周期数 / 该程序包含的指令条数。</p>
<p>MIPS（每秒百万次指令数）：单位时间内的执行指令数<br>     MIPS = 指令条数 / （程序执行时间x10<sup>6</sup>）= 时钟频数 / (CPI x 10<sup>6</sup>)</p>
<p>程序执行时间 Te = 指令条数 /  (MIPSx10<sup>6</sup>)</p>
<p>MFLOPS：每秒百万次浮点数操作次数<br>    MFLOPS = (程序中的浮点数操作次数) / (程序执行时间x10<sup>6</sup>)</p>
<h2 id="第一章习题AND答案"><a href="#第一章习题AND答案" class="headerlink" title="第一章习题AND答案"></a>第一章习题AND答案</h2><p><strong>比较数字计算机和模拟计算机的特点</strong><br>    模拟计算机：数值由连续量表示，运算过程是连续的；<br>    数字计算机：由离散量来表示，运算按位进行；</p>
<p><strong>数字计算机如何分类，分类依据是？</strong><br>    分类分成<strong>专用计算机</strong>和<strong>通用计算机</strong>。<strong>通用计算机分为</strong>巨型机，大型机，小型机，微型机，单片机；<strong>分类依据</strong>：通用和专用是按照计算机的效率，速度，价格，运行的经济性和适应性来划分的；<strong>通用计算机的分类依据是</strong>：体积，简易型，功能损耗，性能指标，数据存储容量，指令系统规模和机器价格；</p>
<p><strong>冯·诺依曼计算机的主要设计思想是什么？主要包括哪些主要部分？</strong><br>    <strong>主要设计思想</strong>：存储程序和程序控制。<br>    程序控制：控制器顺序执行存储的程序，按照指令功能控制全机协调完成运算任务。<br>    存储程序：将解题的程序（指令集）存放在存储器中。<br>    <strong>主要组成部分</strong>：控制器，运算器，存储器，输入设备，输出设备。    </p>
<p><strong>什么是存储容量，单位地址，数据字，指令字</strong><br>    <strong>存储容量</strong>：指的是存储器可以容纳的二进制信息的数量，通常用单位KB，MB，GB来度量，存储容量越大，表示计算机存储的信息越多，反应的计算机存储空间的大小。<br>    <strong>单元地址</strong>：简称地址，在存储器中每一个存储单元都有唯一的地址编号，称为单元地址。<br>    <strong>数据字</strong>：如果计算机字是运算操作的对象，即该对象就是要处理的数据，简称数据字。<br>    <strong>指令字</strong>：若某计算机字代表一条指令或者是指令的一部分，则称指令字。</p>
<p><strong>什么是指令，程序</strong><br>    <strong>指令</strong>：计算机所执行的每一个基本的操作。<br>    <strong>程序</strong>：解决某一问题的一串指令序列称为该问题的计算程序，简称程序。    </p>
<p><strong>指令和数据存放在内存中，计算机如何区分它们是指令还是数据？</strong><br>    一般来说，在取指周期从存储器读出的信息是指令信息；在执行周期中从存储器读出的信息是数据信息。</p>
<p><strong>什么是内存，外存，CPU，接口，简述其功能</strong><br>    <strong>内存</strong>：一般由半导体存储器构成，装在底版上，可直接和CPU交换信息的存储器成为内存储器，简称内存。用来存放经常使用的程序和数据。<br>    <strong>外存</strong>：为了扩大容量，又不使成本有很大的提升，在计算机中配备了存储容量更大的磁盘存储器和光盘存储器，称为外存储器，简称外存。外存可存储大量的信息，计算机需要使用时，在调用内存。<br>    <strong>CPU</strong>：包括运算器和控制器。基本功能为：指令控制，操作控制，时间控制，数据加工。<br>    <strong>借口</strong>：同一计算机不同功能层之间的通信规则称为接口。接口泛指实体把自己提供给外界的一种抽象化物，其内部对外界屏蔽，具有封装的特性。 </p>
<p><strong>计算机的系统软件包括哪几类，说明其用途</strong><br>    <strong>操作系统类</strong>：控制和管理计算机各种资源、自动调度用户作业程序、处理各种中断的软件，是用户与计算机的接口。<br>    <strong>语言处理程序类</strong>：计算机能识别的语言与机器能直接执行的语言并不一致。计算机能够识别的语言编制的程序称为源程序，如：C语言。用机器语言编制的程序，称为目标程序。语言程序将源程序翻译成目标程序。<br>    <strong>服务性程序类</strong>：诊断程序、调试程序等。<br>    <strong>数据库管理系统类</strong>：有组织地、动态地存贮大量数据，使人们能方便、高效地使用这些数据。数据库管理系统是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。</p>
<p><strong>说明软件发展的演变过程</strong><br>    <strong>①</strong>程序设计阶段（20世纪40-50年代）：尚无软件的概念，程序设计主要围绕硬件进行开发，规模很小，工具简单，无明确分工（开发者和用户），程序设计追求节省空间和编程技巧，无文档资料（除程序清单外），主要用于科学计算。<br>    <strong>②</strong>软件设计阶段（20世纪50-70年代）：硬件环境相对稳定，开始广泛使用产品软件（可购买），从而建立了软件的概念。软件系统的规模越来越庞大，高级编程语言层出不穷，应用领域不断拓宽，开发者和用户有了明确的分工。<br>    <strong>③</strong>软件工程阶段（20世纪70年代起）：硬件已向巨型化、微型化、网络化和智能化四个方向发展，数据库技术已成熟并广泛应用。</p>
<p><strong>现代计算机系统如何进行多级划分，这种分级观念对计算机设计产生的影响是什么</strong><br>     第0级是硬联逻辑级；第1级是微程序设计级；第2级是一般机器级；第3级是操作系统级；第4级是汇编语言级；第5级是高级语言级；第6级是应用语言级。<br>     多级层次结构是从使用语言的角度，基于程序员与计算机系统对话中所采用的语言结构和语义划分。有利于正确理解计算机系统的工作过程，明确软件，硬件在计算机系统中的地位和作用。 </p>
<p><strong>为什么软件能够转化为硬件，硬件转化为软件，实现这种转化的媒介是什么？</strong><br>    ①硬件和软件的逻辑等价性，使得任何操作可以由软件来实现，也可由硬件来实现；任何指令的执行可以由硬件来完成，同样也可以由软件来完成。<br>    ②<strong>固件</strong>是软件和硬件相互转化的媒介。将程序固定在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，它具有硬件的快速性特点，又有软件的灵活性特点。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>基数：每个数码所用到的不同符号的个数，r进制的基数是r</p>
<p>任意数制转化十进制</p>
<p>二进制转化为八进制和十六进制</p>
<p>十进制转化为任意进制：除基取余（整数），乘基取整（小数部分）</p>
<p>真值：符合人类习惯的数字</p>
<p>机器数：数字实际存储在机器里的形式，正负号需要被“数字化”</p>
<p><strong>BCD码</strong><br>    8421码：是一种最常见的BCD码，是一种有权码，从高到低位权分别是8，4，2，1。每四个二进制位对应一个十进制位，其中有6中冗余状态。如果两个8421码相加超过范围，则需要在后面加上0110（十进制是6），强制向高位进1。<br>    余三码：在8421码的基础上加上了 3 （0011），是一种无权码。<br>    2421码：有权码，从高到低对应的位权分别是 2，4，2，1。0至4的最高位为0，5至9最高位为1。</p>
<p><strong>字符和字符串</strong><br>    ASCII码：对英文字母，特殊字符，通信字符等进行编码，总共128，可以用7位二进制进行表示<br>    GB 2312-80：1980年中国汉字的一种编码，汉字+字符一共7445个，表示方法是把汉字分区，分成94个区（每行），每个区是94个位置（94列）。每个汉字的编码就是区位码。但是和ASCII码中的通信字符冲突，所以在原来编码的基础上区码和位码都加上32（十六进制是20H），所以就变成了国标码。为了汉字编码和国际字符兼容，又产生了汉字内码，又叫做汉字机内码，汉字机内码的表示形式是在国标码的基础上加上128（十六进制是80H），这样的话编码就不会和ASCII码冲突。汉字编码用两个比特进行存储，第一个字节的最高位是1的一定是汉字编码，所及计算机在识别的时候肯定会等待第二个字符，然后把两个字节组合识别成一个汉字，而不会直接识别为一个英文编码。</p>
<p><strong>字符串的存储</strong></p>
<p>​    一般是按照低地址到高地址进行字符串字符的存储，通常采用 ‘ \0’ 作为字符串的结尾标志；例如汉字这样的多地址数据 ，会占用两个字节进行存储，有两种存储方式：大端模式和小端模式，大端模式是把字符的高位字节存储到低地址位置，小端模式是相反的。</p>
<p><strong>奇偶校验码</strong></p>
<p>码字和码距：由若干的代码组成的一个字叫做码字；两个码字之间的距离叫做两个码字的距离；各个码字间的最小距离被称为 “码距”。当码距 d = 1时，没有检错能力；当码距 d = 2 时，具有检错能力；当 d ≥ 3 时可能具有检错和纠错能力（例如海明码）                </p>
<p>奇校验和偶检验：整个 校验位 + 信息位 的整个二进制数中，所有的 1 的个数是奇数个的时候称为奇校验；如果是偶数个，就叫做偶校验；<u>奇偶校验码的方式只能检测出奇数个信息位的跳变</u>，对于偶数的比特位的跳变，是检测不出来信息错误的。</p>
<p>偶校验的硬件实现：各个信息位进行异或（模二加）运算，得到的结果就是偶校验位；<br>偶校验：所有位进行异或运算，如果结果是1说明出错，结果是0也不一定就是没有错误，万一存在偶数位的跳变。</p>
<p><strong>海明（汉明）校验码</strong></p>
<p>思想：把 n 个信息位分成 k 个分组，然后每个分组再进行偶校验，这样的话就能知道是哪个分组出现了错误</p>
<p>对于 n 个信息位分成 k 个分组的情况，一个分组就会有一个校验位，k个分组一共是k个校验位，所以所有位一共是n+k位，这n+k位每个都可能出错，也有可能每个位都不会出错，所以就会有n+k+1种状态，然后k个校验位会对应2<sup>k</sup> 种状态所以就存在着不等式：2<sup>k</sup> &gt;= n+k+1。</p>
<p>校验位P<sub>i</sub> 应该放在海明位号的第 2<sup>i-1</sup> 的位置，信息位按照顺序放在其余的位置。</p>
<p><strong>循环冗余校验码</strong></p>
<p>思想：数据发送和接收方都共同约定一个 “除数”，然后发送方发送数据，接收方用 “除数” 除法运算，如果能除尽，说明数据没有出错。</p>
<p>K 个信息位 + R 个校验位整体作为 “被除数” 添加完校验位后要确保整体进行 “除法” 运算后余数是 0。如果余数不是0的话，说明出错，进行重传和纠错。</p>
<p><strong>定点数和浮点数</strong></p>
<p>​    定点数就是小数点位置固定，是一种常规技术法。浮点数的小数点位置不固定，用科学计数法表示。</p>
<p>定点数：<br>    无符号数，整个机器字长的全部二进制位用来表示数值位，相当于数的绝对值。无符号数只有整数。<br>    有符号数的定点表示，有符号数说明有正负，正用0表示，负数用0表示。整个机器字长的第一位是符号位，后面的部分是数值部分，数值部分也叫尾数。定点整数的小数点隐含在机器字长的最后一个比特的后面，定点小数的小数点隐含在第一位符号位和第二位（数值部分的开头）。<br>    [X]<sub>原</sub> =1,0001= - 0001B<br>    [X]<sub>原</sub> = 1.0001 = -0.0001B</p>
<p>原码的定点整数表示和定点小数表示都是关于原点对称的。</p>
<img src="https://i.loli.net/2021/10/24/qndymOFLlBTbNEZ.jpg" alt="mmexport1635067630357.jpg" style="zoom:25%;">

<p><strong>反码</strong></p>
<img src="https://i.loli.net/2021/10/24/5ntlEgc1GPbM8Br.jpg" alt="mmexport1635067826185.jpg" style="zoom:25%;">



<p><strong>补码</strong></p>
<img src="https://i.loli.net/2021/10/24/GoOch2uCXYZ9V1e.jpg" alt="mmexport1635068387402.jpg" style="zoom:25%;">



<p><strong>移码</strong></p>
<p>可以很好的实现整数的大小对比。</p>
<img src="https://i.loli.net/2021/10/24/5nXdiICW3RxzuVe.jpg" alt="mmexport1635068614109.jpg" style="zoom:25%;">

<img src="https://img12.360buyimg.com/ddimg/jfs/t1/197380/7/14484/152805/61754693Ec5aba065/48ced55ad4e83ccc.jpg" alt="mmexport1635075633547.jpg" style="zoom:25%;">

<p>移码就是将补码的符号位取反，这样的好处就是让机器更好的比较数字的大小。</p>
<img src="https://img10.360buyimg.com/ddimg/jfs/t1/201804/7/15469/172993/61754751E0fd93eba/b2110aeda8992be1.jpg" alt="mmexport1635075897843.jpg" style="zoom:25%;">

<p><strong>原码，反码，补码，移码总结:</strong></p>
<p>​    如果是正数的情况下，正数的原码，反码，补码都是一致的。正数的移码是在补码的基础上符号位取反。<br>​    如果是负数，负数的反码是符号位不变，数值位取反。负数的补码是在负数反码的基础上在数值位末尾加1。<br>负数的移码是在负数补码的基础上符号位取反。<strong>另外移码只能用来表示整数。</strong></p>
<p>Tip：由 [X]<sub>补</sub> 快速求出 [ - X]<sub>补</sub> 的方法：符号位和数值位全部取反，末尾加一。</p>
<img src="https://img10.360buyimg.com/ddimg/jfs/t1/198216/34/14558/144560/61754b09E3ad8c079/91c9516b8f29b355.jpg" alt="mmexport1635076846428.jpg" style="zoom:25%;">

<p><strong>各种码之间的作用</strong></p>
<p>​    补码的作用：使用补码可以将减法操作转变为等价的加法，ALU就不用再集成减法器。执行加法操作的时候，符号位一起参与运算。</p>
<p>​    加减运算：如果是无符号数的加法操作，就十分的简单。但是有符号数进行加减运算的时候符号位是否参与运算都会影响在最后的结果。在一个正数一个负数相加的操作的时候，可以变成一个正数和一个负数的等价正数相加。负数的等价正数是负数的补码。正数和负数的补码相加就会得到相同的结果。</p>
<p><strong>定点数的算数移位运算</strong></p>
<p>​    移位，通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可以用移位运算实现乘法和除法。</p>
<img src="https://img14.360buyimg.com/ddimg/jfs/t1/204089/34/12753/212048/61761ac8E2e57fbc4/50cf82a670993ca6.jpg" alt="98c64a3652e2f53e79bb2c36f72c71e.jpg" style="zoom:25%;">

<p><strong>总结：</strong>对于正数的算数移位来说，不管是正整数还是正小数，正数的数值位左移和右移都是补0的；<br>对于负数来说就有点麻烦了，负数的原码移位的话还是补0，但是负数的反码就要补1了，因为负数的反码是在原码的基础上数值位取反的，所以负数的反码在进行移位运算的时候，补的是1；<br><strong>负数的补码的移位</strong>：负数的补码是在反码的基础上，末尾加1得来的，所以在末尾加1后，产生进位结束的数值位的左边部分进行算数右移的时候补得的1，在产生进位结束的数值位的右边部分进行算数左移补得是0；</p>
<p><strong>逻辑移位</strong>：逻辑移位可以看作是对无符号数的移位操作，逻辑移位的时候不看是符号位还是数值位，符号位和数值位都一样进行移位操作。</p>
<p><strong>循环左移位</strong>：</p>
<p>循环左移位的时候，向左溢出的值会存储到最后面的数值位的空缺位置，形成了循环；<br>带进位位的循环左移：在左移数值溢出的时候，会有一个CF来存储这个左移溢出的数值，如果之后再出现左移溢出，第二次左移溢出的值存储在CF中，之前CF的值放在数值位的最右边。</p>
<img src="https://img11.360buyimg.com/ddimg/jfs/t1/211832/23/1771/79913/61761f16E9fb6a898/79b23fc96f4b6311.jpg" alt="ba0ef54d99ee136c79f70f9ba0d7de2.jpg" style="zoom:25%;">

<p><strong>定点数的加减运算</strong></p>
<p>如果采用补码的加减运算的时候，符号位和数值位都是参与运算的。<br>在计算机中两数相减的时候，也会处理成相加操作，所以当相加时就要判断是否溢出的情况。<br>溢出分成两种情况，上溢出和下溢出，只要当 “正数+正数” 的时候才会出现上溢出—&gt; 正+正=负，当 “负数+负数”才会出现下溢出–&gt;负+负=正；</p>
<p><strong>判断补码运算溢出的方法：</strong></p>
<p>​    采用双符号位上的形式，00表示正数，11表示负数，如果两个补码进行相加之后符号位没有发生变化，还是00或者是11的话，说明没有发生溢出，如果是符号位变成了 10 或者是 01，则发生了下溢出和上溢出。</p>
<p><strong>符号扩展</strong></p>
<p>要注意补码的负整数和负小数的数值填充 。</p>
<img src="https://img12.360buyimg.com/ddimg/jfs/t1/161307/19/22700/160609/61762ed1Ed943d417/6fe3a6999a22aa4c.jpg" alt="83ad51aa842f05791429a1e4636f12d.jpg" style="zoom:25%;">

<img src="https://img12.360buyimg.com/ddimg/jfs/t1/128950/13/20892/168578/61764dabE10f29b3b/211617b6142cb785.jpg" alt="94538945bcca9f44a383bc27c8f08b1.jpg" style="zoom:25%;">

<p><strong>乘法运算</strong>（好难理解o(╥﹏╥)o，等我理解了，再来盘你）</p>
<p>原码的一位乘法</p>
<p>补码的一位乘法</p>
<p>原码的除法</p>
<p>补码的除法</p>
<p>C<strong>语言的强制类型转换</strong></p>
<pre><code>c语言的定点整数是按照 “补码” 的形式存储的</code></pre><p><strong>大小端的多字节存储</strong></p>
<p>多字节数据在内存中一定是占据连续的几个字节的，最高有效字节（MSB），最低有效字节（LSB）。大端模式的存储是最低高有效字节放在地址的最高位，最高有效字节放在内存地址的最低位；小端模式是最低有效字节放在了内存地址的较低位置；大端模式便于人类的阅读，小端模式便于机器处理。因为机器进行加减运算的时候，是从低位进行的，机器采用小端模式进行多字节数据的识别的时候就可以从识别最低位的数据最低位，然后就可以进行计算了。</p>
<p><strong>浮点数的表示和运算</strong></p>
<img src="https://img14.360buyimg.com/ddimg/jfs/t1/199043/26/14450/107850/617666f1Eb059ec70/12d76dd72000bede.jpg" alt="6b21c7dec2660079e0dd9e4cd6d2130.jpg" style="zoom:25%;">

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/212197/8/1921/142610/61766aeaEfd3d6359/07ce4e270bba9602.jpg" alt="a113bdb4680306068d3d200515ceeb7.jpg" style="zoom:25%;">

<p>阶码 E 反映出了浮点数的边表示范围以及小数点的实际位置；尾数 M 的数值部分的位数n反映出浮点数的精度。<br>尾数给出一个小数，阶码指明了小数点要向前或者向后移动多少位。</p>
<img src="https://img14.360buyimg.com/ddimg/jfs/t1/217614/11/1753/164653/61766ecfE6f241a13/3bd5102d344cbb8f.jpg" alt="c2e58dbc4f0d95f94f8247dc72b8e75.jpg" style="zoom:25%;">

<img src="https://img11.360buyimg.com/ddimg/jfs/t1/213384/22/1899/188506/617670d1Ea05c80d3/be24c476bca0cdff.jpg" alt="968984b35ac7d374e11747eca950540.jpg" style="zoom:25%;">

<img src="https://img10.360buyimg.com/ddimg/jfs/t1/199008/37/14621/176595/6176711fE424fd139/a610756e549f2803.jpg" alt="9446163f34cf47fb7b8293ba946cebc.jpg" style="zoom:25%;">]]></content>
  </entry>
  <entry>
    <title>马原知识点</title>
    <url>/2021/07/04/%E9%A9%AC%E5%8E%9F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="绪论："><a href="#绪论：" class="headerlink" title="绪论："></a>绪论：</h2><p>马克思主义的直接理论来源是：德国古典哲学 ，英国古典政治经济学，十九世纪英法空想社会主义<br>马克思主义的创始人：马克思，恩格斯<br>马克思主义中国化的三大理论成果：毛泽东思想，邓小平理论，“三个代表思想”<br>马克思主义理论体系：马克思主义哲学，马克思主义政治经济学，科学社会主义<br>学习马克思主义基本原理的方法：实事求是，理论联实际，认真学习马克思主义著作，科学对待马克思主义<br>马克思主义生命力的根源是：以实践为基础的科学性和革命性的统一<br>无产阶级的科学世界观和方法论是：辩证唯物主义和历史唯物主义<br>马克思最重要的理论品质：与时俱进<br>马克思主义最崇高的社会理想是：实现社会主义<br>马克思主义最鲜明的政治立场：致力于实现以劳动人民为主体的最广大人民的根本利益</p>
<p>辨析题：</p>
<p>一，马克思主义是马克思恩格斯的观点和学说的体系：</p>
<p>答：观点是不全面的，</p>
<p>（阶级性）马克思主义是无产阶级思想的科学体系<br>（创始人角度）是马克思恩格斯创立的基本理论、基本观点和学说的体系<br>（研究对象和主要内容角度）<br>    是无产阶级科学世界观和方法论，是关于自然、社会和思维发展的普遍规律的学说，是关于资本主义发展和转变为社会主义的普遍规律的学说，是关于无产阶级和人类解放的科学理论<br>（理论品质角度）并且在实践中不断丰富和发展的科学理论体系</p>
<p>二，德国古典哲学是马克思主义的唯一的直接理论来源：</p>
<p>答：这个观点是不全面的，</p>
<p>马克思主义的直接理论来源是<strong>德国古典哲学</strong>，<strong>英国古典政治经济学</strong>和<strong>１９世纪英法空想社会主义</strong>。马克思主义创始人马克思恩格斯直接吸收这三个理论的积极成果，结合无产阶级的实践经验，创立了无产阶级的科学思想体系——马克思主义。</p>
<p>三，马克思主义是行动指南，而不是教条：</p>
<p>答：观点是正确的，</p>
<p>马克思主义是<strong>无产阶级思想的科学体系</strong>，是无产阶级和劳动人民认识世界和改造世界的思想武器，<strong>是无产阶级的科学世界观和方法论</strong>。马克思主义是无产阶级实践经验的总结，是指导无产阶级进行革命的理论，它随着实践的发展而发展。因此，马克思主义不是教条，而是不断发展的理论。</p>
<p>论述题：</p>
<p>怎么理解马克思主义？</p>
<p>答：可以从不同角度理解，</p>
<p>阶级性：马克思主义是无产阶级思想的科学体系</p>
<p>创始人：是马克思恩格斯创立的<strong>基本理论</strong>、<strong>基本观点</strong>和<strong>学说</strong>的体系。</p>
<p>研究对象和主要内容：马克思主义是无产阶级科学世界观和方法论，是关于自然、社会和思维发展的普遍规律的学说，是关于资本主义发展和转变为社会主义的普遍规律的学说，是关于无产阶级和人类解放的科学理论。</p>
<p>理论体系：是由<strong>马克思主义哲学</strong>、<strong>马克思主义政治经济学</strong>和<strong>科学社会主义</strong>三个不可分割的部分组成的完整的科学体系，同时马克思主义又是在实践不断丰富和发展的开放式的，与时俱进的发展的科学体系。</p>
<p>怎样理解马克思主义是发展的理论？</p>
<p>一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理，是马克思主义最重要的理论品质。这一理论品质是马克思主义产生以来保持强大生命力的关键所在。</p>
<h2 id="第一章：世界的物质性及其发展规律"><a href="#第一章：世界的物质性及其发展规律" class="headerlink" title="第一章：世界的物质性及其发展规律"></a>第一章：世界的物质性及其发展规律</h2><p>哲学的基本问题包括：1，物质和意识，谁是本源；2，思维和存在的同一性问题<br>物质：不依赖人类的感觉而存在，唯一特性是客观存在性，存在于人们的意识之外，可以为人的意识所反映<br>意识：自然界长期发展的产物，是人脑的机能和属性，是物质世界的主观映像，内容是客观存在的，形式是主观的<br>物质决定意识，意识依赖于物质并反作用于物质</p>
<p>世界的物质统一性：</p>
<p>​    世界是物质的，而物质是运动的，物质和运动是不可分割的<br>​    物质世界的运动是绝对的，物质在运动过程中静止是相对的<br>​    时间和空间是物质运动的存在形式<br>​    物质，运动，时间，空间具有内在的统一性</p>
<p>社会生活的本质是实践的：</p>
<p>​    实践是社会关系形成的基础；<br>​    实践形成看社会生活的基本领域；<br>​    实践构成了社会发展的动力；</p>
<p>事物的普遍联系：</p>
<p>​    联系是事物内部各要素之间和事物之间相互影响，相互制约和相互作用的关系。<br>​    联系具有客观性，普遍性，多样性。</p>
<p>新事物为什么不可战胜？</p>
<p>​    发展是前进的上升的运动，发展的实质是新事物的产生和旧事物的灭亡。<br>​    ①就新生事物与环境的关系而言，新事物之所以新，是因为有新的结构和功能，它适应已经变化了的环境和条件。</p>
<p>​    ②就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、仍然适合新的条件的因素，并添加了旧事物中所不能容纳的新内容</p>
<p>对立统一规律：</p>
<p>​    <strong>对立统一规律</strong>是事物发展的根本规律，是唯物辩证法的实质和核心<br>​    ①矛盾的两种基本属性——<strong>同一性</strong>和<strong>斗争性</strong><br>​    ②矛盾问题的精髓——<strong>普遍性</strong>和<strong>特殊性</strong><br>​    同一性：矛盾两者相互依存<br>​    斗争性：矛盾对立面之间相互排斥，相互分离<br>​    普遍性：矛盾存在一切事物的发展过程中<br>​    特殊性：不同事物的矛盾各有特点</p>
<p>为什么对立统一规律是唯物辩证法体系的实质和核心？</p>
<pre><code>1，揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题
2，对立统一规律是贯穿质量互变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解这些规律和范畴的“钥匙”。
3，对立统一提供了人们认识世界和改造世界的基本方法-----矛盾分析法</code></pre><p>量变和质变的辩证关系：</p>
<p>​    1，量变是质变的必要准备。<br>​    2，质变是量变的必然结果。<br>​    3，量变和质变相互渗透。</p>
<p>辩证否定观的内容：</p>
<p>​    ①否定是事物的自我否定，是事物内部矛盾运动的结果<br>​    ②否定是事物发展的环节。<br>​    ③否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物是通过否定环节联系起来的。<br>​    ④辩证否定的实质是“<strong>扬弃</strong>”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。</p>
<p>否定之否定规律的基本内容：</p>
<p>​    事物的发展经过两次辩证的否定，由肯定阶段到否定阶段，再到否定之否定阶段，从而使事物的发展表现为螺旋式上升和波浪式前进的过程。否定之否定规律<strong>提示了事物的发展是前进性和曲折性的统一。</strong></p>
<p>矛盾分析法：</p>
<p>​    分析矛盾特殊性的方法，“<strong>两点论</strong>”与“<strong>重点论</strong>”相结合的方法，抓关键、看主流的方法，在对立中把握同一与在同一中把握对立的方法，批判与继承相统一的方法等，都是矛盾分析法的具体表现。</p>
<p>唯物辩证法的五大基本范畴：原因与结果 可能性与现实性 现象与本质 必然性与偶然性 内容与形式</p>
<p>辩证思维方法是人们正确进行理性思维的方法：<strong>归纳与演绎</strong>、<strong>分析与综合</strong>、<strong>抽象与具体</strong>、<strong>逻辑与历史相统一</strong></p>
<p>.什么是规律？</p>
<p>规律是事物的本质的联系。任何规律都是事物的内在根据和本质联系。</p>
<p>（1）规律就是物质运动发展过程中本质的、必然的、稳定的联系。</p>
<p>（2）规律具有两个特点。第一，客观性、第二，普遍性</p>
<p>自然规律与社会规律的区别与联系</p>
<p>区别：前者是一种盲目的无意识的力量起作用，后者则是通过有意识人的活动来实现的；前者是可以重现的，后者则是历史的，在不同的状态下有不同的表现形式。这就使认识社会规律比认识自然规律要困难得多。 </p>
<p>联系：作为规律，它本身具有不以人的意志为转移的客观性，人不能任意改变、创造或消灭自然规律。 </p>
<p>意识的作用：<br>①意识是能动的，具有目的性和计划性。<br>②意识活动具有创造性。<br>③意识具有指导实践改造客观世界的作用。<br>④意识还具有指导、控制人的行为和生理活动的作用。<br>总之，意识是物质的产物，是物质世界在人脑中的主观映像，这是物质、意识关系问题上的唯物主义。</p>
<p>全部哲学、特别是近代哲学的重大的基本问题是：思维和存在的关系问题<br>列宁对辩证唯物主义物质范畴的定义是通过：物质和意识的关系界定的<br>马克思主义认为，世界的真正统一性在于他的：物质性<br>既是自然界与人类社会分化统一的历史前提，又是自然界与人类社会统一起来的现实基础：实践<br>对于同一事物，不同的人有不同的反映：意识受主体状况影响<br>辩证唯物主义认为，事物发展的规律是：事物内在的本质和稳定的联系</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>计网的知识点是真的多，跟到第二章，知识点串联就有些吃力了，😰，还是不能光听课，自己也要做做笔记，做做总结吧。</p>
<h2 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h2><p>2021-10-5  第一章的内容，不看视频了，快速看一遍课本，看看哪里不清楚然后记录下来</p>
<p>带宽：本来是值指通信线路所允许的通过的信号频带范围，单位是HZ赫兹。在计算机网络中所指的是通信线路所能传输数据的能力，是“最高数据传输速率”同义词，单位是比特每秒。</p>
<p>实体：任何可发送或者接收信息的硬件或者软件进程，通常指一个特定的软件模块。</p>
<p>协议数据单元（PDU）= 服务数据单元（SDU）+ 协议控制信息（PCI）<br>每一层的协议数据单元（PDU ）都有一个俗名，物理层的PDU叫比特；数据链路层—》帧 ；网络层–》分组；传输层PDU–》报文段；</p>
<p>上一层只能通过接口使用相邻下一层所提供的服务，不能调用其他层的服务；</p>
<p>网络协议简称协议是相对同层的实体进行通信而言的，不同层的实体不存在协议一说；</p>
<p>协议：语法+语义+同步；</p>
<p>完整的协议应该具备：线路管理（建立释放连接），差错控制，数据转换；</p>
<p>接口：相邻两层之间才有接口一说，跨层之间没有接口；</p>
<p>SAP（Service Access Point）：相邻接口之间的同一结点的实体进行交互的访问点；是一个抽象概念一个逻辑接口，不同于硬件接口，服务是通过SAP提供给上层使用的，第N层SAP就是N+1层可以访问N层的地方；</p>
<p>TCP是一种面向连接服务的协议；</p>
<p>IP、UDP是一种无连接服务的连接；</p>
<p>一层内完成的所有功能并不是都成为服务，而是被上一层实体看得见的功能才称为服务；</p>
<p>通过用户或者是应用可以把不可靠传输变成可靠传输；</p>
<p>计算机的服务可以按照以下三种方式进行分类：<br>1️⃣面向连接/无连接服务<br>2️⃣可靠/不可靠服务<br>3️⃣有应答/无应答服务。<br>文件传输是一种有应答服务。</p>
<p>进行信息传输的物理媒体，例如双绞线，光缆，无线信道等不在物理层，而是在物理层的下面，所以把物理媒体称为第0层；</p>
<p>数据链路层的主要功能是：把来自上层网络层传输下来的数据报进行成帧处理，因为数据链路层的实体就是帧；功能还包括：差错控制，流量控制，传输管理；</p>
<p>网络层可以通过路由算法，计算出合适的路径把分组顺利送到终点；网络层可以进行差错控制，通过奇偶校验码等方式检查差错，能纠错就纠错们不能就舍弃，确保向上的数据不错误；</p>
<p>因特网的主要网络层协议是无连接的网络协议（IP）和许多路由选择协议，因此因特网的网络层也称为网际层或者是IP层。</p>
<p>传输层也叫运输层；</p>
<p>传输层的传输单位是报文段（TCP）或者是用户数据报（UDP），传输层负责两个进程之间的通信，功能是为端到端连接提供可靠的传输服务；</p>
<p>数据链路层提供的是点到点的通信，传输层是提供端到端的通信；点到点是主机之间，端到端是进程和进程之间的通信即端口和端口之间的通信。</p>
<p>通过使用传输层，上层的用户可以忽略下方通信子网的具体细节。</p>
<p>由于一台主机可同时运行多个进程，所以存在传输层的复用和分用功能：<br>    复用：多个应用层进程可以同时使用下面传输层的服务<br>    分用：传输层可以把收到的信息分别交给上面相应的进程</p>
<p>传输层具有的协议是：TCP，UDP</p>
<p>会话层：<br>    会话：会话层利用传输层提供的端到端的服务，向表示层提供他的增值服务。这种服务主要是表示层的实体或者用户进程建立连接，并在连接上进行有效传输，也叫建立同步。</p>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><p>2020-10-14 昨天把第二章物理层的王道书给看完了，再重新梳理一遍知识点吧，不要怕重复，加油!</p>
<p>物理层考虑的是如何在各个计算机之间的传输媒体上传输数据比特流，而传输比特流的是具体的传输媒体。</p>
<p>数据是传送信息的实体，信号是数据的电气或者电磁表现。</p>
<p>数据传输方式可分为串行传输，和并行传输，串行传输就是一个比特一个比特按照时间顺序传输，远距离传输用的是串行传输。并行传输说的是多个比特同时在多个通信信道上传输。</p>
<p>码元：一个码元可以携带若干比特的信息量。</p>
<p>一个通信系统可以划分为信源，信道，信宿。信源是信息发送的源头，信宿是信息吸收的终点。</p>
<p>信道按照传输信号的不同可分为：模拟信道和数字信道。<br>信道按照传输介质的不同可分为：无线信道和有线信道。</p>
<p>信道上传输的的信号可分为基带信号和宽带信号。<br>基带信号：将数字信号按照1和0直接用不同的电压表示，在数字信道上传输（称为基带传输）<br>宽带信号：将基带信号进行调制形成频分复用模拟信号，然后在模拟信道上传输（称为宽带传输）</p>
<p>通信双方交互方式可分为：<br>1 单向通信<br>    只有一条单向通信信道，例如 无线电广播，电视广播。<br>2 半双工通信<br>    具有两条信道，通信双方都可以进行发送和接收消息，但是任何一方都不能同时发送和接收信号。<br>3 全双工通信<br>    具有两条信道，通信双方可以同时进行发送和接收消息。</p>
<p>信道的极限容量：信道的最高码元传输速率或者信道的极限信息传输速率。</p>
<p>速率：数据率/数据传输速率，表示的是单位时间传输的数据量，有两种表示方式，码元传输速率、信息传输速率<br>码元传输速率：<br>    又叫波特率，调制速率，波形速率，符号速率。单位时间传输的码元个数（或者脉冲个数，信号变化次数），码元速率与进制数无关！！！<br>信息传输速率：<br>    又叫信息速率，比特率，表示单位时间内通信系统传输的二进制码元个数（即比特数）单位是比特/秒</p>
<p>带宽原本指的是频带宽度，单位是HZ，在网络中指的是单位时间从网络某一点到某一点所能通过的“最高数据率”单位是b/s</p>
<p><strong>奈奎斯特定理和香农定理</strong><br>    <strong>奈奎斯特定理</strong>又称为奈式定理，他规定在理想（没有噪声，带宽有限）状态下，为了避免码间串扰，规定极限码元传输速率为2W波特，W是理想低通道的带宽。V表示每个码元离散电平个数。<br>极限数据传输速率 = 2W·Log<sub>2</sub> V (单位是b/s)<br>    奈式定理结论：<br>    1️⃣：码元传输速率具有上限，超过上限，会出现码元之间的串扰，使得接收端不可能完全正确的接收和识别码元。<br>    2️⃣：信道的频带越宽，即通过的信号高频分量越多，就可以用更高的速率进行码元的有效传输。<br>    3️⃣：奈式准则给出了码元的传输速率，但是没有给出信息传输速率，即没有对一个码元对应多少个比特位进行限制。<br>    <strong>香农定理</strong>：给出了带宽受限而且有白噪声干扰的信道的极限数据传输速率，用这个速率进行传输的时候，可以做到不产生误差。<br>    定义：信道的极限数据传输速率 = W · Log<sub>2</sub>(1+S/N)  单位是 b/s<br>    W是信道的带宽，S是信道传输信号的平均功率，N是信道内部的高斯噪声功率；<br>    S/N 是信噪比，信噪比有两种表示方法，一种是纯数字，一种单位是dB<br>    香农定理结论：<br>    1️⃣：信号带宽或者信道的信噪比越大的话，信息的极限传输速率越高<br>    2️⃣：对于一定的信号带宽和确定的信噪比，那么信息传输的速率上限就确定了<br>    3️⃣：只要信息传输速率低于信道的极限传输速率，就能找到一种方式达到无差错传输。<br>    4️⃣：香农定理规定的是极限数据传输速率，实际通信的时候速率比极限速率低<br>    总结：奈式定理只规定了带宽和极限码元速率的关系，香农定理还考虑到了信噪比，说明了一个码元对应的二进制位数是有限的。</p>
<p>将数据变换为模拟信号的过程叫调制；把数据变换为数字信号的过程是编码；</p>
<p>信号是数据的具体表现形式；数字数据可以通过数字发送器变换为数字信号传输，也可以通过调制器转换为模拟信号传输；模拟信号可以通过PCM编码器变换为数字信号传输，也可以通过放大器调制器转化为模拟信号进行传输；</p>
<p>四种数字数据编码为数字信号的方式：<br>    1️⃣：归零编码（RZ，ReturnZero），高电平和低电平两种电平可以表示数字0和1，正反表示都可以，由于每个时钟周期通过跳变可以调整时钟基准，就为双方提供了自同步机制，归零会占用一部分带宽，所以传输效率会受到一定的影响</p>
<p>​    2️⃣：非归零编码（NRZ），和归零编码的区别就是，不用归零，一个周期全部用来表示传输数据，但是NRZ无法传输时钟信号，双方难以同步，如果想进行高速同步传输数据，必须要一个时钟线。</p>
<p>​    3️⃣：反向非归零编码（NRZI），信号翻转表示0，信号不变表示1，翻转的信号可以作为一种通知机制，既能传输时钟信号，又能尽量不损失系统带宽。<strong>USB2.0使用的就是NRZI编码</strong>。</p>
<p>​    4️⃣：曼彻斯特编码，将一个码元分成两个相等的间隔，前一个间隔为高电平后一个间隔是低电平时表示码元为1；码元为0的情况相反，也可以采用相反的方案。码元中间进行电平跳变，位中间的跳变可作为时钟信号用来同步，也可作为数据信号，但是所占的频带宽度是原始基带宽度的两倍。<strong>以太网使用的编码方式采用曼彻斯特编码。</strong></p>
<p>​    5️⃣：差分曼彻斯特编码，如果码元表示为0，则码元的前半个周期和上一个码元后半个周期相同，码元表示为1则相反。每个码元之间都有一次的电平跳变，可实现自同步。抗干扰性较好，常用于局域网。</p>
<p>​    6️⃣：4B/5B编码，数据流的每4位按照编码规则转换为相应的5位码，5位码的32中组合中的16种对应4位编码，其他的16种作为开始，结束，线路状态等控制码。</p>
<p>数字数据调制成模拟信号：<br>    数字信号通过调制成模拟信号在信道上传输，传输到接收端，通过解调器把模拟信号再转化为数字信号。<br>    1️⃣：幅移键控（ASK），通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位都不改变。比较容易实现，抗干扰性差。<br>    2️⃣：频移键控（FSK），—————————频率—————————，振幅和相位不改变，容易实现，抗干扰性强，应用较为广泛。<br>    3️⃣：相移键控（PSK），—————————相位—————————，振幅和频率不改变，分为绝对调相和相对调相<br>    4️⃣：正交振幅调制（QAM），</p>
<h2 id="介质访问控制："><a href="#介质访问控制：" class="headerlink" title="介质访问控制："></a>介质访问控制：</h2><p>介质访问控制子层（MAC）用来决定广播信道中信道分配</p>
<p>常见的介质访问控制方法：<br>    信道划分介质访问控制；随机访问介质访问控制；轮询访问介质访问控制，第一种静态划分信道，后两个是动态分配信道。</p>
<p>流量控制与可靠传输机制</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的with用法</title>
    <url>/2021/11/03/python%E4%B8%AD%E7%9A%84with%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>自己是在用tensorflow的时候接触到的 with 语句，知其然不知其所以然。</p>
<p>参考文章：<a href="https://blog.csdn.net/Ego_Bai/article/details/80873242" target="_blank" rel="noopener">https://blog.csdn.net/Ego_Bai/article/details/80873242</a></p>
<p>在打开一些文件的时候，需要进行打开和关闭操作，有时候会忘记关闭，with语句有自动关闭的功能，还有错误处理功能，在遇到错误的时候不需要try catch操作，代码写的不臃肿。</p>
<p>最普通写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"/tmp/foo.txt"</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>加强版-报错处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"/tmp/foo.txt"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure>

<p>前者代码过于冗余，所以使用 with 语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"/tmp/foo.txt"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure>



<p>with 是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FileManager(Object):</span><br><span class="line">	def __init__(self,name,mode):</span><br><span class="line">		print(&quot;调用__init__方法&quot;)</span><br><span class="line">		self.name &#x3D; name</span><br><span class="line">		self.mode &#x3D; mode</span><br><span class="line">		self.file &#x3D; None</span><br><span class="line">		</span><br><span class="line">	def __enter__(self):</span><br><span class="line">		print(&quot;调用__enter__方法&quot;)</span><br><span class="line">		self.file &#x3D; open(self.name,self.mode)</span><br><span class="line">		erturn self.file</span><br><span class="line">		</span><br><span class="line">	def __exit__(self,exc_type,exc_val,exc_tb):</span><br><span class="line">		print(&quot;调用__exit__方法&quot;)</span><br><span class="line">		if self.file:</span><br><span class="line">			self.file.close()</span><br><span class="line">				</span><br><span class="line">#FileManager就是一个上下文管理器的一个类</span><br><span class="line">with FileManager(&#39;test.txt&#39;) as file:</span><br><span class="line">	print(&quot;准备读取文件&quot;)</span><br><span class="line">	content	&#x3D; file.read()</span><br><span class="line">    print(content)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用__init__方法</span><br><span class="line">调用__enter__方法</span><br><span class="line">准备读取文件</span><br><span class="line">嗨，我是崔金浩</span><br><span class="line">调用__exit__方法</span><br></pre></td></tr></table></figure>

<p>运行上面的程序的时候，首先会执行创建类的代码，然后执行所有python类的统一的 init() 方法，然后会执行上下文管理器类特有的方法 enter()，该方法会返回一个文件类，这样就可以不用写打开文件的open方法了，返回的这个文件类传递给我们定义的file，在with语句结束的时候，会自动调用上下文管理器 exit() 方法，进而关闭文件，不需要手动关闭了。</p>
]]></content>
  </entry>
</search>
