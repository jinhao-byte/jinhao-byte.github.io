<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XML学习</title>
    <url>/2021/05/12/XML%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/2021/06/02/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2021/05/12/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机基础知识</title>
    <url>/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/05/26/Git/</url>
    <content><![CDATA[<p>Git：目前最先进的分布式版本控制系统</p>
<p>Workspace：工作区<br>Index/Stage：暂存区<br>Repository：仓库区（本地仓库）<br>Remote：远程仓库</p>
<p>SVN/Git区别：<br>    SVN是集中式的版本控制系统，版本库是集中放在中央服务器的，自己弄的时候，都是在自己的电脑，首先要从中央服务器拿到最新的版本，做完自己的工作，再推送到中央服务器，集中式版本控制系统必须联网才能工作。如果局域网可以，带宽够大，速度够快，在互联网下网速慢的话，就不好了。<br>    Git是分布式的版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，所以工作的时候不需要联网，因为版本都在自己的电脑上，多人协作的时候，如果两个人都修改了文件A，两个人只需把各自的修改推送给对方，就可以互相看到对方的修改。</p>
<p>版本库repository：<br>    也叫仓库，可以简单理解为一个目录，这个目录所有的文件都可以被Git管理起来，每个文件的修改，删除，Git都能被跟踪，以便任何时刻都可以跟踪历史，或者在将来的某个时刻可以将文件‘还原’。</p>
<p>理解工作区和暂存区：<br>    工作区：自己电脑的目录，比如目录下testgit里的文件（.git隐藏目录版本库除外）。或者以后需要再建的目录文件等都属于工作区的范畴<br>    版本库（Repository）：工作区的隐藏目录.git,这个不属于工作区，这是版本库。其中版本库存了很多东西，其中最重要的就是st<br>    age（暂存区），还有Git为我们自动创建的第一个master，以及指向master的一个分支HEAD。</p>
<p>使用Git提交文件到版本库步骤：<br>    1：使用git add把文件添加进去，实际就是把文件添加到暂存区<br>    2：使用git commit提交更改，实际就是把暂存区的内容提交到当前分支。</p>
<p>暂存区：</p>
<p>远程仓库：<br>    首先注册github账号，本地Git和github仓库之间是通过SSH加密的，所以需要设置：<br>        1，</p>
<a id="more"></a>


<p>所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码，Git也是，版本控制系统可以告诉自己每次的改动，但是图片，视频这些二进制文件，虽然也能由版本控制西永管理，但还是没法跟踪文件的变化，只能把二进制文件每次改动串动起来，也就知道文件从1kb变成了2kb，但是改了什么，版本控制也不知道。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2021/05/04/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录MySQL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p12345612</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 显示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE test;</span><br><span class="line"></span><br><span class="line">-- 切换数据库</span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line">-- 显示数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 创建数据表</span><br><span class="line">CREATE TABLE pet (</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    owner VARCHAR(20),</span><br><span class="line">    species VARCHAR(20),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birth DATE,</span><br><span class="line">    death DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看数据表结构</span><br><span class="line">-- describe pet;</span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line">-- 查询表</span><br><span class="line">SELECT * from pet;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);</span><br><span class="line"></span><br><span class="line">-- 修改数据</span><br><span class="line">UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除数据</span><br><span class="line">DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE myorder;</span><br></pre></td></tr></table></figure>

<h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 主键约束</span><br><span class="line">-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 联合主键</span><br><span class="line">-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    password VARCHAR(20),</span><br><span class="line">    PRIMARY KEY(id, name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 自增约束</span><br><span class="line">-- 自增约束的主键由系统自动递增分配。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加主键约束</span><br><span class="line">-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD PRIMARY KEY(id);</span><br><span class="line">ALTER TABLE user MODIFY id INT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">-- 删除主键</span><br><span class="line">ALTER TABLE user drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 建表时创建唯一主键</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    UNIQUE(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加唯一主键</span><br><span class="line">-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD UNIQUE(name);</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">-- 删除唯一主键</span><br><span class="line">ALTER TABLE user DROP INDEX name;</span><br></pre></td></tr></table></figure>

<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表时添加非空约束</span><br><span class="line">-- 约束某个字段不能为空</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 建表时添加默认约束</span><br><span class="line">-- 约束某个字段的默认值</span><br><span class="line">CREATE TABLE user2 (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    age INT DEFAULT 10</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY age INT;</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 班级</span><br><span class="line">CREATE TABLE classes (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE students (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    -- 这里的 class_id 要和 classes 中的 id 字段相关联</span><br><span class="line">    class_id INT,</span><br><span class="line">    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值</span><br><span class="line">    FOREIGN KEY(class_id) REFERENCES classes(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；</span><br><span class="line">-- 2. 主表中的记录被副表引用时，主表不可以被删除。</span><br></pre></td></tr></table></figure>

<h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    product_name VARCHAR(20),</span><br><span class="line">    customer_name VARCHAR(20),</span><br><span class="line">    PRIMARY KEY (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE product (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    customer_phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
<h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE select_test;</span><br><span class="line">-- 切换数据库</span><br><span class="line">USE select_test;</span><br><span class="line"></span><br><span class="line">-- 创建学生表</span><br><span class="line">CREATE TABLE student (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE, -- 生日</span><br><span class="line">    class VARCHAR(20) -- 所在班级</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建教师表</span><br><span class="line">CREATE TABLE teacher (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE,</span><br><span class="line">    profession VARCHAR(20) NOT NULL, -- 职称</span><br><span class="line">    department VARCHAR(20) NOT NULL -- 部门</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建课程表</span><br><span class="line">CREATE TABLE course (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    t_no VARCHAR(20) NOT NULL, -- 教师编号</span><br><span class="line">    -- 表示该 tno 来自于 teacher 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(t_no) REFERENCES teacher(no) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 成绩表</span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    s_no VARCHAR(20) NOT NULL, -- 学生编号</span><br><span class="line">    c_no VARCHAR(20) NOT NULL, -- 课程号</span><br><span class="line">    degree DECIMAL,	-- 成绩</span><br><span class="line">    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(s_no) REFERENCES student(no),	</span><br><span class="line">    FOREIGN KEY(c_no) REFERENCES course(no),</span><br><span class="line">    -- 设置 s_no, c_no 为联合主键</span><br><span class="line">    PRIMARY KEY(s_no, c_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 添加学生表数据</span><br><span class="line">INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加教师表数据</span><br><span class="line">INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加课程表数据</span><br><span class="line">INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加添加成绩表数据</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);</span><br><span class="line"></span><br><span class="line">-- 查看表结构</span><br><span class="line">SELECT * FROM course;</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">SELECT * FROM teacher;</span><br></pre></td></tr></table></figure>

<h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询 student 表的所有行</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询 student 表中的 name、sex 和 class 字段的所有行</span><br><span class="line">SELECT name, sex, class FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询 teacher 表中不重复的 department 列</span><br><span class="line">-- department: 去重查询</span><br><span class="line">SELECT DISTINCT department FROM teacher;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）</span><br><span class="line">-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;</span><br><span class="line">SELECT * FROM score WHERE degree BETWEEN 60 AND 80;</span><br><span class="line">SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中成绩为 85, 86 或 88 的行</span><br><span class="line">-- IN: 查询规定中的多个值</span><br><span class="line">SELECT * FROM score WHERE degree IN (85, 86, 88);</span><br><span class="line"></span><br><span class="line">-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行</span><br><span class="line">-- or: 表示或者关系</span><br><span class="line">SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- 以 class 降序的方式查询 student 表的所有行</span><br><span class="line">-- DESC: 降序，从高到低</span><br><span class="line">-- ASC（默认）: 升序，从低到高</span><br><span class="line">SELECT * FROM student ORDER BY class DESC;</span><br><span class="line">SELECT * FROM student ORDER BY class ASC;</span><br><span class="line"></span><br><span class="line">-- 以 c_no 升序、degree 降序查询 score 表的所有行</span><br><span class="line">SELECT * FROM score ORDER BY c_no ASC, degree DESC;</span><br><span class="line"></span><br><span class="line">-- 查询 &quot;95031&quot; 班的学生人数</span><br><span class="line">-- COUNT: 统计</span><br><span class="line">SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。</span><br><span class="line">-- (SELECT MAX(degree) FROM score): 子查询，算出最高分</span><br><span class="line">SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line"></span><br><span class="line">--  排序查询</span><br><span class="line">-- LIMIT r, n: 表示从第r行开始，查询n条数据</span><br><span class="line">SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</span><br></pre></td></tr></table></figure>

<h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- AVG: 平均值</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;</span><br><span class="line"></span><br><span class="line">-- GROUP BY: 分组查询</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br></pre></td></tr></table></figure>

<h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">-- c_no 课程编号</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先把 c_no, AVG(degree) 通过分组查询出来</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     85.3333 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- 再查询出至少有 2 名学生选修的课程</span><br><span class="line">-- HAVING: 表示持有</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2</span><br><span class="line"></span><br><span class="line">-- 并且是以 3 开头的课程</span><br><span class="line">-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。</span><br><span class="line">AND c_no LIKE &#39;3%&#39;;</span><br><span class="line"></span><br><span class="line">-- 把前面的SQL语句拼接起来，</span><br><span class="line">-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。</span><br><span class="line">SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| c_no  | AVG(degree) | COUNT(*) |</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| 3-105 |     85.3333 |        3 |</span><br><span class="line">| 3-245 |     76.3333 |        3 |</span><br><span class="line">+-------+-------------+----------+</span><br></pre></td></tr></table></figure>

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT no, name FROM student;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| no  | name      |</span><br><span class="line">+-----+-----------+</span><br><span class="line">| 101 | 曾华      |</span><br><span class="line">| 102 | 匡明      |</span><br><span class="line">| 103 | 王丽      |</span><br><span class="line">| 104 | 李军      |</span><br><span class="line">| 105 | 王芳      |</span><br><span class="line">| 106 | 陆军      |</span><br><span class="line">| 107 | 王尼玛    |</span><br><span class="line">| 108 | 张全蛋    |</span><br><span class="line">| 109 | 赵铁柱    |</span><br><span class="line">+-----+-----------+</span><br><span class="line"></span><br><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- FROM...: 表示从 student, score 表中查询</span><br><span class="line">-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。</span><br><span class="line">SELECT name, c_no, degree FROM student, score </span><br><span class="line">WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。</span><br><span class="line">-- as 表示取一个该字段的别名。</span><br><span class="line">SELECT s_no, name as c_name, degree FROM score, course</span><br><span class="line">WHERE score.c_no &#x3D; course.no;</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| s_no | c_name          | degree |</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| 103  | 计算机导论      |     92 |</span><br><span class="line">| 105  | 计算机导论      |     88 |</span><br><span class="line">| 109  | 计算机导论      |     76 |</span><br><span class="line">| 103  | 操作系统        |     86 |</span><br><span class="line">| 105  | 操作系统        |     75 |</span><br><span class="line">| 109  | 操作系统        |     68 |</span><br><span class="line">| 103  | 数字电路        |     85 |</span><br><span class="line">| 105  | 数字电路        |     79 |</span><br><span class="line">| 109  | 数字电路        |     81 |</span><br><span class="line">+------+-----------------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 课程表</span><br><span class="line">SELECT no, name FROM course;</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br><span class="line"></span><br><span class="line">-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。</span><br><span class="line">SELECT student.name as s_name, course.name as c_name, degree </span><br><span class="line">FROM student, score, course</span><br><span class="line">WHERE student.NO &#x3D; score.s_no</span><br><span class="line">AND score.c_no &#x3D; course.no;</span><br></pre></td></tr></table></figure>

<h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询</span><br><span class="line">SELECT s_no, c_no, degree FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT c_no, AVG(degree) FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)</span><br><span class="line">GROUP BY c_no;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     82.0000 |</span><br><span class="line">| 3-245 |     71.5000 |</span><br><span class="line">| 6-166 |     80.0000 |</span><br><span class="line">+-------+-------------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score </span><br><span class="line">WHERE c_no &#x3D; &#39;3-105&#39;</span><br><span class="line">AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。</span><br><span class="line">SELECT * FROM score</span><br><span class="line">WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- YEAR(..): 取出日期中的年份</span><br><span class="line">SELECT no, name, birthday FROM student</span><br><span class="line">WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</span><br></pre></td></tr></table></figure>

<h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );</span><br></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE t_no &#x3D; ( </span><br><span class="line">        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; </span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询 teacher 表</span><br><span class="line">SELECT no, name FROM teacher;</span><br><span class="line">+-----+--------+</span><br><span class="line">| no  | name   |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 804 | 李诚   |</span><br><span class="line">| 825 | 王萍   |</span><br><span class="line">| 831 | 刘冰   |</span><br><span class="line">| 856 | 张旭   |</span><br><span class="line">+-----+--------+</span><br><span class="line"></span><br><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 在这里找到对应的条件</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course;</span><br><span class="line">-- t_no: 教师编号</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| no    | name            | t_no |</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| 3-105 | 计算机导论      | 825  |</span><br><span class="line">| 3-245 | 操作系统        | 804  |</span><br><span class="line">| 6-166 | 数字电路        | 856  |</span><br><span class="line">| 9-888 | 高等数学        | 831  |</span><br><span class="line">+-------+-----------------+------+</span><br></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在此之前向 score 插入一些数据，以便丰富查询条件。</span><br><span class="line">INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。</span><br><span class="line">SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;</span><br><span class="line">+-------+</span><br><span class="line">| c_no  |</span><br><span class="line">+-------+</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT t_no FROM course WHERE no IN (</span><br><span class="line">    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">);</span><br><span class="line">+------+</span><br><span class="line">| t_no |</span><br><span class="line">+------+</span><br><span class="line">| 825  |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 最终条件</span><br><span class="line">    SELECT t_no FROM course WHERE no IN (</span><br><span class="line">        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号</span><br><span class="line">SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| no  | name   | department   |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| 804 | 李诚   | 计算机系     |</span><br><span class="line">| 825 | 王萍   | 计算机系     |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line"></span><br><span class="line">-- 通过 course 表查询该教师的课程编号</span><br><span class="line">SELECT no FROM course WHERE t_no IN (</span><br><span class="line">    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br><span class="line">+-------+</span><br><span class="line">| no    |</span><br><span class="line">+-------+</span><br><span class="line">| 3-245 |</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br><span class="line"></span><br><span class="line">-- 根据筛选出来的课程号查询成绩表</span><br><span class="line">SELECT * FROM score WHERE c_no IN (</span><br><span class="line">    SELECT no FROM course WHERE t_no IN (</span><br><span class="line">        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT: 代表逻辑非</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;</span><br><span class="line">)</span><br><span class="line">-- 合并两个集</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- ANY: 符合SQL语句中的任意条件。</span><br><span class="line">-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，</span><br><span class="line">-- 最后根据降序查询结果。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">) ORDER BY degree DESC;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 只需对上一道题稍作修改。</span><br><span class="line">-- ALL: 符合SQL语句中的所有条件。</span><br><span class="line">-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询平均分</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     87.6667 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line">SELECT degree FROM score;</span><br><span class="line">+--------+</span><br><span class="line">| degree |</span><br><span class="line">+--------+</span><br><span class="line">|     90 |</span><br><span class="line">|     91 |</span><br><span class="line">|     92 |</span><br><span class="line">|     86 |</span><br><span class="line">|     85 |</span><br><span class="line">|     89 |</span><br><span class="line">|     88 |</span><br><span class="line">|     75 |</span><br><span class="line">|     79 |</span><br><span class="line">|     76 |</span><br><span class="line">|     68 |</span><br><span class="line">|     81 |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">-- 将表 b 作用于表 a 中查询数据</span><br><span class="line">-- score a (b): 将表声明为 a (b)，</span><br><span class="line">-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。</span><br><span class="line">SELECT * FROM score a WHERE degree &lt; (</span><br><span class="line">    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| name   | department      |</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| 李诚   | 计算机系        |</span><br><span class="line">| 王萍   | 计算机系        |</span><br><span class="line">| 刘冰   | 电子工程系      |</span><br><span class="line">| 张旭   | 电子工程系      |</span><br><span class="line">+--------+-----------------+</span><br></pre></td></tr></table></figure>

<h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看学生表信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line"></span><br><span class="line">-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。</span><br><span class="line">SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;</span><br><span class="line">+-------+</span><br><span class="line">| class |</span><br><span class="line">+-------+</span><br><span class="line">| 95033 |</span><br><span class="line">| 95031 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT: 取反</span><br><span class="line">-- LIKE: 模糊查询</span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。</span><br><span class="line">SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 曾华      |   42 |</span><br><span class="line">| 匡明      |   44 |</span><br><span class="line">| 王丽      |   43 |</span><br><span class="line">| 李军      |   43 |</span><br><span class="line">| 王芳      |   44 |</span><br><span class="line">| 陆军      |   45 |</span><br><span class="line">| 王尼玛    |   43 |</span><br><span class="line">| 张全蛋    |   44 |</span><br><span class="line">| 赵铁柱    |   45 |</span><br><span class="line">| 张飞      |   45 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure>

<h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(birthday), MIN(birthday) FROM student;</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| MAX(birthday) | MIN(birthday) |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| 1977-09-01    | 1974-06-03    |</span><br><span class="line">+---------------+---------------+</span><br></pre></td></tr></table></figure>

<h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student ORDER BY class DESC, birthday;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| no    | name         | t_no |</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| 3-245 | 操作系统     | 804  |</span><br><span class="line">| 6-166 | 数字电路     | 856  |</span><br><span class="line">+-------+--------------+------+</span><br></pre></td></tr></table></figure>

<h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 找出最高成绩（该查询只能有一个结果）</span><br><span class="line">SELECT MAX(degree) FROM score;</span><br><span class="line"></span><br><span class="line">-- 根据上面的条件筛选出所有最高成绩表，</span><br><span class="line">-- 该查询可能有多个结果，假设 degree 值多次符合条件。</span><br><span class="line">SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先将李军的性别作为条件取出来</span><br><span class="line">SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;</span><br><span class="line">+-----+</span><br><span class="line">| sex |</span><br><span class="line">+-----+</span><br><span class="line">| 男  |</span><br><span class="line">+-----+</span><br><span class="line"></span><br><span class="line">-- 根据性别查询 name 和 sex</span><br><span class="line">SELECT name, sex FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+</span><br><span class="line">| name      | sex |</span><br><span class="line">+-----------+-----+</span><br><span class="line">| 曾华      | 男  |</span><br><span class="line">| 匡明      | 男  |</span><br><span class="line">| 李军      | 男  |</span><br><span class="line">| 陆军      | 男  |</span><br><span class="line">| 王尼玛    | 男  |</span><br><span class="line">| 张全蛋    | 男  |</span><br><span class="line">| 赵铁柱    | 男  |</span><br><span class="line">| 张飞      | 男  |</span><br><span class="line">+-----------+-----+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, sex, class FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">) AND class &#x3D; (</span><br><span class="line">    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| name      | sex | class |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| 曾华      | 男  | 95033 |</span><br><span class="line">| 李军      | 男  | 95033 |</span><br><span class="line">| 王尼玛    | 男  | 95033 |</span><br><span class="line">+-----------+-----+-------+</span><br></pre></td></tr></table></figure>

<h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;</span><br><span class="line">) AND s_no IN (</span><br><span class="line">    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE grade (</span><br><span class="line">    low INT(3),</span><br><span class="line">    upp INT(3),</span><br><span class="line">    grade char(1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO grade VALUES (90, 100, &#39;A&#39;);</span><br><span class="line">INSERT INTO grade VALUES (80, 89, &#39;B&#39;);</span><br><span class="line">INSERT INTO grade VALUES (70, 79, &#39;C&#39;);</span><br><span class="line">INSERT INTO grade VALUES (60, 69, &#39;D&#39;);</span><br><span class="line">INSERT INTO grade VALUES (0, 59, &#39;E&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM grade;</span><br><span class="line">+------+------+-------+</span><br><span class="line">| low  | upp  | grade |</span><br><span class="line">+------+------+-------+</span><br><span class="line">|   90 |  100 | A     |</span><br><span class="line">|   80 |   89 | B     |</span><br><span class="line">|   70 |   79 | C     |</span><br><span class="line">|   60 |   69 | D     |</span><br><span class="line">|    0 |   59 | E     |</span><br><span class="line">+------+------+-------+</span><br></pre></td></tr></table></figure>

<p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, grade FROM score, grade </span><br><span class="line">WHERE degree BETWEEN low AND upp;</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| s_no | c_no  | grade |</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| 101  | 3-105 | A     |</span><br><span class="line">| 102  | 3-105 | A     |</span><br><span class="line">| 103  | 3-105 | A     |</span><br><span class="line">| 103  | 3-245 | B     |</span><br><span class="line">| 103  | 6-166 | B     |</span><br><span class="line">| 104  | 3-105 | B     |</span><br><span class="line">| 105  | 3-105 | B     |</span><br><span class="line">| 105  | 3-245 | C     |</span><br><span class="line">| 105  | 6-166 | C     |</span><br><span class="line">| 109  | 3-105 | C     |</span><br><span class="line">| 109  | 3-245 | D     |</span><br><span class="line">| 109  | 6-166 | B     |</span><br><span class="line">+------+-------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE testJoin;</span><br><span class="line"></span><br><span class="line">CREATE TABLE person (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    cardId INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE card (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);</span><br><span class="line">SELECT * FROM card;</span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | name      |</span><br><span class="line">+------+-----------+</span><br><span class="line">|    1 | 饭卡      |</span><br><span class="line">|    2 | 建行卡    |</span><br><span class="line">|    3 | 农行卡    |</span><br><span class="line">|    4 | 工商卡    |</span><br><span class="line">|    5 | 邮政卡    |</span><br><span class="line">+------+-----------+</span><br><span class="line"></span><br><span class="line">INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);</span><br><span class="line">SELECT * FROM person;</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| id   | name   | cardId |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|    1 | 张三   |      1 |</span><br><span class="line">|    2 | 李四   |      3 |</span><br><span class="line">|    3 | 王五   |      6 |</span><br><span class="line">+------+--------+--------+</span><br></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。</span><br><span class="line">-- on: 表示要执行某个条件。</span><br><span class="line">SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line"></span><br><span class="line">-- 将 INNER 关键字省略掉，结果也是一样的。</span><br><span class="line">-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。</span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 不支持这种语法的全外连接</span><br><span class="line">-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">-- 出现错误：</span><br><span class="line">-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;</span><br><span class="line"></span><br><span class="line">-- MySQL全连接语法，使用 UNION 将两张表合并在一起。</span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- a -&gt; -100</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- b -&gt; +100</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询事务的自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            1 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE bank;</span><br><span class="line"></span><br><span class="line">USE bank;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    money INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user VALUES (1, &#39;a&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 回滚到最后一次提交</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 关闭自动提交</span><br><span class="line">SET AUTOCOMMIT &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- 查询自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            0 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line"></span><br><span class="line">-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，</span><br><span class="line">-- 发生变化的数据并没有真正插入到数据表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 数据表中的真实数据其实还是：</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 由于数据还没有真正提交，可以使用回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line">-- 手动提交数据（持久性），</span><br><span class="line">-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 提交后测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询（回滚无效了）</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 转账</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- 到账</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假设转账发生了意外，需要回滚。</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p>
<h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务</span><br><span class="line">-- START TRANSACTION;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">-- 由于手动开启的事务没有开启自动提交，</span><br><span class="line">-- 此时发生变化的数据仍然是被保存在一张临时表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 测试回滚（无效，因为表的数据已经被提交）</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li>
<li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li>
<li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li>
<li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。</span><br><span class="line">+--------------------------------+</span><br><span class="line"></span><br><span class="line">-- MySQL 5.x</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;</span><br><span class="line">SELECT @@TX_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">-- 查询系统隔离级别，发现已经被修改。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-UNCOMMITTED               |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);</span><br><span class="line">INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 开启一个事务操作数据</span><br><span class="line">-- 假设小明在淘宝店买了一双800块钱的鞋子：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 然后淘宝店在另一方查询结果，发现钱已到账。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小明所处的事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 此时无论对方是谁，如果再去查询结果就会发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-COMMITTED                 |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正在操作数据事务（当前事务）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，</span><br><span class="line">-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 假设此时在远程开启了一个新事务，连接到数据库。</span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line">-- 此时远程连接查询到的数据只能是已经提交过的</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张在查询数据的时候发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 在小张求表的 money 平均值之前，小王做了一个操作：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO user VALUES (5, &#39;c&#39;, 100);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 此时表的真实数据是：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：</span><br><span class="line">SELECT AVG(money) FROM user;</span><br><span class="line">+------------+</span><br><span class="line">| AVG(money) |</span><br><span class="line">+------------+</span><br><span class="line">|  820.0000  |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小王 - 北京</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></span><br></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| SERIALIZABLE                   |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张 - 成都</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 小王 - 北京</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 开启事务之前先查询表，准备操作数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">|  6 | d         |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 发现没有 7 号王小花，于是插入一条数据：</span><br><span class="line">INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);</span><br></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
]]></content>
  </entry>
  <entry>
    <title>javaee</title>
    <url>/2021/05/21/javaee/</url>
    <content><![CDATA[<h3 id="maven"><a href="#maven" class="headerlink" title="maven:"></a>maven:</h3><p>[1] 根目录：工程名</p>
<p>[2] |—src：源码</p>
<p>[3] |—|—main:存放主程序,目录下是项目的主要代码</p>
<p>[4] |—|—|—java：java源码文件</p>
<p>[5] |—|—|—resource：存放框架的配置文件</p>
<p>[6] |—|—test：存放测试程序,目录下存放测试相关的代码</p>
<p>[7] |—pop.xml：maven的核心配置文件</p>
<p>webapp下存放Web应用相关代码</p>
<a id="more"></a>
<h3 id="常用maven命令"><a href="#常用maven命令" class="headerlink" title="常用maven命令"></a>常用maven命令</h3><p>[1] mvn clean：清理</p>
<p>[2] mvn compile：编译主程序</p>
<p>[3] mvn test-compile：编译测试程序</p>
<p>[4] mvn test：执行测试</p>
<p>[5] mvn package：打包</p>
<p>[6] mvn install：安装</p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h3><p><strong>1、modelVersion</strong></p>
<p>​    指定了当前Maven模型的版本号</p>
<p><strong>2、groupId</strong></p>
<p>　　顾名思义，这个应该是公司名或是组织名。一般来说groupId是由三个部分组成，每个部分之间以”.”分隔，第一部分是项目用途，比如用于商业的就是”com”，用于非营利性组织的就　　是”org”；第二部分是公司名，比如”tengxun”、”baidu”、”alibaba”；第三部分是你的项目名</p>
<p><strong>3、artifactId</strong></p>
<p>　　可以认为是Maven构建的项目名，比如你的项目中有子项目，就可以使用”项目名-子项目名”的命名方式</p>
<p><strong>4、version</strong></p>
<p>　　版本号，SNAPSHOT意为快照，说明该项目还在开发中，是不稳定的版本。在Maven中很重要的一点是，<strong>groupId、artifactId、version三个元素生成了一个Maven项目的基本坐标</strong></p>
<p><strong>5、packing</strong></p>
<p>​    项目打包的类型，可以使用jar，war，rar等，默认jar</p>
<p><strong>6、dependencies和dependency</strong></p>
<p> 前者包含后者。前面说了，Maven的一个重要作用就是统一管理jar包，为了一个项目可以build或运行，项目中不可避免的，会依赖很多其他的jar包，在Maven中，这些依赖就被称为dependency。 </p>
<p><strong>7、properties</strong></p>
<p> properties是用来定义一些配置属性的，例如project.build.sourceEncoding（项目构建源码编码方式），可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级。 </p>
<h3 id="maven-多模块"><a href="#maven-多模块" class="headerlink" title="maven 多模块"></a>maven 多模块</h3><p>Spring MVC：<br>    web开发中的请求-响应模型：<br>        web客户端如：IE浏览器先发送请求，web服务器接收请求，处理请求，然后产生响应，响应再返回网站首页内容，浏览器接收响应并渲染。<br>    web世界里：<br>        web浏览器（如IE）发送请求：如，访问<a href="http://sishuok.com" target="_blank" rel="noopener">http://sishuok.com</a><br>        web服务器（如tomcat）接收请求，处理请求（比如用户新增，则把用户保存一下），最后产生响应（一般为html）<br>        web服务器处理完成后，返回内容给web客户端（一般就是我们的浏览器），客户端对接收的内容进行处理（如web浏览器将会对接收到的html内容进行渲染，展示给客户）<br>        因此，都是web客户端发起请求，web服务器接收，处理并产生响应，一般web服务器不主动通知web客户端更新内容<br>    MVC模型：<br>        一种架构行的模式，本身不引入新的功能，只是将开发的结构组织的更加合理。<br>        展示和模型分离，流程控制逻辑，业务逻辑调用与展示逻辑分离。</p>
<pre><code>图片------

MVC：Model-View-Controller
Model（模型）：数据模型，提供要展示的数据，所以包括数据和行为，可以是领域模型或者JavaBean组件（包含数据和行为），不过现在一般分离开：Value Object（数据） 和 服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
View（视图）：负责进行模型的展示，一般就是看到的用户界面，客户想看到的东西。
Controller（控制器）：接收用户请求，委托模型进行处理（状态改变），处理完毕后把返回的数据返回给视图，视图进行展示。也就是说Controller作了一个调度的工作。

WebMVC：
    标准的MVC能主动推数据给视图进行更新，在web开发中模型无法主动推给视图（无法主动更新用户界面），因为web开发是请求-相应式模型</code></pre>]]></content>
  </entry>
  <entry>
    <title>Java基础复习</title>
    <url>/2021/05/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="path："><a href="#path：" class="headerlink" title="path："></a>path：</h1><p>主要为了检索文件方便，如果要执行某个文件，不用到文件所在目录去找，操作系统会在path路径下找。<br>Classpath：类路径，java运行查找类文件的路径</p>
<h1 id="public-class-和class："><a href="#public-class-和class：" class="headerlink" title="public class 和class："></a>public class 和class：</h1><p>​    public class声明类，文件名和类名必须一致，class声明类，文件名任意，但生成的class文件名称和类名一样，不和原文件名一致。</p>
<a id="more"></a>

<h1 id="类的命名："><a href="#类的命名：" class="headerlink" title="类的命名："></a>类的命名：</h1><p>首字母大写，单词之间首字母大写</p>
<h1 id="标识符和标识符命名："><a href="#标识符和标识符命名：" class="headerlink" title="标识符和标识符命名："></a>标识符和标识符命名：</h1><p>​    必须由数字，字母，下划线，和美元符号构成，不能以数字开头，区分大小写，最好见名知意，只用驼峰形式，第一个单词首字母为小写，其他单词首字母为大写，例如：fatherMather()</p>
<h1 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h1><p>​    全部都是小写。</p>
<h1 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h1><p>基本数据类型：</p>
<p>​    数值类型：<br>​            整数：byte，short，int，long<br>​            浮点：float，double<br>​    字符类型；char<br>​    布尔类型：boolean<br>引用数据类型： 数组,类,接口</p>
<!--more-->
<h1 id="字符编码："><a href="#字符编码：" class="headerlink" title="字符编码："></a>字符编码：</h1><p>ASCII：采用一个字节编码，主要针对英文编码<br>ISO-8859-1：(latin-1) ISO制定，主要为西欧语言编码，兼容ASCII<br>GBK/GB2312/GB18030：主要是汉字编码<br>unicode：统一全世界所有文字编码，有几种实现：UTF-8，TUF-16，UTF-32<br>java中的char使用的是utf-16编码，所以一个char类型变量可以存放一个汉字</p>
<h1 id="java整数常量表示方法："><a href="#java整数常量表示方法：" class="headerlink" title="java整数常量表示方法："></a>java整数常量表示方法：</h1><p>默认整数型为int，long类型后最好加上大写的L，小写容易混淆<br>十进制：默认是十进制<br>八进制：以0开头，如013<br>十六进制：以0x开头，如0x23</p>
<h1 id="java浮点类型："><a href="#java浮点类型：" class="headerlink" title="java浮点类型："></a>java浮点类型：</h1><p>默认是double<br>double为8个字节，float为4个字节<br>double向float转换会出现精度丢失<br>声明float，数值后必须加上f，如:float f = 10.5f；</p>
<h1 id="基本类型转换："><a href="#基本类型转换：" class="headerlink" title="基本类型转换："></a>基本类型转换：</h1><p>boolean特殊，不能转换为其他类型<br>默认转换：<br>    byte–&gt;short(char)–&gt;int–&gt;long–&gt;float–&gt;double<br>    byte,short,char之间不会相互转换，首先先转换为int<br>强制转换：<br>    容量大类型转换为容量小类型<br>    只要不超过范围，可以直接将整数值赋值给byte，short，char</p>
<h1 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h1><p>短路与和逻辑与：<br>    短路与：从第一个判断数推断结果，只要第一个是false，不计算第二个操作数<br>    逻辑与：两个操作数都计算<br>短路或和逻辑或：<br>    短路或：从第一个操作数推断结果，只要是true，不计算第二个操作数<br>    逻辑或：两个操作数都计算<br>条件运算符：<br>    op1？op2：op3<br>    如果操作数op1为true，则输出op2，否则输出op3</p>
<h1 id="switch语句："><a href="#switch语句：" class="headerlink" title="switch语句："></a>switch语句：</h1><p>switch(表达式){<br>         case 值1: 语句 break;<br>         case 值2: 语句 break;<br>         default 语句<br>}<br>     表达式中的值只能是：char，byte，short，int 类型，boolean ，long，float，double都是非法的<br>break语句可以省略，但会出现switch穿透<br>default 语句也可以省略，一般不建议省略</p>
<h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><p>​    方法的修饰符有：public，protected，private，abstract，static，final，synchronized<br>​    方法名：符合合法的标识符（驼峰式）</p>
<h2 id="方法重载：（多态的一种）"><a href="#方法重载：（多态的一种）" class="headerlink" title="方法重载：（多态的一种）"></a>方法重载：（多态的一种）</h2><p>​    重载条件：<br>​        方法名相同<br>​        方法的参数类型，个数，顺序至少有一个不同<br>​        方法的返回值可以不同也可以相同，（不依靠返回值类型区分重载）<br>​        方法的修饰符可以不同，方法重载和修饰符没有关系<br>​        方法重载只出现在一个类中</p>
<h1 id="面向过程和面向对象："><a href="#面向过程和面向对象：" class="headerlink" title="面向过程和面向对象："></a>面向过程和面向对象：</h1><p>​    面向过程：必须了解整个过程，每个步骤的因果关系，每个步骤很难分离<br>​    面向对象：将现实世界分割成不同单元(对象),实现每个对象，如果完成某个功能，只需要将每个对象协作起来就可以了</p>
<h2 id="面向对象的三大特性："><a href="#面向对象的三大特性：" class="headerlink" title="面向对象的三大特性："></a>面向对象的三大特性：</h2><p>​    封装<br>​    继承<br>​    多态</p>
<h1 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a>类和对象：</h1><p>对象也叫实例，类的具体化就是对象或实例<br>好处：更符合人的思维模式，更容易分析<br>面向对象开发的三个阶段：<br>    OOA：面向对象的分析<br>    OOD：面向对象的设计<br>    OOP：面向对象的编程 —–Java是纯面向对象的语言<br>类 = 属性 ＋ 方法<br>    属性来源于类的状态，方法来自于动作<br>    类中的成员变量和局部变量，成员变量会默认初始化，默认初始化为该变量的默认值，局部变量必须在使用前初始化，</p>
<p>对象的创建和使用：<br>    必须是new出来，才能用<br>    一个类可以创建N个对象，成员变量只属于当前的对象（只属于对象，不属于类），只能通过对象才能访问成员变量，通过类不能直接访问成员变量</p>
<p>面向对象封装：<br>    使用private声明成员变量，成员变量只属于对象，属性只能通过方法访问<br>    封装属性，暴露方法</p>
<p>构造方法：<br>    声明格式：构造方法修饰词 类名 (参数列表)<br>    构造方法修饰词：public，protected，private<br>    构造方法可重载<br>    特点：<br>        方法名必须和类名一致<br>        构造方法不具有返回值，也没有void，否则就成为了普通的方法<br>        每个类都有构造方法，没有明显显示，系统会默认的定义一个不含任何参数的构造方法</p>
<p>this关键字：<br>    this指的是当前调用的对象，有100个对象就有100个this<br>    this的使用：<br>        局部变量和成员变量重名的时候，this指定调用成员变量<br>        通过this调用另一个构造方法<br>        在构造方法中，如果使用this调用构造方法，this语句必须放在第一行，否则会报错<br>        this只能用在构造方法和成员方法内部(声明变量也可以用)，static标识的方法里不能使用this</p>
<p>static关键字：<br>    静态的意思，可以修饰成员方法，成员变量<br>    特点：被类的所有对象共享，这也是我们判断是否使用静态关键字的条件，可以通过类名调用，当然也可以通过对象名调用（推荐使用类名）<br>    访问特点：<br>        非静态的成员方法：<br>            能访问静态的成员变量，能访问非静态的成员变量，能访问静态的成员方法，能访问非静态的成员方法<br>        静态的成员方法：能访问静态的成员变量，能访问静态的成员方法<br>    可修饰：变量，方法，代码块<br>    用static修饰的变量和方法，可以采用类名访问<br>    用static声明的代码块为静态代码块，jvm加载类的时候，会执行静态代码块的内容<br>    static声明的变量，所有的通过该类new出来的对象，都可以访问该变量，类也可以访问，所以叫类变量。<br>    总结：静态的只能调用静态的</p>
<p>静态方法：<br>    静态方法不能直接调用实例变量，实例方法和this，和实例相关的，都不能直接调用。</p>
<p>静态变量<br>    在类加载的时候就会初始化，就是将类的字节码读取到方法区就初始化了</p>
<p>main方法：<br>    public：表示全局所有，就是封装性<br>    static：静态的，也就是说它描述的方法只能通过类调用<br>    main：系统规定<br>    String[]args：参数类型也是系统规定的<br>    静态方法，java虚拟机调用方便，直接拿到类就能调用main方法，静态的东西都在方法区，静态方法调用成员属性，在方法区无法找到，就算在堆区找到，对象也没有创建，所以，静态方法不能直接访问成员属性和成员方法。</p>
<h2 id="类的继承："><a href="#类的继承：" class="headerlink" title="类的继承："></a>类的继承：</h2><pre><code>继承的注意事项：只支持单继承，不支持多继承，但支持多层继承

继承的好处和弊端：提高代码的复用率（多个类相同的成员可以放在同一个类中）
提高代码的维护性
继承让类与类之间产生关系，类的耦合性增强，当父类发生变化时子类实现也不得不跟着变化，削弱子类的独立性。

继承的应用场景：
    使用继承，需要考虑类与类之间是否考虑is，a的关系，不能盲目使用继承</code></pre><p>​    关键字：extends<br>​    继承是面向对象的重要概念<br>​    继承提高软件可重用性<br>​    java只支持类的单继承<br>​    软件设计原则：重复代码最好不要重复两次或多次</p>
<pre><code>​    



方法的覆盖/重写（Override）：</code></pre><p>​    方法覆盖的条件：<br>​        必须有继承关系<br>​        覆盖只能出现在子类中，没有继承关系，不存在覆盖，只存在重载<br>​        在子类中被覆盖的方法，必须和父类的方法完全一致，方法名，返回类型，参数列表，完全一样<br>​        <strong>子类方法的访问权限不能小于父类方法的访问权限</strong><br>    方法重写的应用场景：<br>        当子类需要父类的功能，而功能主体子类有自己独特内容，可以重写父类方法中的方法，沿袭父类的功能，又定义子类特有的内容<br>    Override注解：监测当前方法，是否是重写的方法，起到检验的作用</p>
<pre><code>方法重写的注意事项：
    私有方法不能被重写，子类方法访问权限不能更低；

继承中变量的访问：就近原则，子类没有找到变量，在父类找，不考虑父类的父类。</code></pre><h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h2><p>重载式多态：<br>    也叫编译时多态，这种多态在编译时就确定好了，在调用这种重载式方法的时候，传入不同的参数，最后得到不同的结果，就是一种多态。<br>重写式多态：<br>        也叫运行时多态，多态通过动态绑定来实现，在执行期间判断引用对象的实际类型，根据实际类型调用相应方法</p>
<p>多态中的成员访问特点：<br>    成员的访问特点：成员变量—-&gt;编译看父类，运行看父类;成员方法—-&gt;编译看父类，运行看子类;</p>
<p>多态的好处和弊端：<br>    好处：提高程序的扩展性，定义方法的时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作<br>    弊端：不能使用子类的特有成员</p>
<p>多态的转型：<br>    向上转型：父类引用指向子类对象就是向上转型<br>    向上转型：子类型 对象名 = （子对象）父类引用;</p>
<p>对静态方法的覆盖：<br>    静态方法不存在多态的概念，多态和成员方法相关，静态方法值属于某一个类，声明的是哪一个类，就调用的是哪一个类的静态方法，和子类没有关系。new谁调谁。<br>    为什么覆盖成员方法可以构成多态，主要是运行期间的动态绑定，静态绑定的含义是在编译成class文件的时候已经确定好调用哪个方法。</p>
<p>super关键字：<br>    调用父类的构造方法和成员方法<br>    super只能应用在成员方法和构造方法中，不能应用在静态方法中，和this一样，如果在构造方法中使用，必须放在第一行。<br>    子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父也就没有子<br>    有时需要在子类中显示的调用父类的成员方法</p>
<p>final关键字：<br>     final的应用：final的意思是最终的意思 可以修饰成员变量，方法，类</p>
<pre><code>采用final修饰的类不能被继承
采用final修饰的方法不能被覆盖
采用final修饰的变量不能被修改
final修饰的变量必须显示初始化
如果修饰的是引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象可以修改。
构造方法不能被final修饰
final定义的静态变量，调用时不会执行java的类初始化方法，也就是说不会执行static代码块等相关语句。
final修饰引用数据类型变量：final修饰的引用类型的地址值不能发生变化，但地址里面的内容是可以变化的</code></pre><p>抽象类：<br>    采用sbstract关键字定义的类就是抽象类，采用abstract关键字定义的方法就是抽象方法<br>    抽象的方法只需要在抽象类中，提供声明，不需要实现<br>    如果一个类包含抽象方法，那么这个类必须是抽象类<br>    一个类是抽象的，那么这个类被子类继承，抽象方法必须复写，如果在子类中不复写抽象方法，那么必须将此方法声明为抽象方法。<br>    抽象的类是不能被实例化的<br>    抽象类不能被final修饰，因为抽象方法就是被子类实现的，而且final修饰的类不能被继承。<br>    抽象的方法只需在抽象类中，提供声明，不需要实现，起到一个强制的约束作用，要求子类必须实现。<br>    如果一个类是抽象的，那么这个类被子类继承，抽象方法必须被覆盖。如果子类不覆盖该抽象方法，那么必须将方法再次声明为抽象方法，继承的子类也成为了抽象子类。<br>    抽象类不能被final修饰<br>    抽象类特点：<br>        抽象类和成员方法必须用abstract关键字修饰;<br>        抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类;<br>        抽象类不能被实例化<br>        抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类</p>
<pre><code>抽象类的成员特点：
    成员变量：既可以是变量，也可以是常量
    构造方法：空参构造，有参构造
    成员方法：抽象方法，普通方法</code></pre><p>接口：<br>    接口可以看做是抽象类的一种特殊情况，在接口中只能定义抽象的方法和变量。<br>    java接口要用interface声明<br>    接口的方法默认就是public abstract的，不能修改<br>    接口的变量时public static final类型的，不能改变，所以必须显示的初始化。<br>    接口不能被实例化，接口没有函数的概念。<br>    接口之间可以继承，接口之间不能实现。<br>    接口的方法只能通过类来实现，通过implements关键字<br>    如果一个类实现了接口，接口里的方法必须全部实现<br>    一个类可以实现多个接口<br>    接口中的方法默认是public abstract的，不能更改<br>    接口中的变量是public static final类型的，不能更改，所以必须显示的初始化。就算是没有关键词final修饰，例如 String y=”yes”; y也是默认加上public static final的<br>    接口不能被实例化，接口没有构造函数的概念</p>
<p>接口的进一步应用：<br>    在java中接口其实描述了类需要做的事情，类要遵循接口的定义来做事。<br>    使用接口的好处：<br>        采用接口明确的声明了他所能提供的服务<br>        解决了java单继承的问题<br>        实现了可接插性（重要）</p>
<p>类和接口的关系：<br>    类与类的关系：继承关系，只能单继承，但是可以多层继承<br>    类和接口的关系：实现关系，可以单实现，也可以多实现，还可以继承一个类同时实现多个接口。<br>    接口与接口的关系：继承关系，可以单继承，也可以多继承！！！。</p>
<p>多态：<br>    多种状态的含义。<br>    如方法重载，相同的方法名称考可以完成不同的功能，这就是多态的一种表现，此时成为静态多态。<br>    如将学生数据保存的示例，当调用接口的方法，java就自动调用实现类的方法，如果Oracle实现级调用Oracle的方法，如果是MySql实现的就调用MySql中的方法，这是在运行时决定的，叫做运行时多态。<br>    多态的条件：<br>        有继承或实现，有方法覆盖或实现，父类对象（接口）指向子类对象<br>    接口和抽象类的区别：<br>        接口描述方法的特征，不给出实现，一方面解决了java的单继承问题，实现了可接插性。<br>        抽象类提供了部分实现，抽象类是不能实例化的，抽象类的存在主要是把公共的代码移植到抽象类中。<br>        面向接口编程，不要面向具体编程（面向抽象编程，不面向具体编程）<br>        优先选择接口（因为继承抽象类后，此类将无法再继承，所以丧失了类的灵活性）</p>
<p>类之间的关系：<br>    泛化关系：类和类之间的继承关系及接口之间的继承关系<br>    实现关系：类对接口的实现<br>    并联关系：类和类之间的连接，一个类可以知道另一个类的属性和方法，在java语言中使用实例变量体现<br>    聚合关系：是关联关系的一种，是较强的关联关系，是整体和部分的关系，如汽车和轮胎，聚合关系的类处在不平等的层次上，一个代表整体，一个代表部分<br>    合成关系：是关系的一种，比聚合关系强的关联关系，如：人和四肢，整体对象决定部分对象的生命周期，部分对象每一时刻只与一个对象发生合成关系<br>    依赖关系：比关联关系弱，在java语言中体现在返回值，参数，局部变量和静态方法调用</p>
<p>Object类：<br>    Object类是所有Java类的基类<br>    如果在类的声明中未使用extends关键字指明基类，则默认基类为Object类</p>
<p>toString():<br>    返回该对象的字符串表示，通常toString方法会返回一个”以文本方式表示”此对象的字符串，Object类的toString方法返回一个字符串，该字符串由类名加标记@和此对象的哈希码的无符号十六进制表示组成，</p>
<p>finalize：<br>    垃圾回收器（Garbage Collection），也叫GC，垃圾回收器的主要特点：<br>        当对象不再被程序使用时，垃圾回收器将其回收<br>        垃圾回收是在后台运行的，无法命令垃圾回收器马上回收资源但是可以告诉它，尽快回收资源（System.gc和Runtime.getRuntime().gc()）<br>        垃圾回收器在回收某个对象的时候，首先会调用该对象的finalize方法<br>        GC主要针对堆内存</p>
<p>==和equals方法：<br>    等号可以比较基本类型和引用类型，等号比较的是值，特别是比较引用类型，比较的是引用的内存地址<br>    equals方法比较对象的地址，字符串的equals方法是比较的内容</p>
<p>包和import：<br>    包：其实就是目录，特别是项目比较大的时候，java文件特别多的时候，应该分目录管理，在java中称为分包管理，包的名称通常采用小写<br>        包最好采用小写字母<br>        包的命名要有规则，不能重复，一般采用公司网站的逆序<br>        package必须放在所有语句的第一行，注释除外<br>    import:<br>        采用import引入需要使用的类<br>        可以采用*通配符，引入包下的所有类（方式不明确，效率较低，但简单）<br>        如果都在同一个包下，就不需要import引入了</p>
<p>JDK常用开发包：<br>    java.lang:语言标准包，使用此包中的内容无需import引入<br>    java.sql:提供JDBC接口类<br>    java.util：提供常用工具类<br>    java.io:提供各种输入输出流</p>
<p>修饰符：<br>    package：<br>        包是文件夹，用来管理文件；<br>        包的定义格式：<br>            package 包名；（多级包，分开）<br>            例如：package com.edu.demo<br>        带包编译&amp;带包运行<br>            带包编译：javac -d.类名.java<br>            带包运行：java 包名+类名<br>    import:<br>        导包的意义：使用不同包下的类时，使用的时候要写类的路径，写起来很麻烦为了简化导包的操作，java就提供导包的功能<br>        导包的格式：import 包名</p>
<p>访问权限控制符：<br>    java访问修饰符主要包括：private，protected，public，可以限定其他类对该类，属性和方法的使用权限。</p>
<pre><code>修饰符      类的内部        同一个包里      子类（不同包中）        任何地方
private     Y               N               N                       N
protected   Y               Y               Y                       N
public      Y               Y               Y                       Y
default     Y               Y               N                       N
对类的修饰只有public和default，内部类除外





private:private声明的变量或方法，只能在同一个类中使用
protected：采用protected声明的变量或方法只能子类或者同一个包下的类可以调用。
default：如果class不采用public修饰的话，此时的class只能被该包下的类访问，其他包无法访问</code></pre><p>内部类：<br>    在一个类的内部定义的类，叫做内部类<br>    内部类的分类：<br>        实例内部类<br>            创建实例内部类，外部类的实例必须已经创建<br>            实例内部类会持有外部类的引用<br>            实例内部不能定义static成员，只能定义实例成员<br>        局部内部类<br>            局部内部类是在方法中定义的，只能在当前方法中使用，和局部变量的作用一样，局部内部类和实例内部类一致，不能包含静态成员。局部变量在内部类中使用必须采用final修饰<br>        静态内部类<br>            静态内部类不会持有外部的类的引用，创建时可以不用创建外部类<br>            静态内部类可以访问外部的成员变量，如果访问外部类的成员变量，必须通过外部类的实例访问<br>        匿名内部类<br>            特殊内部类，没有名字。</p>
<p>JVM的内存结构中三块比较重要的内存空间。<br>    方法区：<br>        存储代码片段，存储xxx.class字节码文件，这个空间是最先有数据的，<br>        类加载器首先将代码加载到这里。<br>    堆内存：<br>        用来存放各种类的实例对象<br>    栈内存：<br>        stack栈当中存储什么？<br>            每个方法执行时所需要的内存空间（局部变量）。</p>
<p>System.out.println(“Hello World!”)：<br>        System.out 中，out后面没有小括号，说明out是变量名。<br>        另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。<br>        System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。</p>
<p>java和c++的区别：</p>
<p>都是面向对象的语言</p>
<p>java不提供指针直接访问内存，程序内存更安全</p>
<p>java的类是单继承，c++支持多继承，虽然java的类不可以多继承，但是接口可以多继承</p>
<p>java有自动内存管理机制，不需要人手动释放无用内存。</p>
<p>c语言中，字符串或字符数组最后都会有额外的字符‘\0’来表示结束，java里没有结束符的概念。</p>
<p>import java和javax：</p>
<p>javax之前是Java的拓展包，后来成为java的标准API的一部分，没啥区别了。</p>
<p>编译和解释型语言：</p>
<p>编译型语言：编译器针对指定的操作系统将源代码一次性翻译成可被平台执行的机器码</p>
<p>解释型语言：解释器对源程序逐行解释成特定平台的机器码并立即执行。</p>
<p>java程序是要先编译后解释，经过两个步骤。所以java是编译和解释并存。</p>
<p>字符常量和字符串常量区别：<br>形式上：字符常量使用单引号，字符串常量使用双引号</p>
<p>含义上：字符常量相当于一个整数值（ASCII），可参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放的位置）</p>
<p>内存大小：字符常量只占2个字节，字符串常量占若干个字节。</p>
<p>泛型：</p>
<p>==和equals的区别：</p>
<p>==：判断两个对象的地址是否相等，即判断两个对象是不是一个对象。</p>
<p>（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）</p>
<p>因为java只有值传递，所以==，不管是比较基本数据类型，还是引用数据类型的变量，本质都是比较值，只是引用类型变量的值是对象的地址。</p>
<p>equals()：判断两个对象是否相等，不能用于比较基本数据类型的变量。</p>
<p>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>诸如String，Date等类对equals方法进行重写的话，比较所指对象的内容。</p>
<p>为什么重写equals方法必须重写hsahCode方法？（待整理）</p>
<pre><code>hashCode()：获取哈希值，也称散列码，实际返回的是int整数。哈希码的作用是确定该对象在哈希表的索引位置。hashCode()定义在JDK的Object类中，意味着java中的任何类都包含hashCode()函数。注意：Object的hashCode方法是本地方法，也就是c语言或者c++实现的，该方法会用来将对象的内存地址转换为整数返回。

强调：向HsahSet或者HashMap中加入数据时，必须同时覆盖equals和hashCode方法
    两个对象的equals相等，那么他们的hashCode相等，两个对象的equals不相等，hashCode不要求相等。</code></pre><p>Java中的几种基本类型和对应的包装类：（待整理）<br>    基本类型:<br>        6种数字类型：byte，short，int，long，float，double<br>        1种字符类型：char<br>        1种布尔类型：boolean (默认false)<br>        Java里使用long类型的时候，要在数值后面加上L<br>        char类型用单引号，String用双引号。<br>    自动拆箱和装箱：<br>        装箱：将基本类型用他们对应的引用类型包装起来；<br>        拆箱：将包装类型转换为基本类型；</p>
<p>String的两种创建方式：<br>    1：双引号的方式，是在编译生成class文件的时候，字符串就存放在常量池里的，定义一个新的字符串的时候，先从常量池里找有没有这个字符串，有的话直接拿来用，没有的话，放进去后，再用。<br>    2：new关键字创建，创建一个字符串对象，对象放在堆区内存中，每次创建一个字符串的时候，创建一个新的字符串对象，字符串内容一样，字符串的引用不一样，可以用==来判断一下，不能用equals方法来判断，因为String类重写了toString方法。</p>
<pre><code>因为String是不可变对象，多个字符串拼接的话，会形成多个对象，可能会造成内存溢出，拼接的时候可以使用StringBuffer和Builder</code></pre><p>枚举：<br>        采用枚举能够限定取值的范围，在程序编译的时候，及早返回错误，使程序更加健壮</p>
<p>Treeset：<br>    可以放入不重复的数据，而且会进行排序，但必须实现Comparable接口，基本类型的包装类和String已经实现了该接口</p>
<p>Comparable和 Comparator区别：<br>    一个类实现Comparable接口表明这个类的对象之间可以相互比较，对象组成的集合可以直接使用sort方法排序。<br>    Comparator可以看做一种算法的实现，将算法和数据分离，Comparator也可以在两种情况下使用：<br>        1：类本身没有考虑到比较问题而没有实现Comparable,可以通过Comparator来实现排序，不必改变对象本身<br>        2：可以使用多种排序标准，降序，升序。<br>    对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</p>
<pre><code>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</code></pre><p>HashMap：<br>    HashMap底层实现是hash表，所以Map的Key，必须重写hashCode和equals方法。</p>
<p>TreeMap：<br>    TreeMap可以对Map中的Key进行排序，如果map中的key采用的是自定义类，那么需要实现Comparable或者Comparator接口完成排序</p>
]]></content>
  </entry>
  <entry>
    <title>Java代码练习</title>
    <url>/2021/06/12/Java%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>2021-6-12<br>冒泡排序：<br>import java.util.Scanner;<br>public class bubbleSortTest {<br>    public static void main(String[] args) {<br>        Scanner input = new Scanner(System.in);<br>        int a[] = new int[10];<br>        for(int i = 0;i&lt;a.length;i++){<br>            a[i] = input.nextInt();<br>        }<br>        System.out.println(“冒泡排序未排序前数组：”);<br>        //for each 循环<br>        for (int i:a) {<br>            System.out.print(i+”  “);<br>        }<br>        //冒泡排序：<br>        int d=0;<br>        for (int i=0; i&lt;a.length-1;i++){<br>            for (int j=0;j&lt;a.length-i-1;j++) {<br>                if (a[j] &lt; a[j + 1]) {<br>                    d = a[j];<br>                    a[j] = a[j + 1];<br>                    a[j + 1] = d;<br>                }<br>            }<br>    }<br>        //冒泡排序后的结果<br>        System.out.println(“冒泡排序后”);<br>        for (int i=0;i&lt;a.length;i++){<br>            System.out.print(a[i]+”   “);<br>        }<br>}}</p>
<p>选择排序：<br>public class selectionSortTest {<br>    public static void main(String[] args) {<br>        int []arr = new int[]{1,2,3,9,8,7,6,5,4,10};<br>        selectSort(arr);<br>        for (int i=0;i&lt;arr.length;i++){<br>            System.out.println(arr[i]+”   “);<br>        }<br>    }<br>    public  static void selectSort(int[] a){<br>        //实现冒泡排序,从小到大排列<br>        //数组要遍历a.length遍<br>        int minIndex=0;<br>        for (int i=0;i&lt;a.length;i++){<br>            minIndex = i;//记录一下最小值的索引<br>            for (int j=i+1;j&lt;a.length;j++){<br>                if (a[minIndex]&gt;a[j]){<br>                    minIndex=j;<br>                }<br>            }<br>            //将最小值和起始值进行交换<br>            int d=a[i];<br>            a[i]=a[minIndex];<br>            a[minIndex]=d;<br>        }</p>
<pre><code>}
}</code></pre><a id="more"></a>
<p>二分查找：<br>import java.util.Scanner;<br>import java.math.*;<br>public class binarySearch {<br>    public static void main(String[] args) {<br>        Scanner input =new Scanner(System.in);<br>        int[] a = new int[]{1,2,3,4,5,6,7,8,9,10};<br>        System.out.println(“数组：”);<br>        for (int i=0;i&lt;a.length;i++){<br>            System.out.print(a[i]+” “);<br>        }<br>        System.out.println(“输入你想查找的数：”);<br>        int b = input.nextInt();<br>        //递归实现：<br>//        System.out.println(“—————–递归实现———————-“);<br>//        int findnumIndex =find(b,a,0,a.length-1);<br>//        System.out.println(“findnumIndex:”+findnumIndex);<br>        System.out.println(“——————-while实现———————–”);<br>        //循环实现<br>        int first=0;<br>        int last = a.length-1;<br>        int mid = (first+last)/2;<br>        if (b==mid){<br>            System.out.println(“findnumIndex:”+mid);<br>        }<br>        while (b!=a[mid]){<br>           if (b&lt;a[mid]){<br>               last = mid;<br>               mid = (first+last) /2;<br>           }else if(b&gt;a[mid]){<br>                first = mid;<br>                mid = (first+last)/2;<br>           }else if (b==a[mid]){<br>               System.out.println(“findnumIndex:”+mid);<br>           }<br>        }<br>        System.out.println(“findnumIndex:”+mid);<br>    }</p>
<pre><code>//findNum  想查找的目标数字，a：查找的数组     start:查找数组起始位置    fin:查找的数组的末尾位置
//返回目标数字所在的索引
public static int find(int findNum ,int[] a,int start,int fin){

    int mid = a[start]+a[fin];
    mid = mid/2;
    if (findNum&lt;a[start] || findNum&gt;a[fin]){
        System.out.println(&quot;该数不在此数组内&quot;);
        return -1;
    }else if (findNum&lt;mid) {
        fin=mid;
        return find(findNum,a,start,fin);
    }
    else if (findNum&gt;mid){
        start = mid;
        return find(findNum,a,start,fin);
    }else if(findNum==mid) {
        return mid;
    }
        return -1;

}</code></pre><p>}</p>
<p>2021-6-13<br>比较字符串地址值<br>public class stringPoolTest {<br>    public static void main(String[] args) {<br>        String s1 = “abc”;<br>        String s2 = “abc”;<br>        String s3  = new String(“abc”);<br>        System.out.println(s1==s2);//s1,s2都是来源于一个字符串常量池的停用<br>        System.out.println(s1==s3);//一个是字符串常量池的地址值，一个是字符串对象的地址。<br>        System.out.println(s1.equals(s3));//String重写了toString方法，比较的是内容，所以为true<br>    }<br>}</p>
<p>2021-6-15</p>
<p>泛型自动类型推断<br>import java.util.ArrayList;</p>
<p>public class genericsTest {<br>    public static void main(String[] args) {<br>        //jdk7新特性，后面的尖括号不用填写东西<br>        ArrayList<animal> arrayList = new ArrayList&lt;&gt;();<br>        //普通写法<br>        ArrayList<animal> arrayList1 = new ArrayList<animal>();<br>    }<br>}<br>class animal{</p>
<p>}</p>
<p>switch支持String：</p>
<p>public class switchTest {<br>    public static void main(String[] args) {<br>        //Switch支持String<br>        String name = “cui”;<br>        switch(name){<br>            case “jin”: System.out.println(“jin”);break;<br>            case “cui”: System.out.println(“cui”);break;<br>            case “hao”: System.out.println(“hao”);break;<br>            default:<br>                System.out.println(“没有cui”);break;<br>        }<br>    }<br>}</p>
<p>Integer的常量池：<br>public class intergerPoolTest {<br>    public static void main(String[] args) {<br>        int a1= 100;<br>        int a2 = 100;<br>        System.out.println(“a1== a2”+(a1== a2));//true<br>        int e1= 100000;<br>        int e2 = 100000;<br>        System.out.println(“e1== e2”+(e1== e2));//true</p>
<pre><code>    Integer b1 = 100;
    Integer b2 = 100;
    System.out.println(&quot;b1==b2:&quot;+(b1==b2));//true
    Integer c1 = 1000;
    Integer c2 = 1000;
    System.out.println(&quot;c1==c2:&quot;+(c1==c2));//false
}</code></pre><p>}</p>
<p>2021-6-17<br>Collection练习：</p>
<p>import java.util.*;</p>
<p>public class collectionTest {<br>    public static void main(String[] args) {<br>        //创建Collection集合的对象<br>        Collection<String> c = new ArrayList<String>();<br>        //添加元素：bollean add(E e)<br>        c.add(“hello”);<br>        c.add(“World”);<br>        c.add(“demo”);<br>        System.out.println(c);<br>        System.out.println(“===========================”);<br>        List arr1 = new ArrayList&lt;&gt;();<br>        arr1.add(1);<br>        arr1.add(2);<br>        arr1.add(2);<br>        arr1.add(2);<br>        arr1.add(2);<br>        Iterator iterator = arr1.iterator();<br>        while (iterator.hasNext()){<br>            Integer a = (Integer) iterator.next();<br>            System.out.println(a);<br>        }</p>
<pre><code>}</code></pre><p>}</p>
<p>枚举练习：</p>
<p>public class enumTest {<br>    public static void main(String[] args) {<br>        Color color = Color.green;<br>        switch (color){<br>            case red:<br>                System.out.println(“红色”);<br>                break;<br>            case blank:<br>                System.out.println(“灰色”);<br>                break;<br>                case yellow:<br>                System.out.println(“黄色”);<br>                break;<br>            default:<br>                System.out.println(“没有yanse”);</p>
<pre><code>    }
    int value1 = 3;
    int value2 = 4;
    Result result = method1(value1,value2);
    System.out.println(result);//FAILURE
    //result的变量类型：
    System.out.println(result.getClass().getName());//enumTest$Result
}
private static Result method1(int value1,int value2){
    if(value1&gt;value2)return Result.SUCCESS;
    if(value1&lt;=value2)return Result.FAILURE;
    else return Result.FAILURE;
}
public  enum  Color{
    red,green,blank,yellow
}
enum Result{
    SUCCESS,FAILURE
}</code></pre><p>}</p>
<p>2021-6-21<br>集合类练习：<br>import java.lang.reflect.Array;<br>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;</p>
<p>public class genericsTest01 {<br>    public static void main(String[] args) {<br>        List list =new ArrayList();<br>        list.add(1);<br>        list.add(2);<br>        list.add(4);<br>        list.add(3);<br>        for (Iterator iter = list.iterator(); list.iterator().hasNext();){<br>            System.out.println(iter.next());<br>        }</p>
<pre><code>}</code></pre><p>}</p>
]]></content>
  </entry>
  <entry>
    <title>中原工学院数据库系统概论试题</title>
    <url>/2021/06/05/%E4%B8%AD%E5%8E%9F%E5%B7%A5%E5%AD%A6%E9%99%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="《数据库系统概论》期末考试卷"><a href="#《数据库系统概论》期末考试卷" class="headerlink" title="《数据库系统概论》期末考试卷"></a>《数据库系统概论》期末考试卷</h1><h2 id="一，填空题"><a href="#一，填空题" class="headerlink" title="一，填空题"></a>一，填空题</h2><p>1.实体之间的联系按照联系方式的不同可分为  <u>一对一</u> 、 <u>一对多</u> 和 <u>多对多</u>   。  </p>
<p>2.数据库系统的核心是  <u>数据库管理系统（DBMS）</u>。</p>
<p>3.在关系模型中，实体以及实体间的联系都是用  <u>关系</u>  来表示的。</p>
<p>4.在关系代数中专门的关系运算包括   <u>选择   、投影、   连接    、除</u>等运算。</p>
<p>5.1975年由IBM公司的M.Zloof提出的QBE语言是一个很有特色的 <u>域关系演算</u>   语言。</p>
<p>6.SQL语言集<u>数据查询</u>、  <u>数据操作</u>    、  <u>数据定义</u>和  <u>数据控制</u>   功能于一体，充分体现了关系数据语言的特点和优点。</p>
<p>7.数据库管理系统保证数据安全的主要措施是进行  <u>存取控制</u>     。</p>
<p>8.人们已经提出了许多种类型的数据依赖，其中最重要的是  <u>函数依赖</u>    和 <u>多值依赖</u>  。</p>
<p>9.关系模式由3NF转化为BCNF是消除了主属性对码的  <u>部分函数依赖</u>   和 <u>传递函数依赖</u>    。</p>
<p>10.数据库设计应包括两个方面的内容： <u>结构设计</u>和   <u>行为设计</u>。</p>
<p>11.CGI规范允许Web服务器执行  <u>外部程序</u>    ，并将它们的输出发送给浏览器。</p>
<p>12.数据库技术与  <u>面向对象</u>    技术相结合，形成了面向对象数据库系统。</p>
<a id="more"></a>
<h2 id="二，单项选择"><a href="#二，单项选择" class="headerlink" title="二，单项选择"></a>二，单项选择</h2><p>1.数据库类型是按照(  B  )来划分的。</p>
<p> A.文件形式    B.数据模型  C.记录形式    D.数据存取方法</p>
<p>2.关系演算的基础是(   C  )</p>
<p> A.形式逻辑中的逻辑演算   B.形式逻辑中的关系演算 C.数理逻辑中的谓词演算  D.数理逻辑中的形式演算</p>
<p>3.若要求分解保持函数依赖，那么模式分解一定能够达到(  B   )</p>
<p> A. 2NF      B. 3NF      C. BCNF      D. 1NF</p>
<p>4.1级封锁协议加上T要读取的数据R加S锁，这是(   C  )</p>
<p> A. 3级封锁协议   B. 4级封锁协议   C. 2级封锁协议  D. 1级封锁协议</p>
<p>5.建立数据字典的时机是(  A  )</p>
<p> A.需求分析阶段   B.数据库物理设计阶段   C.数据库实施  D.概念结构设计阶段</p>
<h2 id="三，简答题"><a href="#三，简答题" class="headerlink" title="三，简答题"></a>三，简答题</h2><p>1.简述数据库管理系统的功能。</p>
<p>DBMS功能包括：</p>
<p>数据定义，数据操纵，数据库运行管理，数据组织，存储和管理，数据库的建立和维护，数据通信接口。</p>
<p>2.简述SQL语言的特点。</p>
<p> SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，充分体现了关系数据库语言的特点和优点。其特点如下：</p>
<p>综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供两种操作方式，语言简洁，易学易用</p>
<p>3、什么是数据库系统?</p>
<p>答：数据库系统是实现有组织地、动态地存储大量关联数据，方便多用户访问的计算机软、硬资源组成的系统。它包含关联数据的集合，DBMS和用户应用程序等。</p>
<p>4、试述数据库完整保护的主要任务和措施。</p>
<p>主要任务是保障数据的正确性，有效性，协调性，提高数据对用户的可用性。</p>
<p>其措施如下：适时检查完整约束条件，保证语义完整。控制并发操作，使其不破坏完整性。在系统出现故障后，即时恢复系统。</p>
<p>5、在倒排文件中，如果只建立了部分关键字的辅索引，如何进行查找？</p>
<p>对询问中涉及的关键字，首先在已建立的辅索引中求指针的交集P，而后对P中所指记录逐个验证其它关键字是否与询问条件匹配，所有匹配的记录即为查询结果。</p>
<h2 id="四，综合题"><a href="#四，综合题" class="headerlink" title="四，综合题"></a>四，综合题</h2>]]></content>
  </entry>
  <entry>
    <title>JavaSE进阶</title>
    <url>/2021/05/30/JavaSE%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>抽象类和接口以及抽象类和接口的区别：<br>    抽象类：<br>        抽象类的定义：在class前添加abstract关键字<br>        抽象类是无法实例化的，所以抽象类是用来被子类继承的<br>        final和abstract不能联合使用，这两个关键字是对立的<br>        抽象类的子类可以是抽象类，也可以是非抽象类<br>        抽象类虽然无法实例化，但是抽象类有构造方法，构造方法是供子类使用的。<br>        抽象类中不一定有抽象方法，抽象方法必须在抽象类中。<br>        抽象方法的定义：public abstract void doSome();<br>        一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现</p>
<a id="more"></a>
<pre><code>java语言中凡是没有方法体的方法都是抽象方法。
        不对，错误的。
        Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
        都不是抽象方法，例如：
            public native int hashCode();
            这个方法底层调用了C++写的动态链接库程序。
            前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</code></pre><!--more-->
<pre><code>接口的基础语法：
    接口是一种‘引用数据类型’
    接口是完全抽象的
    接口的定义：[修饰符列表] interface 接口名{}
    接口的多继承
    接口中只有常量+抽象方法
    接口中所有的元素都是public修饰的
    接口中的抽象方法的public abstract可以省略
    接口中常量的public static final可以省略
    接口中方法不能有方法体
    一个非抽象的类，实现接口的时候，必须将接口中的所有方法实现
    一个类可以实现多个接口
    extends 和 implements可以共存，extends在前，impl在后
    使用接口，写代码时，可以使用多态

接口在开发中的作用：
    面向抽象编程---&gt;面向接口编程
    有了接口就实现拓展
    调用者面向接口调用，实现者面向接口编写实现

抽象类和接口的区别：
    抽象类是半抽象的，接口是完全抽象的
    抽象类中有构造方法，接口中没有
    接口和接口之间，支持多继承
    类和类之间只能单继承
    一个类可以同时实现多个接口，一个抽象类只能继承一个类
    接口中只允许出现常量和抽象方法
    接口使用的比抽象类多，抽象类使用少
    接口一般都是对“行为”的抽象</code></pre><p>import和package：<br>    package：<br>        必须出现在源文件的第一行<br>    import：<br>        java.lang包不需要引入<br>        同包下的java文件不需要引入</p>
<p>private 表示私有的，只能在本类中访问<br>        public 表示公开的，在任何位置都可以访问<br>        “默认”表示只能在本类，以及同包下访问。<br>        protected表示只能在本类、同包、子类中访问。</p>
<p>JDK类库根类：Object<br>    需要知道的几个方法：<br>        protected Object clone()   // 负责对象克隆的。<br>         int hashCode()    // 获取对象哈希值的一个方法。<br>        boolean equals(Object obj)  // 判断两个对象是否相等<br>            以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。<br>            重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。<br>            基本数据类型比较实用：==<br>            对象和对象比较：调用equals方法<br>            String类是SUN编写的，所以String类的equals方法重写了。<br>            以后判断两个字符串是否相等，最好不要使用==，要调用字符串对象的equals方法。<br>            注意：重写equals方法的时候要彻底。<br>        String toString()  // 将对象转换成字符串形式<br>            以后的所有的类的toString()方法是需要重写的，System.out.println(引用);<br>             这里会自动调用“引用”的toString()方法。String类是SUN写，toString方法已经重写了。<br>        protected void finalize()  // 垃圾回收器负责调用的方法</p>
<p>数组：<br>    理解：空间存储上，内存地址是连续的，每个元素占用的空间大小形同，知道首元素的内存地址，知道下标可以计算出偏移量，<br>    优点：检索效率高<br>    缺点：随机增删效率较低，数组无法存储大数据量<br>    数组最后一个元素的增删效率不受影响</p>
<pre><code>一维数组的静态初始化和动态初始化
    静态初始化：
        int []arr ={1,2,3,4};
        Object[] objs = {new Object(), new Object(), new Object()};
    动态初始化：
        int[] arr = new int[4]; // 4个长度，每个元素默认值0
        Object[] objs = new Object[4]; // 4个长度，每个元素默认值null                        

数组的拷贝：System.arraycopy()方法的使用
    数组的特点：长度一旦确定，不可变
    数组长度不够的时候，需要扩容，扩容机制：新建一个更大的数组
    将小数组中数据拷贝到大数组中，小数组对象被垃圾回收</code></pre><p>String类：<br>    理解：<br>        字符串一旦创建，不可修改<br>        双引号括起来的字符串存储在字符串常量池中<br>        字符串的比较使用的是equals方法<br>        String已经重写了toString()和equals()方法<br>    String的构造方法：<br>        String s = “abc”;<br>        String s = new String(“abc”);<br>        String s = new String(byte数组);<br>        String s = new String(byte数组, 起始下标, 长度);<br>        String s = new String(char数组);<br>        String s = new String(char数组, 起始下标, 长度);<br>    采用双引号赋值字符串，在编译期将会放到方法区中的字符串的常量池，如果是运行时对字符串相加或者相减会放到堆中（放之前会验证方法区中是否含有相同的字符串常量，如果存在，把地址返回，如果不存在，先将字符串常量放到池中，然后返回该对象的地址）<br>    String常用方法：<br>        1. endsWith：判断字符串是否以指定的后缀结束<br>        2. startsWith，判断字符串是否以指定的前缀开始<br>        3. equals，字符串相等比较，不忽略大小写<br>        4. equalsIgnoreCase，字符串相等比较，忽略大小写<br>        5. indexOf，取得指定字符在字符串的位置<br>        6. lastIndexOf，返回最后一次字符串出现的位置<br>        7. length，取得字符串的长度<br>        8. replaceAll，替换字符串中指定的内容<br>        9. split，根据指定的表达式拆分字符串<br>        10. substring，截子串<br>        11. trim,去前尾空格<br>        12. valueOf，将其他类型转换成字符串<br>    使用String时注意：<br>        String是不可变对象，如果多个字符串拼接，就会产生多个对象，会造成内存溢出</p>
<p>StringBuffer和StringBuilder<br>    StringBuffer和StringBuilder可以看做可变长度的字符串<br>    StringBuffer和StringBuilder初始化容量为16<br>    StringBuffer和StringBuilder是完成字符串拼接操作的，方法名：append<br>    频繁进行字符串拼接不建议使用‘+’<br>    StringBuffer（字符串缓冲区）:<br>        工作原理：<br>            预先申请一块内存，存放字符序列，如果字符序列满了，重新改变缓存区的大小，StringBuffer是可变对象，这个是String最大的不同<br>    StringBuilderr：<br>        用法和Buffer一样，区别是StringBuffer方法是同步的，是线程安全的，但速度慢，StringBuilder速度快，线程不安全<br>八中基本数据类型对应的包装类：<br>    包装类存在的作用：方便编程<br>    八种包装类的类名：<br>        Byte<br>        Short<br>        Integer<br>        Long<br>        Float<br>        Double<br>        Boolean<br>        Character<br>    所有的数字的父类Number       </p>
<p>日期类：<br>    获取系统当前时间：<br>        Date d = new Date();<br>    日期格式化：Date –&gt; String<br>        yyyy-MM-dd HH:mm:ss SSS<br>        SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss SSS”);<br>        String s = sdf.format(new Date());<br>    String –&gt; Date<br>        SimpleDateFormat sdf = new SimpleDate(“yyyy-MM-dd HH:mm:ss”);<br>        Date d = sdf.parse(“2008-08-08 08:08:08”);<br>    获取毫秒数<br>        long begin = System.currentTimeMillis();<br>        Date d = new Date(begin - 1000 * 60 * 60 * 24);</p>
<p>数字类<br>    DecimalFormat数字格式化<br>        ###,###.## 表示加入千分位，保留两个小数。<br>        ###,###.0000 表示加入千分位，保留4个小数，不够补0<br>    BigDecimal<br>        财务软件中通常使用BigDecimal</p>
<p>随机数<br>    怎么产生int类型随机数。<br>        Random r = new Random();<br>        int i = r.nextInt();<br>    怎么产生某个范围之内的int类型随机数。<br>        Random r = new Random();<br>        int i = r.nextInt(101); // 产生[0-100]的随机数。</p>
<p>枚举<br>    枚举是一种引用数据类型。<br>    枚举编译之后也是class文件。<br>    枚举类型怎么定义？<br>        enum 枚举类型名{<br>            枚举值,枚举值2,枚举值3<br>        }<br>    当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来的时候，建议返回值类型设计为枚举类型。</p>
<p>异常处理机制：<br>    java中异常的作用:增强程序的健壮性<br>    java中的异常以类和对象的形式存在</p>
<p>java的异常处理机制：<br>    异常在java中以类和对象的形式存在<br>    Object<br>    Object下有Throwable（可抛出的）<br>    Throwable下有两个分支：Error：（不可处理的，直接退出JVM）和Exception（可处理的）<br>    Exception下有两个分支：<br>        Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。<br>        RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）<br>    java对异常的处理的两种方式：<br>        使用throws关键字，抛给上一级<br>        使用try……catch语句进行异常的抓捕<br>        java出现异常，如果一直往上抛，最终会抛给main方法，main方法再往上抛给了JVM，JVM知道异常后，终止java程序的执行。<br>    异常捕获的顺序：从小到大<br>    子类方法不能抛出比父类方法更多的异常</p>
<p>集合：<br>    Java主要有3个重要的集合<br>        List:一个有序的集合，可以放重复的数据<br>        Set:无序的集合，不允许放重复的数据<br>        Map:一个无序的集合，包含一个键对象和一个值对象，键对象不重复，值对象可以重复<br>    Collection和Iterator：<br>        Collection是List和Set的父接口，在Collection中定义一些主要方法<br>        Iterator：迭代接口，通过此接口可以遍历集合中的数据<br>    List接口：<br>        主要实现了ArrayList和LinkedList，都是由顺序的基于线性存储，可以看成是可变数组。<br>        ArrayList：查询数据比较快，添加和删除数据比较慢（基于可变数组）<br>        LinkedList：查询数据比较慢，添加和删除数据比较快（基于链式数据结构）<br>        Vector：不建议使用，方法是同步的，效率慢，已经被ArrayList取代<br>        Stack：是继承Vector实现的一个栈，栈结构是后进先出的，已经被LinkedList取代<br>    Set接口：<br>        哈希表：一种数据结构，用于提供快速存取操作，基于数组。<br>        HashSet：存储的数据是无序的不可重复的，按照哈希算法存取数据，具有很好的性能<br>            工作原理：插入数据的时候，调用对象的hashCode得到对象的哈希吗，根据哈希吗计算出对象插入集合的位置。<br>        equals和hashCode:</p>
<pre><code>    TreeSet:
        可以对Set集合进行排序，默认自然升序排序
Map接口：
    可以放置键值对，也就是每个元素都包含键对象和值对象，Map实现较为常用的为HashMap，HashMap对键对象的存取和HashSet一样，仍采用哈希算法，所以如果使用自定类作为Map的键对象，必须复写equals和hashCode方法。
    HashMap：

    TreeMap：</code></pre><p>基本类型的包装类：<br>    作用：提供更多实用的操作，更容易处理基本类型，所有的包装类都是final的，所以不能创建子类，包装类都是不可变对象<br>    byte    Byte<br>    short   Short<br>    char    Character<br>    int     Integer<br>    long    Long<br>    float   Float<br>    double  Double<br>    boolean Boolean</p>
<p>JDK5.0新特性：<br>    JDK5.0之前包装类和基本类型做运算时，必须将包装类转换为基本类型。JDK5.0提供自动装箱拆箱Auto-boxing/unboxing</p>
<p>泛型：</p>
<p>2021-6-3 </p>
<p>IO流：要站在内存的角度，看输出和输入<br>    概述：文件通常是一连串的字节和字符构成，组成文件的字节序列称为字节流，组成文件的字符序列称为字符流。java根据流的方向分为输入流和输出流。</p>
<pre><code>输入流：将文件或其他输入设备的数据加载到内存的过程；
输出流：将内存中的数据保存到文件或者其他输出设备中

Java语言将IO分为：字节输入\输出流和字符输入\输出流

InputStream（字节输入流）:
    InputStream是一个抽象类，所有继承InputStream的类都是字节输入流
OutputStream（字节输出流）：   
    所有继承OutputStream的类都是字节输出流
Reader（字符输出流）：
    所有继承Reader的类都是字符输入流
Writer（字符输出流）： 
    所有继承Writer都是字符输出流

文件流：
    文件流主要分为：文件字节输入流、文件字节输出流、文件字符输入流、文件字符输出流

    FileInputStream(文件字节输入流):
        主要按照字节方式读取文件
        注意：如果是读取的是中文，按照字节读入，然后直接打印在控制台的话，会发生乱码，因为汉字是按照两个自己存储的，按照一个字节打印汉字是不完整的。
    FileOutputStream(文件字节输出流)：
        按照字节方式写文件，例如文件的复制，首先读取文件，读取文件后将文件保存在另一个磁盘上，就完成了备份。
    FileReader(文件字符输入流):
        以字符为单位读取字符，也就是一次读取两个字节，采用字符输入流读取文本文件，汉字就不乱码了。
    FileWriter(文件字符输出流):
        输出字符流到文本文件。

缓冲流：
    目的：为了提升效率，减少物理读取次数。
    缓冲流主要有：：BufferedInputStream、BufferedOutputStream，BufferedReader、BufferedWriter
    BufferedReader 提供了实用方法readLine()，可以直接读取一行，BufferWriter 提供了 newLine()可以写换行符。

转换流：   
    包括InputStreamReader 和 OutputStreamWriter
    InputStreamReader：将字节流输入流转换为字符输入流
    OutputStreamWriter：主要是将字节流输出流转换成字符输出流

打印流：
    包括：PrintStream 字节流和 PrintWriter字符流</code></pre><p>对象流：</p>
<p>​    对象流可以将Java对象转换为二进制写入磁盘，这个过程通常叫做序列化，并且还可以从磁盘里读出完整java对象，而这个过程叫做反序列化。</p>
<p>对象流主要包括：ObjectInputStream 和 ObjectOutputStream </p>
<p>实现序列化和反序列化：</p>
<p>​    实现序列化该类必须实现序列化接口 java.io.Serializable,该接口没有任何方法，该接口只是一种标记接口，标记这个类是可序列化的</p>
<p>序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class ObjectStreamTest02 &#123; </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">ObjectOutputStream oos &#x3D; null; </span><br><span class="line"></span><br><span class="line">try &#123; </span><br><span class="line">oos &#x3D; new ObjectOutputStream( new FileOutputStream(&quot;c:&#x2F;Person.dat&quot;)); </span><br><span class="line">Person person &#x3D; new Person(); </span><br><span class="line">person.name &#x3D; &quot;张三&quot;; </span><br><span class="line">oos.writeObject(person); </span><br><span class="line">&#125;catch(FileNotFoundException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;catch(IOException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;finally &#123; </span><br><span class="line">try &#123; </span><br><span class="line">if (oos !&#x3D; null) &#123; </span><br><span class="line">oos.close(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;catch(IOException e) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现序列化接口 </span><br><span class="line">class Person implements Serializable&#123; </span><br><span class="line">String name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化，过程类似</p>
<p>关于transient关键字：一个类实现Serializable接口后，类中的某个属性被transient关键字修饰后，序列化时会被忽略</p>
<p>serialVersionUID ：序列化有关 </p>
<p>File类：</p>
<p>​    提供了大量的文件操作：删除文件，修改文件，得到文件的修改日期，建立目录，列表文件。</p>
<p>zip格式：</p>
<p>​    参见java.util.zip.*包下的api</p>
<p>多线程</p>
<p>多线程概念：线程指的是进程中的一个执行场景，也就是执行流程。</p>
<p>​    每一个进程是一个应用程序，都有独立的内存空间</p>
<p>​    同一个进程的线程中的线程共享其进程中的内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的。）</p>
<p>什么是进程？</p>
<p>​    一个进程就是一个应用程序。在操作系统中每启动一个应用程序就会启动一个进程。例如：qq进程，word进程……。</p>
<p>系统引入多进程的作用：最初的计算机是“单进程的”，计算机只能运行一个应用程序，例如第一台计算机只有 </p>
<p>DOS 窗口。现代的计算机可以满足我们一边听音乐，一边玩游戏。现代的计算给我们人类感 </p>
<p>觉：多件事情一起运行。感觉是并行的（错觉）。</p>
<p>对于单核的计算机来讲，在某一个时间点上只能做一件事情，但是由于计算机的处理速度 </p>
<p>很高，多个进程之间完成频繁的切换执行，这个切换速度使人类产生了错觉，人类的错觉是：多个进程在同时运行。 </p>
<p>计算机引入多进程的作用：提高 <strong>CPU</strong> <strong>的使用率</strong>。 </p>
<p><strong>重点：进程和进程之间的内存独立。</strong> </p>
<p>什么是线程：线程是进程的一个执行场景。一个进程可以启动多个线程。 </p>
<p><strong>进程引入多线程的作用？</strong></p>
<p>提高进程的使用率。 </p>
<p><strong>重点：线程和线程之间栈内存独立，堆内存和方法区内存共享。一个线程一个栈。</strong> </p>
<p><strong>描述</strong> <strong>java</strong> <strong>程序的执行原理：</strong> </p>
<p>java 命令执行会启动 JVM，JVM 的启动表示启动一个应用程序，表示启动了一个进程。 </p>
<p>该进程会自动启动一个“主线程”，然后主线程负责调用某个类的 main 方法。所以 main 方法 </p>
<p>的执行是在主线程中执行的。然后通过 main 方法代码的执行可以启动其他的“分支线程”。 </p>
<p>所以，main 方法结束程序不一定结束，因为其他的分支线程有可能还在执行。 </p>
<p>线程的创建和启动：<br>    java虚拟机的主线程入口是main方法，用户可以自己创建线程，创建方式有两种：</p>
<p>​    继承Thread类</p>
<p>​    实现Runnable接口（推荐使用Runnable接口）</p>
<p>继承Thread类：</p>
<p>Thread类中创建线程最重要的两个方法：</p>
<p>public void run()</p>
<p>public void start()</p>
<p>采用</p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/06/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程：<br>    进程：正在运行的程序，是系统进行资源分配和调度的独立单位，每一个进程都有自己的内存空间和系统资源<br>    线程：在进程中的单个顺序控制流，是一条执行路径<br>        单线程：一个进程如果只有一条执行路径，则称为单线程程序<br>        多线程：一个进程有多个执行路径，则称为多线程程序</p>
<p>线程调度的两种方式：<br>    分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间<br>    抢占式调度：优先让优先级高的线程使用CPU，如果线程优先级相同，那么会随机选择一个，优先级高的线程获取CPU时间片相对较多。</p>
<p>Java使用的是抢占式调度模型</p>
<p>随机性：<br>    假如计算机只有一个CPU，那么CPU只能在一个时刻只能执行一条命令，线程只有得到CPU的时间片，也就是使用权才能执行命令。<br>    所以多线程程序的执行是有随机性的</p>
<p>final int getPriority()：返回线程的优先级<br>final void setPriority(int newPriority)：更改线程的优先级，线程优先级默认为5，优先级范围是：1-10</p>
<p>线程控制：<br>    static void sleep(long millis)：是当前正在执行的线程停留（暂停执行），指定的毫秒数<br>    void join()：等待这个线程死亡<br>    void setDaemon(boolean on) 将线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</p>
<p>实现多线程的方式：<br>    继承Thread类或者实现Runnable接口<br>    相比继承Thread类，实现Runnable接口的好处：<br>        避免了Java的单继承的局限性<br>        适合多个相同程序的代码，去处理同一个资源的情况，把线程和程序的代码，数据有效分离，体现面向对象思想</p>
<p>同步代码块解决数据安全问题：<br>    出现条件：在多线程环境下，有个共享数据，多条语句操作共享数据<br>    如何解决：让程序没有安全问题的环境<br>    如何实现：把多条语句操作数据的代码给锁起来，让任何时刻只能有一个线程执行就行了</p>
<pre><code>同步代码块：   
    synchronized(任意对象){
        多条语句操作工具数据的代码
    }
    synchronized(任意对象)：相当于给代码加锁，任意对象就可以看做为一把锁
    好处和弊端：
        解决多线程的数据安全问题
        当线程很多的时候，因为每个线程都会去判断同步上的锁，这就很耗费资源，无形中降低程序的运行效率</code></pre><p>线程安全的类：</p>
<pre><code>StringBuffer:
    线程安全，可变的字符串序列，从JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为执行不同步。
Vector：
    该类改进了List接口。与新的集合实现不同，Vector被同步。如果不需要线程安全实现，建议使用ArrayList代替Vector
Hashtable:
    该类实现哈希表，将键映射到值，任何非null对象都可以作为键或者值，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashable</code></pre><p>生产者消费者模式：<br>    待理解</p>
<p>Thread.sleep():<br>    是Thread类的一个静态方法，使当前线程休眠，进入阻塞状态（暂停执行），如果线程在睡眠状态被中断，将会抛出IterruptedException中断异常。</p>
<p>代码练习：<br>public class SellTicketDemo {<br>    public static void main(String[] args) {<br>        //创建SellTicket类对象<br>        SellTicket st = new SellTicket();</p>
<pre><code>    //创建三个Thread类对象，把SelllTicket对象作为构造方法的参数，并给对应窗口进行命名
    Thread thread1 = new Thread(st,&quot;窗口1&quot;);
    Thread thread2 = new Thread(st,&quot;窗口2&quot;);
    Thread thread3 = new Thread(st,&quot;窗口3&quot;);

    thread1.start();
    thread2.start();
    thread3.start();
   /*
   出现问题：
        相同的票出现多次
        出现负数票
    出现原因：
        线程执行的随机性导致
    */

}</code></pre><p>}</p>
<p>public class SellTicket implements Runnable{<br>    private int tickets = 100;</p>
<pre><code>@Override
public void run() {
    while (true){
        if(tickets&gt;0){
            System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;张票&quot;);
            tickets--;
        }
    }
}</code></pre><p>}</p>
<p>public class priorityDemo {<br>    public static void main(String[] args) {<br>        MyThread myThread =new MyThread();<br>        MyThread myThread1 =new MyThread();<br>        MyThread myThread2 =new MyThread();<br>        MyThread myThread3 =new MyThread();<br>        MyThread myThread4 =new MyThread();<br>        MyThread myThread5 =new MyThread();<br>        MyThread myThread6 =new MyThread();<br>        myThread.setName(“my”);<br>        myThread1.setName(“my1”);<br>        myThread2.setName(“my2”);<br>        myThread3.setName(“my3”);<br>        myThread4.setName(“my4”);<br>        myThread5.setName(“my5”);<br>        myThread6.setName(“my6”);<br>        //其他的线程默认为5<br>        myThread6.setPriority(10);//进程my6是最高的<br>        myThread1.setPriority(1);//进程my是优先级最小的<br>       //测试<br>        myThread.start();<br>        myThread1.start();<br>        myThread2.start();<br>        myThread3.start();<br>        myThread4.start();<br>        myThread5.start();<br>        myThread6.start();</p>
<pre><code>}</code></pre><p>}</p>
<p>public class MyThreadTest {<br>    public static void main(String[] args) {<br>        MyThread my1 = new MyThread();<br>        MyThread my2 = new MyThread();<br>        my1.setName(“my1”);<br>        my2.setName(“my2”);<br>        my1.start();<br>        my2.start();<br>        String my1Name = my1.getName();<br>        String my2Name = my2.getName();<br>        System.out.println(“my1name:”+my1Name);<br>        System.out.println(“my2name:”+my2Name);<br>    }<br>}</p>
<p>public class MyThread extends Thread{<br>    @Override<br>    public void run(){<br>        for(int i = 0; i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>        System.out.println(this.getName());<br>    }</p>
<p>}</p>
]]></content>
  </entry>
  <entry>
    <title>SQL语法</title>
    <url>/2021/06/04/SQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>模式定义了数据如何存储，存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋值给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准SQL由ANSI标准委员会管理，从而称为ANSI SQL。各个DBMS都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL不区分大小写，但数据库表名，列名和值是否区分依赖于具体的DBMS以及配置</p>
<p>SQL支持的注释：</p>
<a id="more"></a>
<p>注释：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure>

<p>数据库创建和使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<!--more-->
<h2 id="二，创建表"><a href="#二，创建表" class="headerlink" title="二，创建表"></a>二，创建表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create Table mytable(</span><br><span class="line">	#int 类型 ，不为空，自增</span><br><span class="line">	id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">	#int 类型，不为空，默认值为1，不为空</span><br><span class="line">	col1 INT NOT NULL DEFAULT1,</span><br><span class="line">	#变长字符串类型，最长为45个字符，可以为空</span><br><span class="line">	col2 VARCHAR(45) NULL,</span><br><span class="line">	#日期类型，不为空</span><br><span class="line">	col3 DATE NULL,</span><br><span class="line">	#设置主键id</span><br><span class="line">	PRIMARY KEY(&#39;id&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="三，修改表"><a href="#三，修改表" class="headerlink" title="三，修改表"></a>三，修改表</h2><p>添加列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">ADD col CHAR(20);</span><br></pre></td></tr></table></figure>

<p>删除列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">DROP COLUMN col;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE mytable;</span><br></pre></td></tr></table></figure>

<h2 id="四，插入"><a href="#四，插入" class="headerlink" title="四，插入"></a>四，插入</h2><p>普通插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytable(col1,col2)</span><br><span class="line">VALUE(val1,val2);</span><br></pre></td></tr></table></figure>

<p>插入检索出来的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytable(col1,col2)</span><br><span class="line">SELECT col1,col2</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>

<p>将一个表的内容插入一个新表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE newtable AS </span><br><span class="line">SELECT *FROM mytable;</span><br></pre></td></tr></table></figure>

<h2 id="五，更新"><a href="#五，更新" class="headerlink" title="五，更新"></a>五，更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mytable</span><br><span class="line">set col &#x3D; val</span><br><span class="line">WHERE ID&#x3D;1;</span><br></pre></td></tr></table></figure>

<h2 id="六，删除"><a href="#六，删除" class="headerlink" title="六，删除"></a>六，删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p> <strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE mytable;</span><br></pre></td></tr></table></figure>

<p>使用更新和删除操作时一定要用WHERE子句，不然会把整张表的数据都破坏了。</p>
<p>可以先用SELECT语句进行测试，防止错误删除。</p>
<h2 id="七，查询"><a href="#七，查询" class="headerlink" title="七，查询"></a>七，查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>相同的值只会出现一次。他的作用是用于所有列，也就是说所有的列的值都是相同的才算相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT col1, col2</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数，可以有两个参数，第一个参数为起始行，从0开始；</p>
<p>第二个参数为返回的总行数。</p>
<p>返回前五行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 0, 5;</span><br></pre></td></tr></table></figure>

<p>返回第3~5行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="八，排序"><a href="#八，排序" class="headerlink" title="八，排序"></a>八，排序</h2><p>ASC：升序（默认）</p>
<p>DESC：降序</p>
<p>可以按照多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="九，过滤"><a href="#九，过滤" class="headerlink" title="九，过滤"></a>九，过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用SQL语句来过滤不必要的数据，而不是传输所有的数据到客户端进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>WHERE子句的操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&gt; !=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;= !&gt;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;= !&lt;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center">为 NULL 值</td>
</tr>
</tbody></table>
<p>注意：NULL，0，空字符串都是不同的。</p>
<p>AND和OR用于连接多个过滤条件。优先处理AND，当一个过滤条件表达式涉及到多个AND和OR时，可以使用（）来决定优先级，使得优先级更加清晰。</p>
<p>IN操作符用于匹配一组值，其后也可以接一个SELECT子句，从而匹配子查询得到的一组值。</p>
<p>NOT操作符用于否定一个条件。</p>
<h2 id="十，通配符"><a href="#十，通配符" class="headerlink" title="十，通配符"></a>十，通配符</h2><p>通配符也是用在过滤语句中，但只用于文本字段。</p>
<ul>
<li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li>
<li><strong>_</strong> 匹配 ==1 个任意字符；</li>
<li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure>

<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h2 id="十一，计算字段"><a href="#十一，计算字段" class="headerlink" title="十一，计算字段"></a>十一，计算字段</h2><p>在数据库服务器上完成数据的</p>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 </p>
<p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。 </p>
<h2 id="十二，函数"><a href="#十二，函数" class="headerlink" title="十二，函数"></a>十二，函数</h2><p>各个DBMS的函数都是不相同的，因此不可移植，一下主要是MYSQL的函数。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th align="left">函 数</th>
<th align="right">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AVG()</td>
<td align="right">返回某列的平均值</td>
</tr>
<tr>
<td align="left">COUNT()</td>
<td align="right">返回某列的行数</td>
</tr>
<tr>
<td align="left">MAX()</td>
<td align="right">返回某列的最大值</td>
</tr>
<tr>
<td align="left">MIN()</td>
<td align="right">返回某列的最小值</td>
</tr>
<tr>
<td align="left">SUM()</td>
<td align="right">返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG()会忽略NULL行。</p>
<p>使用DISTINCT可以汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LEFT()</td>
<td align="left">左边的字符</td>
</tr>
<tr>
<td align="center">RIGHT()</td>
<td align="left">右边的字符</td>
</tr>
<tr>
<td align="center">LOWER()</td>
<td align="left">转换为小写字符</td>
</tr>
<tr>
<td align="center">UPPER()</td>
<td align="left">转换为大写字符</td>
</tr>
<tr>
<td align="center">LTRIM()</td>
<td align="left">去除左边的空格</td>
</tr>
<tr>
<td align="center">RTRIM()</td>
<td align="left">去除右边的空格</td>
</tr>
<tr>
<td align="center">LENGTH()</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="center">SOUNDEX()</td>
<td align="left">转换为语音值</td>
</tr>
</tbody></table>
<p> 其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="left">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDDATE()</td>
<td align="left">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center">ADDTIME()</td>
<td align="left">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="left">返回当前日期</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="left">返回当前时间</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="left">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="left">计算两个日期之差</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="left">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="left">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="left">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DAYOFWEEK()</td>
<td align="left">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="left">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="left">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="left">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">NOW()</td>
<td align="left">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="left">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">TIME()</td>
<td align="left">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="left">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="left">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="left">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="left">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="left">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="left">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="left">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="left">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="left">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="left">随机数</td>
</tr>
</tbody></table>
<h3 id="十三，分组"><a href="#十三，分组" class="headerlink" title="十三，分组"></a>十三，分组</h3><p>把相同的数据值的行放在同一组中。</p>
<p>可以最同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按照字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure>

<p> GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<p> WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h2 id="十四，子查询"><a href="#十四，子查询" class="headerlink" title="十四，子查询"></a>十四，子查询</h2><p>子查询中智能返回一个字段的数据</p>
<p>可以将子查询的结果作为WHERE语句的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p> 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="十五，连接"><a href="#十五，连接" class="headerlink" title="十五，连接"></a>十五，连接</h2><p>连接用于连接多张表，使用JOIN关键字，并且条件语句使用ON而不是WHERE。</p>
<p>连接可以代替子查询，并且比子查询效率一般会更快。</p>
<p>可以用AS给列名，计算机字段和表名取别名，给表名取别名是为了简化SQL语句以及连接相同表。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称为等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<p>可以不明确使用 INNER JOIN,而使用不同查询并在 WHERE 中将两张表中要连接的列用等等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接可以看成内连接的一种，只是表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找到与Jim处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，通名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接保留了没有关联的那些行，分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p> 检索所有顾客的订单信息，包括还没有订单信息的顾客。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h2 id="十六，组合查询"><a href="#十六，组合查询" class="headerlink" title="十六，组合查询"></a>十六，组合查询</h2><p>使用UNION来组合两个查询，如果第一个查询返回M行，第二个查询返回N行，那么组合查询的结果一般为M+N行。</p>
<p>每一个查询必须包含相同的列，表达式和聚合函数</p>
<p>默认会去处相同行，如果需要保留相同行，使用UNION ALL。</p>
<p>只能包含一个ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十七，视图"><a href="#十七，视图" class="headerlink" title="十七，视图"></a>十七，视图</h2><p>视图是虚拟的表，本身不包含数据，也就是不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图的好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure>

<h2 id="十八，存储过程"><a href="#十八，存储过程" class="headerlink" title="十八，存储过程"></a>十八，存储过程</h2><p>存储过程可以看成是对一系列SQL操作的批处理。</p>
<p>使用存储过程的好处:</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中存储过程需要自定义分隔符，因为命令行是以；为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
]]></content>
  </entry>
  <entry>
    <title>数据库零碎知识点</title>
    <url>/2021/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p> 一些最重要的 SQL 命令</p>
<ul>
<li><p><strong>SELECT</strong> - 从数据库中提取数据</p>
</li>
<li><p><strong>UPDATE</strong> - 更新数据库中的数据</p>
</li>
<li><p><strong>DELETE</strong> - 从数据库中删除数据</p>
</li>
<li><p><strong>INSERT INTO</strong> - 向数据库中插入新数据</p>
</li>
<li><p><strong>CREATE DATABASE</strong> - 创建新数据库</p>
</li>
<li><p><strong>ALTER DATABASE</strong> - 修改数据库</p>
</li>
<li><p><strong>CREATE TABLE</strong> - 创建新表</p>
</li>
<li><p><strong>ALTER TABLE</strong> - 变更（改变）数据库表</p>
</li>
<li><p><strong>DROP TABLE</strong> - 删除表</p>
</li>
<li><p><strong>CREATE INDEX</strong> - 创建索引（搜索键）</p>
</li>
<li><p><strong>DROP INDEX</strong> - 删除索引</p>
<p>SELECT DISTINCT：<br>选取出来列中唯一不同的值（重复的值出现一次）</p>
</li>
</ul>
<a id="more"></a>

<p>SQL的四种连接查询：<br>    内连接（内联查询，就是两张表中的数据，通过某个字段相对，查询出相关记录数据）</p>
<p>​        inner join 或者 join      （后加on表示条件）</p>
<p>​        例如：select * from person inner join card on person.cardId=card.id;</p>
<p>​    外连接</p>
<p>​        1.左连接 left join 或者 left outer join  (会把左边表里的数据全部取出来，而右边表的数据，如果有的话，显示出来，没有的话，就会补NULL。)</p>
<p>​        2.右连接 right join 或者 right outer join (和左外连接相似)</p>
<p>​        3.完全外连接 full join 或者 full outer join (mysql  不支持full join)</p>
<p>只能通过左右外连接，然后union起来，例如：<br>select * from person left join card on person.cardId=card.id</p>
<p>union</p>
<p>select * from person right join card on person.cardId=card.id</p>
<p>​        </p>
<p>unique约束，可以为空，但为空只能有一个，</p>
<p>视图：</p>
<p>​    虚表，是从一个或多个</p>
]]></content>
  </entry>
  <entry>
    <title>四级英语词汇</title>
    <url>/2021/06/07/%E5%9B%9B%E7%BA%A7%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/</url>
    <content><![CDATA[<p>a art.一(个)；每一 (个)<br>abandon vt.丢弃；放弃，抛弃<br>ability n.能力；能耐，本领<br>able a.有能力的；出色的<br>abnormal a.不正常的；变态的<br>aboard ad.在船(车)上；上船<br>about prep.关于；在…周围<br>above prep.在…上面；高于<br>abroad ad.(在)国外；到处<br>absence n.缺席，不在场；缺乏<br>absent a.不在场的；缺乏的<br>absolute a.绝对的；纯粹的<br>absolutely ad.完全地；绝对地<br>absorb vt.吸收；使专心<br>abstract a.抽象的 n.摘要<br>abundant a.丰富的；大量的<br>abuse vt.滥用；虐待 n.滥用<br>academic a.学院的；学术的<br>academy n.私立中学；专科院校</p>
<a id="more"></a>
<p>accelerate vt.(使)加快；促进<br>acceleration n.加速；加速度<br>accent n.口音，腔调；重音<br>accept vt.vi.接受；同意<br>acceptable a.可接受的，合意的<br>acceptance n.接受，验收；承认<br>access n.接近；通道，入口<br>accessory n.同谋，从犯；附件<br>accident n.意外的；事故<br>accidental a.偶然的；非本质的<br>accommodate vt.容纳；供应，供给<br>accommodation n.招待设备；预定铺位<br>accompany vt.陪伴，陪同；伴随<br>accomplish vt.达到(目的 )；完成<br>accord vt.使一致；给予<br>accordance n.一致；和谐；授予<br>accordingly ad.因此，所以；照着<br>account n.记述；解释；帐目<br>accumulate vt.积累 vi.堆积<br>accuracy n.准确(性)；准确度<br>accurate a.准确的，正确无误的<br>accuse vt.指责；归咎于<br>accustom vt.使习惯<br>accustomed a.惯常的；习惯的<br>ache vi.痛；想念 n.疼痛<br>achieve vt.完成，实现；达到<br>achievement n.完成；成就，成绩<br>acid n.酸；酸的，酸性的<br>acquaintance n.认识；了解；熟人<br>acquire vt.取得；获得；学到<br>acre n.英亩(=6.07 亩)<br>across prep.横过；在…对面<br>act vi.行动；见效 n.行为<br>action n.行动；作用；功能<br>active a.活跃的；积极的<br>activity n.活动；活力；行动<br>actor n.男演员；演剧的人<br>actress n.女演员<br>actual a.实际的；现行的<br>actually ad.实际上；竟然<br>acute a.尖的，锐的；敏锐的<br>ad n.广告<br>adapt vt.使适应；改编<br>add vt.添加，附加，掺加<br>addition n.加，加法；附加物<br>additional a.附加的，追加的<br>address n.地址；演说；谈吐<br>adequate a.足够的；可以胜任的<br>adjective n.形容词 a.形容词的<br>adjust vt.调整，调节；校正<br>administration n.管理；管理部门<br>admire vt.钦佩，羡慕，赞赏<br>admission n.允许进入；承认<br>admit vt.承认；准许…进入<br>adopt vt.收养；采用；采取<br>adult n.成年人 a.成年的<br>advance vi.前进；提高 n.进展<br>advanced a.先进的；高级的<br>advantage n.优点，优势；好处<br>adventure n.冒险；惊险活动<br>adverb n.副词<br>advertisement n.广告；公告；登广告<br>advice n.劝告；忠告；意见<br>advisable n.明智的；可取的<br>advise vt.劝告；建议；通知<br>aeroplane n.飞机<br>affair n.事情，事件；事务<br>affect vt.影响；感动<br>affection n.慈爱，爱；爱慕<br>afford vt.担负得起…；提供<br>afraid a.害怕的；担心的<br>Africa n.非洲<br>African a.非洲的 n.非洲人<br>after prep.在…以后；次于<br>afternoon n.下午，午后<br>afterward ad.后来，以后<br>again ad.又一次；而且<br>against prep.倚在；逆，对着<br>age n.年龄；时代 vt.变老<br>agency n.经办；代理；代理处<br>agent n.代理人，代理商<br>aggressive a.侵略的；好斗的<br>ago ad.以前<br>agony n.极度痛苦<br>agree vi.同意；持相同意见<br>agreement n.协定，协议；同意<br>agriculture n.农业，农艺；农学<br>ahead ad.在前；向前；提前<br>aid n.帮助，救护；助手<br>aim vi.瞄准，针对；致力<br>air n.空气；空中；外观<br>aircraft n.飞机，飞行器<br>airline n.航空公司；航线<br>airplane n.飞机<br>airport n.机场，航空站<br>alarm n.惊恐，忧虑；警报<br>alcohol n.酒精，乙醇<br>alike a.同样的，相同的<br>alive a.活着的；活跃的<br>all a.全部的 prep.全部<br>allow vt.允许，准许；任<br>alloy n.合金； (金属的 )成色<br>almost ad.几乎，差不多<br>alone a.单独的 ad.单独地<br>along prep.沿着 ad.向前<br>aloud ad.出声地，大声地<br>alphabet n.字母表，字母系统<br>already ad.早已，已经<br>also ad.亦，也；而且，还<br>alter vt.改变，变更；改做<br>alternative n.替换物；取舍，抉择<br>although conj.尽管，虽然<br>altitude n.高，高度；高处<br>altogether ad.完全；总而言之<br>aluminium n.铝<br>always ad.总是，一直；永远<br>a.m (缩)上午，午前<br>amaze vt.使惊奇，使惊愕<br>ambition n.雄心，抱负，野心<br>ambulance n.救护车；野战医院<br>America n.美洲；美国<br>American a.美洲的 n.美国人<br>among prep.在…之中<br>amongst prep在…之中 (=among)<br>amount n.总数；数量；和<br>ampere n.安培<br>    amplify vt.放大，增强；扩大<br>amuse vt.逗…乐；给…娱乐<br>analyse vt.分析，分解，解析<br>analysis n.分析，分解，解析<br>ancestor n.祖宗，祖先<br>anchor n.锚 vi.抛锚，停泊<br>ancient a.古代的，古老的<br>and conj.和，又，并，则<br>angel n.天使，神差，安琪儿<br>anger n.怒，愤怒 vt.使发怒<br>angle n.角，角度<br>angry a.愤怒的，生气的<br>animal n.动物，兽 a.动物的<br>ankle n.踝，踝节部<br>announce vt.宣布，宣告，发表<br>announcer n.宣告者；播音员<br>annoy vt.使恼怒；打搅<br>annual a.每年的 n.年报<br>another a.再一个的；别的<br>answer vt.回答；响应；适应<br>ant n.蚂蚁<br>anticipate vt.预料，预期，期望<br>anxiety n.焦虑，忧虑；渴望<br>anxious a.忧虑的；渴望的<br>any a.什么，一些；任何的<br>anybody prep.任何人<br>anyhow ad.无论如何<br>anyone pron.任何人<br>anything pron.任何事物；一切<br>anyway ad.无论如何<br>anywhere ad.在什么地方<br>apart ad.相隔；分开；除去<br>apartment n.一套公寓房间<br>apologize vi.道歉，谢罪，认错<br>apology n.道歉，认错，谢罪<br>apparatus n.器械，仪器；器官<br>apparent a.表面上的；明显的<br>appeal vi.&amp;n.呼吁；申述<br>appear vi.出现；来到；似乎<br>appearance n.出现，来到；外观<br>    appetite n.食欲，胃口；欲望<br>apple n.苹果，苹果树<br>appliance n.用具，器具，器械<br>applicable a.能应用的；适当的<br>application n.请求，申请；施用<br>apply vt.应用，实施，使用<br>appoint vt.任命，委任；约定<br>appointment n.任命；约定，约会<br>appreciate vt.欣赏；领会；感谢<br>approach vt.向…靠近 n.靠近<br>appropriate a.适当的，恰当的<br>approval n.赞成，同意；批准<br>approve vt.赞成，称许；批准<br>approximately ad.近似地，大约<br>April n. 四月<br>Arabian a.阿拉伯的<br>arbitrary a.随心所欲的；专断的<br>architecture n.建筑学；建筑式样<br>area n.面积；地区；领域<br>argue vi.争论，争辩，辩论<br>argument n.争论，辩论；理由<br>arise vi.出现；由…引起<br>arithmetic n.算术，四则运算<br>arm n.臂；臂状物；武器<br>army n.军队；陆军<br>around prep.在…周围<br>arouse vt.引起，唤起；唤醒<br>arrange vt.筹备；整理；调解<br>arrangement n.整理，排列；安排<br>arrest vt.逮捕，拘留；阻止<br>arrival n.到达；到来；到达者<br>arrive vi.到达；来临；达到<br>arrow n.箭；箭状物<br>art n.艺术，美术；技术<br>article n.文章；条款；物品<br>artificial a.人工的；娇揉造作的<br>artist n.艺术家，美术家<br>artistic a.艺术的；艺术家的<br>as conj.当…的时候<br>ash n.灰，灰末；骨灰<br>ashamed a.惭愧(的)；羞耻 (的)<br>Asia n.亚洲<br>Asian a.亚洲的 n.亚洲人<br>aside ad.在旁边，到旁边<br>ask vt.问；要求；邀请<br>asleep a.睡着的，睡熟的<br>aspect n.方面；样子，外表<br>    assemble vt.集合，召集；装配<br>assembly n.集合；集会；装配<br>assess vt.对(财产等 )估价<br>assign vt.指派；分配；指定<br>assignment n.任务，指定的作业<br>assist vt.援助，帮助；搀扶<br>assistant n.助手，助理；助教<br>associate vi.交往 n.伙伴，同事<br>association n.协会，团体；联合<br>assume vt.假定；承担；呈现<br>assure vt.使确信；向…保证<br>    astonish vt.使惊讶，使吃惊<br>astronaut n.宇宙航行员，宇航员<br>at prep.在…里；在…时<br>athlete n.运动员；田径运动员<br>Atlantic a.大西洋的 n.大西洋<br>atmosphere n.大气；空气；气氛<br>atmospheric a.大气的；大气层的<br>atom n.原子；微粒；微量<br>atomic a.原子的；原子能的<br>attach vt.缚，系，贴；附加<br>attack vt.&amp;vi.&amp;n. 攻击，进攻<br>attain vt.达到，获得，完成<br>attempt vt.尝试，试图 n.企图<br>attend vt.出席；照顾，护理<br>attention n.注意，留心；注意力<br>attentive a.注意的；有礼貌的<br>attitude n.态度，看法；姿势<br>attract vt.吸引；引起，诱惑<br>attraction n.吸引；吸引力；引力<br>attractive a.有吸引力的<br>attribute vt.把…归因于 n.属性<br>audience n.听众，观众，读者<br>August n.八月<br>aunt n.伯母，婶母，姑母<br>    aural a.耳的，听觉的<br>Australia n.澳大利亚<br>Australian a.澳大利亚的<br>author n.作者，作家<br>authority n.当局，官方；权力<br>auto n.(口语)汽车<br>automatic a.自动的；机械的<br>automation n.自动，自动化<br>automobile n.汽车，机动车<br>autumn n.秋，秋季<br>    auxiliary a.辅助的；附属的<br>available a.可利用的；通用的<br>    avenue n.林荫道，道路；大街<br>average n.平均数 a.平均的<br>    aviation n.航空，航空学<br>avoid vt.避免，躲开；撤消<br>await vt.等候，期待<br>awake a.醒着的 vt.唤醒<br>award n.奖，奖品；判定<br>aware a.知道的，意识到的<br>away ad.离开，远离；…去<br>    awful a.令人不愉快的<br>awfully ad.令人畏惧的；很<br>    awkward a.笨拙的；尴尬的<br>ax n.斧子<br>axis n.轴，轴线；中心线<br>baby n.婴儿；孩子气的人<br>back ad.在后；回原处；回<br>background n.背景，后景，经历<br>backward a.向后的；倒的 ad.倒<br>    bacteria n.细菌<br>bad a.坏的，恶的；严重的<br>badly ad.坏，差；严重地<br>badminton n.羽毛球<br>bag n.袋，包，钱包，背包<br>    baggage n.行李<br>bake vt.烤，烘，焙；烧硬<br>balance vt.使平衡；称 n.天平<br>ball n.球，球状物；舞会<br>balloon n.气球，玩具气球<br>banana n.香蕉；芭蕉属植物<br>band n.乐队；带；波段<br>bang n.巨响，枪声；猛击<br>bank n.银行；库；岩，堤<br>banner n.旗，旗帜，横幅<br>bar n.酒吧间；条，杆；栅<br>barber n.理发师<br>    bare a.赤裸的；仅仅的<br>bargain n.交易 vi.议价；成交<br>bark n.吠叫声 vi.吠，叫<br>    barn n.谷仓；牲口棚<br>    barrel n.桶；圆筒；枪管<br>    barrier n.栅栏，屏障；障碍<br>base n.基础，底层；基地<br>basic a.基本的，基础的<br>basically ad.基本上<br>basin n.盆，洗脸盆；盆地<br>basis n.基础，根据<br>basket n.篮，篓，筐<br>basketball n.篮球；篮球运动<br>bat n.球拍；短棍；蝙蝠<br>bath n.浴，洗澡；浴缸<br>bathe vt.给…洗澡；弄湿<br>bathroom n.浴室；盥洗室<br>battery n.电池；一套，一组<br>battle n.战役；斗争 vi.作战<br>bay n.湾；山脉中的凹处<br>B.C. (缩)公元前<br>be aux.v.&amp;vi.是，在，做<br>beach n.海滩，湖滩，河滩<br>    beam n.梁；横梁；束，柱<br>bean n.豆，蚕豆<br>bear n.熊；粗鲁的人<br>bear vt.容忍；负担；生育<br>beard n.胡须，络腮胡子<br>beast n.兽，野兽；牲畜<br>beat vt.&amp;vi.打，敲；打败<br>beautiful a.美的，美丽的<br>beauty n.美，美丽；美人<br>because conj.由于，因为<br>become vi.变成；成为，变得<br>bed n.床，床位；圃；河床<br>bee n.蜂，密蜂；忙碌的人<br>beef n.牛肉；菜牛<br>beer n.啤酒<br>before prep.在…以前；向…<br>beg vt.&amp;vi.乞求；请求<br>beggar n.乞丐，穷人<br>begin vi.开始 vt.开始<br>beginner n.初学者，生手<br>beginning n.开始，开端；起源<br>behalf n.利益，维护，支持<br>behave vi.表现，举止；运转<br>behavior n.行为，举止，态度<br>behind prep.在…后面<br>being n.存在；生物；生命<br>belief n.信任，相信；信念<br>believe vt.相信；认为<br>bell n.钟，铃，门铃；钟声<br>belong vi.属于，附属<br>beloved a.为…的爱的 n.爱人<br>below prep.在…下面 (以下)<br>belt n.带，腰带；皮带；区<br>bench n.长凳，条凳；工作台<br>bend vt.使弯曲 vi.弯曲<br>beneath prep.在…下方<br>beneficial a.有利的，有益的<br>benefit n.利益；恩惠；津贴<br>berry n.浆果(如草莓等 )<br>beside prep.在…旁边<br>besides ad.而且 prep.除…之外<br>best a.最好的；最大的<br>bet vt.&amp;vi.&amp;n. 打赌<br>    betray vt.背叛；辜负；泄漏<br>better a.较好的 ad.更好地<br>between prep.在…中间<br>beyond prep.在…的那边<br>Bible n.基督教《圣经》<br>bicycle n.自行车，脚踏车<br>big a.大的，巨大的<br>bike n.自行车 vi.骑自行车<br>bill n.账单；招贴；票据<br>billion num. 万亿(英)<br>bind vt.捆绑；包扎；装钉<br>biology n.生物学；生态学<br>bird n.鸟，禽<br>birthday n.生日，诞生的日期<br>biscuit n.(英)饼干； (美)软饼<br>bit n.一点，一些，小片<br>bite vt.咬，叮，螫；剌穿<br>bitter a.痛苦的；严寒的<br>bitterly ad.苦苦地；悲痛地<br>black a.黑色的；黑暗的<br>blackboard n.黑板<br>    blade n.刀刃，刀片；叶片<br>    blame vt.责备，把…归咎于<br>blank a.空白的 n.空白<br>blanket n.毛毯，毯子，羊毛毯<br>blast n.爆炸，冲击波 vt.炸<br>    blaze n.火；闪光 vi.燃烧<br>bleed vi.出血，流血；泌脂<br>blend vt.&amp;vi.&amp;n. 混和<br>bless vt.为…祝福<br>    blind a.瞎的；盲目的<br>block n.街区 vt.堵塞，拦阻<br>blood n.血，血液；血统<br>bloom n.花；开花，开花期<br>blossom n.花，开花 vi.开花<br>blow vi. 吹，吹动；吹响<br>blue a.蓝色的 n.蓝色<br>board n.板 vt.上(船、车等 )<br>boast vi.自夸 vt.吹嘘<br>boat n.小船，艇；渔船<br>body n.身体；主体；尸体<br>boil vi. 沸腾；汽化 vt.煮沸<br>    bold a.大胆的；冒失的<br>    bolt n.螺栓；插销 vt.闩门<br>    bomb n.BoB!!! vt. 轰炸<br>bond n.联结，联系；公债<br>bone n.骨，骨骼<br>book n.书，书籍 vt.预定<br>boot n.靴子，长统靴<br>booth n.货摊；公用电话亭<br>border n.边，边缘；边界<br>bore vt.使厌烦；钻，挖<br>born a.天生的；出生的<br>borrow vt.借，借用，借人<br>bosom n.胸，胸部；内心<br>boss n.老板，上司 vt.指挥<br>both pron.两者(都)<br>bother vt.烦扰，迷惑 n.麻烦<br>bottle n.瓶，酒瓶；一瓶<br>bottom n.底，底部，根基<br>bough n.树枝<br>bounce vi.反跳，弹起；跳起<br>bound a.一定的；有义务的<br>boundary n.分界线，办界<br>bow n.弓；蝴蝶结；鞠躬<br>bowl n.碗，钵；碗状物<br>box n.箱，盒；包箱<br>box vi.拳击，打拳<br>boy n.男孩，少年；家伙<br>brain n.脑，脑髓；脑力<br>brake n.闸，刹车 vi.制动<br>branch n.树枝；分部；分科<br>brand n.商品；烙印 vt.铭刻<br>    brandy n.白兰地酒<br>    brass n.黄铜；黄铜器<br>brave a.勇敢的，华丽的<br>    bread n.面包；食物，粮食<br>    breadth n.宽度，幅度；幅面<br>break vt.打破；损坏；破坏<br>breakfast n.早饭，早餐<br>breast n.乳房；胸脯，胸膛<br>breath n.气息，呼吸；气味<br>breathe vi.呼吸 vt.呼吸<br>breed n.品种 vt.使繁殖<br>    breeze n.微风，和风<br>brick n.砖，砖块；砖状物<br>    bridge n.桥，桥梁；桥牌<br>brief a.简短的；短暂的<br>bright a.明亮的；聪明的<br>brighten vt.使发光；使快活<br>brilliant a.光辉的；卓越的<br>    brim n.边，边缘；帽沿<br>bring vt.带来；引出；促使<br>brisk a.活泼的；清新的<br>    bristle n.短而硬的毛；鬃毛<br>Britain n.不列颠，英国<br>British a.不列颠的，英联邦的<br>    brittle a.脆的；易损坏的<br>broad a.宽的，阔的；广泛的<br>broadcast n.广播，播音<br>broken a.被打碎的，骨折的<br>    bronze n.青铜；青铜制品<br>    brood n.同窝幼鸟 vt.孵(蛋)<br>    brook n.小河，溪流<br>broom n.扫帚<br>    brother n.兄弟；同事，同胞<br>brow n.额；眉，眉毛<br>brown n.褐色，棕色<br>    bruise n.青肿，伤痕；擦伤<br>    brush n.刷子，毛刷；画笔<br>    brute n.禽兽，畜生<br>    bubble n.泡 vi.冒泡，沸腾<br>    bucket n.水桶；吊桶；铲斗<br>    bud n.芽，萌芽；蓓蕾<br>build vt.建筑；建立；创立<br>building n.建筑物，大楼；建筑<br>bulb n.电灯泡；球状物<br>bulk n.物体，容积，大批<br>bull n.公牛；雄的象<br>bullet n.枪弹，子弹，弹丸<br>bunch n.束，球，串；一群<br>    bundle n.捆，包，束；包袱<br>burden n.担子，重担；装载量<br>    bureau n.局，司，处；社，所<br>burn vi.烧，燃烧 n.烧伤<br>burst vt.使爆裂 vi.&amp;n. 爆炸<br>bury vt.埋葬，葬；埋藏<br>bus n.公共汽车<br>bush n.灌木，灌木丛，矮树<br>business n.商业，生意；事务<br>busy a.忙的，繁忙的<br>but conj.但是，可是<br>    butcher n.屠夫；屠杀者<br>butter n.黄油；奶油<br>butterfly n.蝴蝶<br>button n.扣子；按钮 vt.扣紧<br>buy vt.买，购买 vi.买<br>by prep.在…旁；被，由<br>cabbage n.洋白菜，卷心菜<br>    cabin n.小屋；船舱，机舱<br>    cabinet n.橱，柜；内阁<br>    cable n.缆，索；电缆；电报<br>cafe n.咖啡馆；小餐厅<br>cafeteria n.自助食堂<br>cage n.笼；鸟笼，囚笼<br>cake n.饼，糕，蛋糕<br>    calculate vt.计算；估计；计划<br>calculation n.计算，计算结果<br>calculator n.计算器，计算者<br>calendar n.日历，历书；历法<br>call vt.把…叫做；叫，喊<br>    calm a.静的，平静的<br>camel n.骆驼<br>camera n.照相机，摄影机<br>camp n.野营，营地，兵营<br>campaign n.战役；运动<br>campus n.校园，学校场地<br>can aux.v.能，会，可能<br>can n.罐头，听头；容器<br>Canada n.加拿大<br>Canadian a.加拿大的<br>canal n.运河；沟渠；管<br>cancel vt.取消，撤消；删去<br>cancer n.癌，癌症，肿瘤<br>candidate n.候选人；投考者<br>    candle n.蜡烛；烛形物；烛光<br>candy n.糖果；砂糖结晶<br>cannon n.大炮，火炮；榴弹炮<br>    canoe n.独木舟，皮艇，划子<br>    canteen n.小卖部；临时餐室<br>canvas n.粗帆布；一块油画布<br>cap n.帽子，便帽；帽状物<br>capable a.有能力的，有才能的<br>capacity n.容量；能力；能量<br>capital n.资本，资金；首都<br>captain n.陆军上尉；队长<br>captive n.俘虏，被监禁的人<br>capture vt.捕获，俘获；夺得<br>car n.汽车，小汽车，轿车<br>carbon n.碳<br>card n.卡，卡片，名片<br>care vi.关心，介意 n.小心<br>career n.生涯，职业，经历<br>careful a.仔细的；细致的<br>careless a.粗心的，漫不经心的<br>cargo n.船货，货物<br>carpenter n.木工，木匠<br>carpet n.地毯，毡毯，毛毯<br>carriage n.客车厢；四轮马车<br>carrier n.运输工具；运载工具<br>carrot n.胡罗卜<br>carry vt.携带；运载；传送<br>cart n.二轮运货马车<br>carve vt.刻，雕刻；切开<br>case n.情况；事实；病例<br>case n.箱(子)，盒(子)，套<br>cash n.现金，现款<br>cassette n.盒式录音带；盒子<br>cast vt.投，扔，抛；浇铸<br>    castle n.城堡；巨大建筑物<br>casual a.偶然的；随便的<br>cat n.猫，猫科，猫皮<br>catalog n.目录，目录册<br>catch vt.捉住；赶上；领会<br>    cathedral n.总教堂；大教堂<br>cattle n.牛；牲口，家畜<br>cause n.原因，理由；事业<br>cave n.山洞，洞穴，窑洞<br>    cease vi.&amp;vi.&amp;n.停止，停息<br>ceiling n.天花板，顶蓬<br>celebrate vt.庆祝；歌颂，赞美<br>cell n.细胞；小房间<br>cellar n.地窑，地下室<br>cement n.水泥；胶泥 vt.粘结<br>cent n.分；分币；百<br>centigrade a.百分度的<br>centimetre n.公分，厘米<br>central a.中心的；主要的<br>centre n.中心；中枢 vt.集中<br>century n.世纪，百年<br>ceremony n.典礼，仪式；礼节<br>certain a.确实的；肯定的<br>certainly ad.一定，必定；当然<br>certainty n.必然；肯定<br>certificate n.证书，证件，执照<br>chain n.链，链条，项圈<br>chair n.椅子；主席<br>chairman n.主席；议长，会长<br>    chalk n.白垩；粉笔<br>challenge n.挑战；要求，需要<br>    chamber n.会议室；房间；腔<br>champion n.冠军，得胜者<br>chance n.机会，机遇；可能性<br>change n.改变，变化；零钱<br>channel n.海峡；渠道；频道<br>chapter n.章，回，篇<br>character n.性格；特性；角色<br>characteristic a.特有的 n.特性<br>charge vt.索价；控告 n.费用<br>charity n.施舍；慈善事业<br>charming a.迷人的，可爱的<br>chart n.图，图表；海图<br>chase n.追逐，追赶，追求<br>cheap a.廉价的；劣质的<br>cheat vt.骗取；哄 vi.行骗<br>check vt.检查；制止 n.检查<br>cheek n.面颊，脸蛋<br>cheer vt.使振作；欢呼<br>cheerful a.快乐的，愉快的<br>cheese n.乳酪，干酪<br>chemical a.化学的 n.化学制品<br>chemist n.化学家；药剂师<br>    chemistry n.化学<br>    cheque n.支票<br>    cherry n.樱桃；樱桃树<br>chess n.棋；国际象棋<br>chest n.胸腔，胸膛；箱子<br>    chew vt.咀嚼，嚼碎<br>chicken n.小鸡，小鸟；鸡肉<br>chief a.主要的；首席的<br>child n.小孩，儿童；儿子<br>childhood n.童年，幼年；早期<br>childish a.孩子的；幼稚的<br>chill vt. 使变冷 n.寒冷<br>chimney n.烟囱，烟筒；玻璃罩<br>chin n.颏，下巴<br>China n.中国<br>china n.瓷器，瓷料<br>Chinese a.中国的 n.中国人<br>chocolate n.巧克力；巧克力糖<br>choice n.选择，抉择<br>choke vt.使窒息；塞满<br>choose vt.选择，挑选；情愿<br>chop vt.砍，劈；切细 vi.砍<br>Christian n.基督教徒；信徒<br>Christmas n.圣诞节</p>
]]></content>
  </entry>
  <entry>
    <title>学习记录</title>
    <url>/2021/05/13/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>2021-5-25<br>idea启动tomcat，8080端口被占，已解决<br><a href="https://blog.csdn.net/qq_33198758/article/details/82924561?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">https://blog.csdn.net/qq_33198758/article/details/82924561?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
<p>tomcat启动项目报错：<br>    查看tomcat日志： C:\Users\（用户名）.IntelliJIdea2017.3\system\tomcat  </p>
<pre><code>错误信息：Error during artifact deployment. See server log for details.
    解决办法：https://blog.csdn.net/qq_39095899/article/details/106604228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162192913216780255278525%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162192913216780255278525&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-7-106604228.first_rank_v2_pc_rank_v29&amp;utm_term=Error+during+artifact+deployment.+See+server+log+for+details.&amp;spm=1018.2226.3001.4187</code></pre><p>【cmd命令】‘netstat’不是内部命令：<br><a href="https://blog.csdn.net/m18633778874/article/details/80441536?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162280993916780264039009%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162280993916780264039009&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80441536.first_rank_v2_pc_rank_v29&amp;utm_term=netstat%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/m18633778874/article/details/80441536?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162280993916780264039009%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162280993916780264039009&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80441536.first_rank_v2_pc_rank_v29&amp;utm_term=netstat%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187</a></p>
<p>UTF-8的BOM：<br>    <a href="https://blog.csdn.net/qq_38929030/article/details/73920996?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs" target="_blank" rel="noopener">https://blog.csdn.net/qq_38929030/article/details/73920996?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-13.baidujs</a></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>数学建模比赛</title>
    <url>/2021/05/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="指数增长-Malthus-模型"><a href="#指数增长-Malthus-模型" class="headerlink" title="指数增长(Malthus)模型:"></a>指数增长(Malthus)模型:</h1><pre><code>1:https://blog.csdn.net/weixin_43441742/article/details/99622081

2:https://blog.csdn.net/weixin_46308081/article/details/115640828?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162160078716780274133193%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162160078716780274133193&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-115640828.first_rank_v2_pc_rank_v29&amp;utm_term=Malthus&amp;spm=1018.2226.3001.4187
3:

提出和假设：
    指数增长模型，由马尔萨斯在1798年提出
    基本假设：人口（相对）增长率r是常数（r很小）
    相对增长率 = 出生率 － 死亡率</code></pre><a id="more"></a>
<p>上课培训：</p>
<p>中国大学生在线网站，穿越沙漠赛题<br>不要就题论题，寻一个一般性的数学模型，解决特定问题<br>文献查阅能力 把方程拿过来用，不需要搞太清楚</p>
<p>学习建模能力最重要</p>
<p>赛题结构：实际问题背景，若干假设条件，要求回答问题</p>
<p>标题，摘要部分很重要。</p>
<p>题目：写出比较确切的题目</p>
<p>论文排版问题</p>
<p>层次分析法（AHP）：一种定性和定量相结合，系统化的，层次化的分析方法   </p>
<pre><code>适用于评价类问题

特点：半定型，半定量问题转化为定量问题的行之有效的一种方法，使人们的思维过程层次化。

用途：通过逐层比较多种关联因素为 分析评估，决策，预测，或者控制事物的法发展提供定量依据，适用于难于完全定量方法进行分析的复杂问题

层次结构：目标层，准则层，方案层

步骤：
    one：构造两两比较矩阵，对于同一层次的各因素关于上一层中某一目标的重要性进行两两比较
    two：由比较矩阵计算被比较因素对每一准则的相对权重，并进行判断矩阵的一致性检验。
    three：计算方案层对目标层的组合权重，并进行排序。</code></pre><p>微分和差分    </p>
<p>概率与统计：<br>    伯努利方程，泊松分布，正态分布。<br>    正态分布：期望就是平均数，什么时候是正态分布：多个因素影响最后结果。</p>
<pre><code>生命问题还有器件的使用寿命问题----&gt;指数分布

统计：在总体中抽出个别的样本，看样本来分析总体

极大似然估计法

假设检验：
    基本步骤：1假设      H0----&gt;真         H1—----&gt;假</code></pre><p>论文写作：多个方法作对比，进行分析，做写点总结性话语</p>
]]></content>
  </entry>
  <entry>
    <title>学习资源链接</title>
    <url>/2021/05/04/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="MySQL系列学习目录："><a href="#MySQL系列学习目录：" class="headerlink" title="MySQL系列学习目录："></a>MySQL系列学习目录：</h2><h3 id="MYSQL文章学习："><a href="#MYSQL文章学习：" class="headerlink" title="MYSQL文章学习："></a>MYSQL文章学习：</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933257&idx=1&sn=0f0086a2465a2fcae13d3fea65064803&chksm=88621bb7bf1592a1ac94fe4107ba1ef26a0fa97e1bf9aea7279009d8bd240f1ef7d27aa10393&token=1876080189&lang=zh_CN#rd" target="_blank" rel="noopener">第一篇:MySQL基础</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933270&idx=1&sn=409080e17352da2035b0bfdf63ccdfde&chksm=88621ba8bf1592beb2ef6106d6bf9f3eccd48d6814c7031f36e3c8be68821f17cf065129688c&token=1876080189&lang=zh_CN#rd" target="_blank" rel="noopener">第二篇:详解MySQL数据类型</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933279&idx=1&sn=f8591b95362cb3c352d895b1289d665a&chksm=88621ba1bf1592b72a43a62e3f310695e8b87f17932d052145622c3edbb70ef8cb987849fc3e&token=516655478&lang=zh_CN#rd" target="_blank" rel="noopener">第三篇:管理员必备技能（必须掌握）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933289&idx=1&sn=c4f212c312ea86e08ad322caddd05e38&chksm=88621b97bf159281156ee3be510a1a15234531d2c97d66957e67377829ab23779809ea55bbde&token=1484565200&lang=zh_CN#rd" target="_blank" rel="noopener">第四篇:DDL常见操作</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933296&idx=1&sn=1c56256d60c5847a944d87c8cfc9c14d&chksm=88621b8ebf159298b0789e2994d2aaf8b582effc7d8c1ba715deaca11c86a9dc8ac730878dc0&token=2000571846&lang=zh_CN#rd" target="_blank" rel="noopener">第五篇:DML操作汇总（insert，update，delete）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933300&idx=1&sn=bedef4d430dc76141e42e42ef6acfaa6&chksm=88621b8abf15929caae7904019c946a396885a33855ca465bacdd4187538005ebc3c116888f5&token=1814800041&lang=zh_CN#rd" target="_blank" rel="noopener">第六篇:select查询基础篇</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933305&idx=1&sn=2c5ba0bea6fcdd57d86cecd63541f91a&chksm=88621b87bf1592915086c1e945119fcc95af6aa1127b90ef1b56b018083bfd787ad95efde918&token=1144227002&lang=zh_CN#rd" target="_blank" rel="noopener">第七篇:玩转select条件查询，避免采坑</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933309&idx=1&sn=0f7dfec8bc70e67daa7159ee219325b8&chksm=88621b83bf1592951d949179061f39a1f4266b2879bc9a25af4da3b4b29f69ab1fcc595a462f&token=516674265&lang=zh_CN#rd" target="_blank" rel="noopener">第八篇:详解排序和分页(order by &amp; limit)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933315&idx=1&sn=4abf2b34a53a85cbd4a3b9ee31fcd398&chksm=88621bfdbf1592eb6a5a13202588dde9068ac7e6391d8dbf3fde33647bf0e044839ba4228216&token=1937580929&lang=zh_CN#rd" target="_blank" rel="noopener">第九篇:分组查询详解(group by &amp; having)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933321&idx=1&sn=110f6cacb90845bf2327fbcd7acd708c&chksm=88621bf7bf1592e1f1c0f2f01e40d4bd63a48d98daa4ba1157ecad4c6c6520d18b4b2c24c906&token=1096041061&lang=zh_CN#rd" target="_blank" rel="noopener">第十篇:常用的几十个函数详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933325&idx=1&sn=33274227db275a3570e1e43ccdd4f49c&chksm=88621bf3bf1592e5b75f537e21961c4295fafb782dbf31c0c1cbf9e36f5f4ed44d31cdad68b3&token=1832579722&lang=zh_CN#rd" target="_blank" rel="noopener">第十一篇:深入了解连接查询及原理</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933342&idx=2&sn=2e41daa0926a9c32d5fddd23590391aa&chksm=88621be0bf1592f66904a184858df7c11129e8b545c7626b8b6c1fcc32d3dfdd9ab21aeda8e5&token=386795745&lang=zh_CN#rd" target="_blank" rel="noopener">第十二篇:子查询</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933349&idx=1&sn=6e81f9046119cda43f8eb602d1139ef0&chksm=88621bdbbf1592cd9a20ec4715fe9f9459d079b641b04f607999c106cd52453d8c8508d939d7&token=386795745&lang=zh_CN#rd" target="_blank" rel="noopener">第十三篇:细说NULL导致的神坑，让人防不胜防</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933355&idx=1&sn=b426ad28dfc2a64bba813df5b7c341a4&chksm=88621bd5bf1592c3c08e441398f699d0a4c2303a51519aac169447f22765cc613dfc3d991f8b&token=385335213&lang=zh_CN#rd" target="_blank" rel="noopener">第十四篇:详解事务</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933370&idx=1&sn=4fe9b8e2aba766988c503737d34d9836&chksm=88621bc4bf1592d2b06d659884bf9881bd207a042ac36176f12808bd72f235e8e3404366259e&token=84059034&lang=zh_CN#rd" target="_blank" rel="noopener">第十五篇:详解视图</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933374&idx=1&sn=c294b6a69564a4c98d4c0cb29aeb9ac0&chksm=88621bc0bf1592d650752c44ca50540c1fa0c88c0a514019f1317559e13098de7dac37ddfc05&token=1531009350&lang=zh_CN#rd" target="_blank" rel="noopener">第十六篇:变量详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933382&idx=1&sn=4cf80b4f50c80dcc8171d2128b47cf63&chksm=88621c38bf15952e193177a0ba3e03beeaeed996553ce6900f91518310332e99c915e8be2566&token=1341741305&lang=zh_CN#rd" target="_blank" rel="noopener">第十七篇:存储过程&amp;自定义函数详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933388&idx=1&sn=59cb1d23845e45894bb72c1e2479f074&chksm=88621c32bf1595241573e4194912ca60a51eb8477f4b49492e26668c9bebc032e9d6672e7fdd&token=1832749573&lang=zh_CN#rd" target="_blank" rel="noopener">第十八篇:流程控制语句</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933392&idx=1&sn=ff29e380b42a0aa7cb1dc7659d745686&chksm=88621c2ebf1595380f99d9c4c89581638a27a5cf356de35d31aa9ae7ac17e63abe0e4adc813c&token=1479782197&lang=zh_CN#rd" target="_blank" rel="noopener">第十九篇:游标详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933396&idx=1&sn=b6cc5d5287bf43d94e6706fa217aa8cb&chksm=88621c2abf15953c3200c6d4d945ad70bdd2177f020f8e2229ae269153bbc8bf251af83e1135&token=1846211483&lang=zh_CN#rd" target="_blank" rel="noopener">第二十篇:异常捕获及处理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933400&idx=1&sn=61af771f10342ee4956efea6749abd71&chksm=88621c26bf15953041a6bc65734edf788af711ff176ad36884fe6411e5c4cfd0bf967e0e33fc&token=1781447741&lang=zh_CN#rd" target="_blank" rel="noopener">第二十一篇:什么是索引?</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933422&idx=1&sn=f28a92c195d914d636117c2316524c5e&chksm=88621c10bf159506af8a3c6b947e32b11414ff72ed3ad19a9fa0b0cec0be6c3ae3931117b3d2&token=1928746279&lang=zh_CN#rd" target="_blank" rel="noopener">第二十二篇:mysql索引原理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933427&idx=1&sn=d9cb0317b50c76519291d2e4311b887f&chksm=88621c0dbf15951b1d4d37da57f88a7b026d2bb656234a738f8660be4c5750f82300c20be779&token=410060235&lang=zh_CN#rd" target="_blank" rel="noopener">第二十三篇:mysql索引管理详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933439&idx=1&sn=a1eddd36a6f597b9cd43e39e9f1b9d76&chksm=88621c01bf1595175894d27c996a49c9305c59bf23250f165943f91fcf35076813cf832985f7&token=410060235&lang=zh_CN#rd" target="_blank" rel="noopener">第二十四篇:如何正确的使用索引?</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933444&idx=1&sn=2d0c3ca9ba1275aa9dceac367d7b21a9&chksm=88621c7abf15956c9fae6cb4e68663263979a9aef7bec617c235032b03bc874e2dab0ef28fe1&token=164798892&lang=zh_CN#rd" target="_blank" rel="noopener">第二十五篇:sql中where条件在数据库中提取与应用浅析</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933457&idx=1&sn=b1e9e38bdcc3e3cf5e67e040ab4a4f94&chksm=88621c6fbf1595793a369015b88df0332c6bfab43ff6a8b35423797beaacf0f9632132e353e4&token=164798892&lang=zh_CN#rd" target="_blank" rel="noopener">第二十六篇：聊聊mysql如何实现分布式锁?</a></p>
<h3 id="MYSQL视频学习："><a href="#MYSQL视频学习：" class="headerlink" title="MYSQL视频学习："></a>MYSQL视频学习：</h3><p><a href="https://www.bilibili.com/video/BV1Vt411z7wy" target="_blank" rel="noopener">b站MYSQL基础课</a></p>
<p><a href="https://www.bilibili.com/video/BV1hE411V7vu" target="_blank" rel="noopener">数据库关系代数</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ez411b7hb/?spm_id_from=333.788.recommend_more_video.-1" target="_blank" rel="noopener">关系代数操作哈工大</a></p>
<h2 id="机器学习相关资料"><a href="#机器学习相关资料" class="headerlink" title="机器学习相关资料:"></a>机器学习相关资料:</h2><h3 id="吴恩达机器学习系列课程"><a href="#吴恩达机器学习系列课程" class="headerlink" title="吴恩达机器学习系列课程"></a>吴恩达机器学习系列课程</h3><p><a href="http://www.ai-start.com/ml2014/" target="_blank" rel="noopener">斯坦福大学2014机器学习教程中文笔记目录在线阅读</a><br><a href="https://www.bilibili.com/video/BV164411b7dx" target="_blank" rel="noopener">视频地址(中文字幕版):</a><br><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">视频视频原地址(打开不流畅，建议b站观看):</a><br><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">吴恩达老师的机器学习课程个人笔记+资料+码源 github地址:</a></p>
<h3 id="学习网站："><a href="#学习网站：" class="headerlink" title="学习网站："></a>学习网站：</h3><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程（编程基础知识）</a></p>
<p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school（web技术教程）</a></p>
<p><a href="https://www.yiibai.com/" target="_blank" rel="noopener">易百教程</a></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2021/06/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>监督学习：就是我们给学习算法一个数据集，这个数据集由“正确答案”组成。</p>
<p>监督学习基本思想：我们每个数据集的每个样本都有相应的正确答案，再根据这些样本进行预测。</p>
<p>回归：就是我们推测这一系列连续值属性</p>
<p>分类：就是我们试着推测出离散的输出值，目标是推出一组离散的结果</p>
<p>无监督学习：无监督学习中没有任何标签或者是有相同的标签或者就是没有标签</p>
<p>聚类是无监督学习的一种</p>
<p>无监督学习：是一种学习策略，交给算法大量数据，并让算法为我们从数据中找出某种结构</p>
<p>代价函数也称为平方误差函数</p>
<p>梯度下降算法：一种用来求函数最小值的算法</p>
<p>正规方程：直接计算出函数最小值</p>
<p>正规方程和梯度下降：在数据量较大的时候，梯度下降法比正规方程更适用</p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>机器学习记录</title>
    <url>/2021/05/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="用来记录自己的的ML学习历程"><a href="#用来记录自己的的ML学习历程" class="headerlink" title="用来记录自己的的ML学习历程"></a>用来记录自己的的ML学习历程</h1><p>决策树：</p>
<p>KNN算法：<br>    参考文章：<a href="https://blog.csdn.net/pengjunlee/article/details/82713047" target="_blank" rel="noopener">https://blog.csdn.net/pengjunlee/article/details/82713047</a><br>    解释：看一个人怎么样，看她身边的朋友是什么样就知道了，寻找最近的K个数据，推测出新数据的分类<br>    指导思想：近朱者赤，近墨者黑<br>    KNN只根据临近的几个样本的类别进行分类，对于一些类域交叉或者重叠较多的待分类样本集来说，KNN方法较为适合。</p>
<pre><code>原理：
    通用步骤： 
        计算距离（常用欧几里得距离或者马氏距离） 
        升序排列
        取前K个
        加权平均
    K的选取：   
        K太大：导致分类模糊
        K太小：受个例影响，波动较大
    如何选取K:
        经验
        均方根误差

关键：
    样本的所有特征都可以进行量化，一些非数值类型，可以采取手段量化为数值，例如颜色可以进行灰度转换为灰度值，来实现距离计算。
    样本特征要作归一化处理，样本有很多参数，每个参数都有自己的定义域和取值范围，他们对距离计算的影响不一样，取值较大的类型会盖过较小的参数。所以样本参数必须做一些scale处理，最简单的方式就是所有的特征的数值都采取归一化处理。
    需要一个距离函数以计算两个样本之间的距离，通常使用的距离函数有：欧氏距离，余弦距离，汉明距离，曼哈顿距离等，一般选取欧式。
    欧式只适合于连续变量，在文本分类这种非连续变量情况下，汉明距离可以作为度量。
    通常情况下，如果运用一些特殊的算法来计算度量的话，KNN分类的精度可以显著提高，如：大边缘最近邻法或者近邻成分分析法。
        欧氏距离：高中的空间距离计算
        曼哈顿距离：|x1-x2|+|y1-y2|
    确定K的值：K值得选取，太大会产生欠拟合，太小容易过拟合，需要进行交叉验证确定K值
    KNN的优点：
        简单易于理解，易于实现，无需参数估计，无需训练；
        适合对稀有事件进行分类；
        特别适合于多分类问题（对象具有多个标签），KNN比SVM表现更好
    KNN的缺点：
        样本不平衡的时候， 该算法只计算最近的邻居样本，某一类的样本数量很大，或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。
        计算量较大。
KNN算法实现：
    步骤：
        算距离：给定待分类样本，计算它与已分类样本中每个样本的距离；
        找邻居：圈定与待分类样本距离最近的K个已分类样本，作为  待分类样本的近邻 ；
        做分类：根据这K个近邻中的大部分样本所属的类别来决定待分类样本该属于哪个分类；
    import math</code></pre><p>import csv<br>import operator<br>import random<br>import numpy as np<br>from sklearn.datasets import make_blobs</p>
<p>#Python version 3.6.5</p>
<h1 id="生成样本数据集-samples-样本数量-features-特征向量的维度-centers-类别个数"><a href="#生成样本数据集-samples-样本数量-features-特征向量的维度-centers-类别个数" class="headerlink" title="生成样本数据集 samples(样本数量) features(特征向量的维度) centers(类别个数)"></a>生成样本数据集 samples(样本数量) features(特征向量的维度) centers(类别个数)</h1><p>def createDataSet(samples=100, features=2, centers=2):<br>    return make_blobs(n_samples=samples, n_features=features, centers=centers, cluster_std=1.0, random_state=8)</p>
<h1 id="加载鸢尾花卉数据集-filename-数据集文件存放路径"><a href="#加载鸢尾花卉数据集-filename-数据集文件存放路径" class="headerlink" title="加载鸢尾花卉数据集 filename(数据集文件存放路径)"></a>加载鸢尾花卉数据集 filename(数据集文件存放路径)</h1><p>def loadIrisDataset(filename):<br>    with open(filename, ‘rt’) as csvfile:<br>        lines = csv.reader(csvfile)<br>        dataset = list(lines)<br>        for x in range(len(dataset)):<br>            for y in range(4):<br>                dataset[x][y] = float(dataset[x][y])<br>        return dataset</p>
<h1 id="拆分数据集-dataset-要拆分的数据集-split-训练集所占比例-trainingSet-训练集-testSet-测试集"><a href="#拆分数据集-dataset-要拆分的数据集-split-训练集所占比例-trainingSet-训练集-testSet-测试集" class="headerlink" title="拆分数据集 dataset(要拆分的数据集) split(训练集所占比例) trainingSet(训练集) testSet(测试集)"></a>拆分数据集 dataset(要拆分的数据集) split(训练集所占比例) trainingSet(训练集) testSet(测试集)</h1><p>def splitDataSet(dataSet, split, trainingSet=[], testSet=[]):<br>    for x in range(len(dataSet)):<br>        if random.random() &lt;= split:<br>            trainingSet.append(dataSet[x])<br>        else:<br>            testSet.append(dataSet[x])</p>
<h1 id="计算欧氏距离"><a href="#计算欧氏距离" class="headerlink" title="计算欧氏距离"></a>计算欧氏距离</h1><p>def euclideanDistance(instance1, instance2, length):<br>    distance = 0<br>    for x in range(length):<br>        distance += pow((instance1[x] - instance2[x]), 2)<br>    return math.sqrt(distance)</p>
<h1 id="选取距离最近的K个实例"><a href="#选取距离最近的K个实例" class="headerlink" title="选取距离最近的K个实例"></a>选取距离最近的K个实例</h1><p>def getNeighbors(trainingSet, testInstance, k):<br>    distances = []<br>    length = len(testInstance) - 1<br>    for x in range(len(trainingSet)):<br>        dist = euclideanDistance(testInstance, trainingSet[x], length)<br>        distances.append((trainingSet[x], dist))<br>    distances.sort(key=operator.itemgetter(1))</p>
<pre><code>neighbors = []
for x in range(k):
    neighbors.append(distances[x][0])
return neighbors</code></pre><h1 id="获取距离最近的K个实例中占比例较大的分类"><a href="#获取距离最近的K个实例中占比例较大的分类" class="headerlink" title="获取距离最近的K个实例中占比例较大的分类"></a>获取距离最近的K个实例中占比例较大的分类</h1><p>def getResponse(neighbors):<br>    classVotes = {}<br>    for x in range(len(neighbors)):<br>        response = neighbors[x][-1]<br>        if response in classVotes:<br>            classVotes[response] += 1<br>        else:<br>            classVotes[response] = 1<br>    sortedVotes = sorted(classVotes.items(), key=operator.itemgetter(1), reverse=True)<br>    return sortedVotes[0][0]</p>
<h1 id="计算准确率"><a href="#计算准确率" class="headerlink" title="计算准确率"></a>计算准确率</h1><p>def getAccuracy(testSet, predictions):<br>    correct = 0<br>    for x in range(len(testSet)):<br>        if testSet[x][-1] == predictions[x]:<br>            correct += 1<br>    return (correct / float(len(testSet))) * 100.0</p>
<p>def main():<br>    # 使用自定义创建的数据集进行分类<br>    # x,y = createDataSet(features=2)<br>    # dataSet= np.c_[x,y]</p>
<pre><code># 使用鸢尾花卉数据集进行分类
dataSet = loadIrisDataset(r&apos;C:\DevTolls\eclipse-pureh2b\python\DeepLearning\KNN\iris_dataset.txt&apos;)

print(dataSet)
trainingSet = []
testSet = []
splitDataSet(dataSet, 0.75, trainingSet, testSet)
print(&apos;Train set:&apos; + repr(len(trainingSet)))
print(&apos;Test set:&apos; + repr(len(testSet)))
predictions = []
k = 7
for x in range(len(testSet)):
    neighbors = getNeighbors(trainingSet, testSet[x], k)
    result = getResponse(neighbors)
    predictions.append(result)
    print(&apos;&gt;predicted=&apos; + repr(result) + &apos;,actual=&apos; + repr(testSet[x][-1]))
accuracy = getAccuracy(testSet, predictions)
print(&apos;Accuracy: &apos; + repr(accuracy) + &apos;%&apos;)</code></pre><p>main()</p>
<p>尾花卉数据文件百度网盘下载链接：<a href="https://pan.baidu.com/s/10vI5p_QuM7esc-jkar2zdQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10vI5p_QuM7esc-jkar2zdQ</a> 密码：4und</p>
<pre><code>KNN算法应用：
    使用KNN算法处理简单分类任务
    在scikit-learn中，内置若干玩具数据集，还有API让我们可以自己来生成一些数据集。</code></pre>]]></content>
  </entry>
  <entry>
    <title>学习资料链接</title>
    <url>/2021/06/04/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>01 Java基础阶段：<br>链接:<a href="https://pan.baidu.com/s/1IGjSH_y8oSthPP3DDzauKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IGjSH_y8oSthPP3DDzauKw</a>  密码:koa9<br>02 数据库阶段：<br>链接:<a href="https://pan.baidu.com/s/1tzAzYP5CbPbaPgTeQ1tqZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tzAzYP5CbPbaPgTeQ1tqZw</a>  密码:sbog<br>03 Web前端：<br>链接:<a href="https://pan.baidu.com/s/1uVWEaJ9Ie8xu7BQle_7peQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1uVWEaJ9Ie8xu7BQle_7peQ</a>  密码:p0wy<br>04 Javaweb阶段：<br>链接:<a href="https://pan.baidu.com/s/1haw_v4KEWwXPg4-wnM3-9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1haw_v4KEWwXPg4-wnM3-9w</a>  密码:njpq<br>05 Web进阶：<br>链接:<a href="https://pan.baidu.com/s/1dAMOUJzqrMfX0Eg91k8m3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1dAMOUJzqrMfX0Eg91k8m3g</a>  密码:9w0s<br>06 Web项目实战：<br>链接:<a href="https://pan.baidu.com/s/1J-o7w-l_UT5InxM81raDkA" target="_blank" rel="noopener">https://pan.baidu.com/s/1J-o7w-l_UT5InxM81raDkA</a>  密码:ekn5<br>07 Java框架阶段：<br>链接:<a href="https://pan.baidu.com/s/104vUkuyV4VQz_G9ExraJuQ" target="_blank" rel="noopener">https://pan.baidu.com/s/104vUkuyV4VQz_G9ExraJuQ</a>  密码:2jqq<br>08 互联网分布式技术：<br>链接:<a href="https://pan.baidu.com/s/1cv8dng3Ht0p6LQmLFbvVwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1cv8dng3Ht0p6LQmLFbvVwg</a>  密码:6t3d<br>09 项目实战：<br>链接:<a href="https://pan.baidu.com/s/1UNfGhadLOrAmdsmePaO7Dw" target="_blank" rel="noopener">https://pan.baidu.com/s/1UNfGhadLOrAmdsmePaO7Dw</a>  密码:gplw<br>10 Java开发工具：<br>链接：<a href="https://pan.baidu.com/s/10bKNbe0Jx6wF1jx9TMhqZA" target="_blank" rel="noopener">https://pan.baidu.com/s/10bKNbe0Jx6wF1jx9TMhqZA</a> 提取码：krpc</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/06/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>计算机网络：<br>    是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及其网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>网络编程：<br>    在网络通信协议下，实现网络互联的不同计算机运行的程序间可以进行数据交换。</p>
<p>网络编程3要素：</p>
<pre><code>IP地址：
    要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

端口：
    网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识

协议：
    通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</code></pre><p>IP地址：网络中设备的唯一标识<br>    IPV4：为每个连接在网络上的主机分配的32bit的地址，也就是4字节，例如11000000 10101000 00000001 01000010，为一个ipv4的地址，利用点分十进制表示法可以看成192.168.1.66<br>    IPV6：v4的地址不够用，v6重新定义地址空间，采用128为地址长度，16字节一组，8组十六进制数，来解决网络地址不足的问题<br>    DOS常用命令：<br>        ipconfig：查看本机IP地址<br>        ping IP地址：检查网络是否连通<br>    特殊IP地址：<br>        127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</p>
]]></content>
  </entry>
</search>
